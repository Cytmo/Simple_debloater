{'xnmalloc': None, 'xnrealloc': None, 'x2nrealloc': ['  void *tmp;\n', '  {\n', '    n = * pn;\n', '    if (! p)\n', '    {\n', '      if (! n)\n', '      {\n', '        n = 128UL / s;\n', '      }\n', '    }\n', '    else\n', '    {\n', '      if ((0xaaaaaaaaaaaaaaaaUL / s) <= n)\n', '      {\n', '        {\n', '        }\n', '      }\n', '      n += (n / 2UL) + 1UL;\n', '    }\n', '    {\n', '      * pn = n;\n', '      tmp = xrealloc(p, n * s);\n', '    }\n', '    return tmp;\n', '  }\n', '}\n'], 'xmalloc': None, 'xrealloc': None, 'xzalloc': None, 'xcalloc': None, 'xmemdup': None, 'xstrdup': None, 'safe_read': ['  ssize_t tmp;\n', '  int *tmp___0;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          tmp = read(fd, buf, count);\n', '          result = tmp;\n', '        }\n', '        if (0L <= result)\n', '        {\n', '          return (size_t) result;\n', '        }\n', '        else\n', '        {\n', '          {\n', '          }\n', '          {\n', '            {\n', '            }\n', '            if ((* tmp___0) == 22)\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return 0UL;\n', '  }\n', '}\n'], 'set_program_name': ['  {\n', '    {\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'openat_safer': ['  int tmp;\n', '  int tmp___0;\n', '  {\n', '    {\n', '      {\n', '      }\n', '    }\n', '    {\n', '      tmp = openat(fd, file, flags, mode___0);\n', '      tmp___0 = fd_safer(tmp);\n', '    }\n', '    return tmp___0;\n', '  }\n', '}\n'], 'fd_safer': ['  {\n', '    if (0 <= fd)\n', '    {\n', '      if (fd <= 2)\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    return fd;\n', '  }\n', '}\n'], 'init_colorize': None, 'close_stdout': ['  {\n', '    {\n', '    }\n', '  }\n', '}\n'], 'close_stream': ['  _Bool fclose_fail;\n', '  int *tmp___3;\n', '  {\n', '    {\n', '    }\n', '    {\n', '      if (fclose_fail)\n', '      {\n', '        {\n', '          {\n', '          }\n', '          if ((* tmp___3) != 9)\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '}\n'], 'set_binary_mode': None, 'to_uchar': None, 'tr': ['  int tmp___0;\n', '  {\n', '    {\n', '      tmp___0 = (int) c;\n', '    }\n', '    return (char) tmp___0;\n', '  }\n', '}\n'], 'kwsalloc': ['  struct kwset *tmp;\n', '  struct obstack *__h;\n', '  struct obstack *__o;\n', '  int __len;\n', '  struct obstack *__o1;\n', '  void *__value;\n', '  char *tmp___0;\n', '  char *tmp___1;\n', '  {\n', '    {\n', '      tmp = (struct kwset *) xmalloc(sizeof(* kwset___1));\n', '      kwset___1 = tmp;\n', '      _obstack_begin(& kwset___1->obstack, 0, 0, (void *(*)(long)) (& xmalloc), & free);\n', '      kwset___1->words = (ptrdiff_t) 0;\n', '      __h = & kwset___1->obstack;\n', '      __o = __h;\n', '    }\n', '    if ((__o->chunk_limit - __o->next_free) < ((long) __len))\n', '    {\n', '      {\n', '      }\n', '    }\n', '    __o->next_free += __len;\n', '    __o1 = __h;\n', '    __value = (void *) __o1->object_base;\n', '    {\n', '    }\n', '    if ((sizeof(long)) < (sizeof(void *)))\n', '    {\n', '      tmp___0 = __o1->object_base;\n', '    }\n', '    else\n', '    {\n', '      tmp___0 = (char *) 0;\n', '    }\n', '    if ((sizeof(long)) < (sizeof(void *)))\n', '    {\n', '      tmp___1 = __o1->object_base;\n', '    }\n', '    else\n', '    {\n', '      tmp___1 = (char *) 0;\n', '    }\n', '    {\n', '    }\n', '    __o1->object_base = __o1->next_free;\n', '    kwset___1->trie = (struct trie *) __value;\n', '    kwset___1->mind = 2147483647;\n', '  }\n', '}\n'], 'kwsincr': ['  unsigned char label___0;\n', '  struct tree *kwset_link;\n', '  struct tree *links[12];\n', '  enum __anonenum_dirs_58 dirs[12];\n', '  int depth___0;\n', '  struct obstack *__h;\n', '  struct obstack *__o;\n', '  int __len;\n', '  struct obstack *__o1;\n', '  void *__value;\n', '  char *tmp___2;\n', '  char *tmp___3;\n', '  struct obstack *__h___0;\n', '  struct obstack *__o___0;\n', '  int __len___0;\n', '  struct obstack *__o1___0;\n', '  void *__value___0;\n', '  char *tmp___4;\n', '  char *tmp___5;\n', '  struct tree *t;\n', '  struct tree *r;\n', '  struct tree *l;\n', '  size_t tmp___8;\n', '  {\n', '    trie = kwset___1->trie;\n', '    {\n', '      while (1)\n', '      {\n', '        tmp___8 = len;\n', '        len--;\n', '        if (! tmp___8)\n', '        {\n', '          goto while_break;\n', '        }\n', '        kwset_link = trie->links;\n', '        links[0] = (struct tree *) (& trie->links);\n', '        dirs[0] = (enum __anonenum_dirs_58) 0;\n', '        depth___0 = 1;\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '              goto while_break___0;\n', '            }\n', '            if (((int) label___0) < ((int) kwset_link->label))\n', '            {\n', '            }\n', '          }\n', '        }\n', '        while_break___0:\n', '        {\n', '          __h = & kwset___1->obstack;\n', '          __len = (int) (sizeof(* kwset_link));\n', '          {\n', '            {\n', '            }\n', '          }\n', '          __o->next_free += __len;\n', '          __o1 = __h;\n', '          __value = (void *) __o1->object_base;\n', '          {\n', '            tmp___2 = (char *) 0;\n', '          }\n', '          if ((sizeof(long)) < (sizeof(void *)))\n', '          {\n', '            tmp___3 = __o1->object_base;\n', '          }\n', '          else\n', '          {\n', '            tmp___3 = (char *) 0;\n', '          }\n', '          {\n', '          }\n', '          __o1->object_base = __o1->next_free;\n', '          kwset_link = (struct tree *) __value;\n', '          __h___0 = & kwset___1->obstack;\n', '          __o___0 = __h___0;\n', '          __len___0 = (int) (sizeof(* kwset_link->trie));\n', '          {\n', '            {\n', '            }\n', '          }\n', '          __o___0->next_free += __len___0;\n', '          __o1___0 = __h___0;\n', '          __value___0 = (void *) __o1___0->object_base;\n', '          {\n', '            tmp___4 = (char *) 0;\n', '          }\n', '          if ((sizeof(long)) < (sizeof(void *)))\n', '          {\n', '            tmp___5 = __o1___0->object_base;\n', '          }\n', '          else\n', '          {\n', '            tmp___5 = (char *) 0;\n', '          }\n', '          {\n', '          }\n', '          __o1___0->object_base = __o1___0->next_free;\n', '          kwset_link->trie = (struct trie *) __value___0;\n', '          kwset_link->trie->parent = trie;\n', '          kwset_link->trie->depth = trie->depth + 1;\n', '          depth___0--;\n', '          {\n', '            links[depth___0]->llink = kwset_link;\n', '            {\n', '              {\n', '              }\n', '            }\n', '          }\n', '          {\n', '            {\n', '              {\n', '                if (links[depth___0]->balance)\n', '                {\n', '                  ;\n', '                  r = links[depth___0];\n', '                  ;\n', '                  l = links[depth___0];\n', '                  {\n', '                  }\n', '                  if (((int) t->balance) != (- 1))\n', '                  {\n', '                  }\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '        trie = kwset_link->trie;\n', '      }\n', '    }\n', '    while_break:\n', '    kwset___1->words++;\n', '    {\n', '      kwset___1->mind = trie->depth;\n', '    }\n', '  }\n', '}\n'], 'enqueue': ['  {\n', '    if (! tree)\n', '    {\n', '      return;\n', '    }\n', '    {\n', '      tmp = tree->trie;\n', '      (* last)->next = tmp;\n', '      * last = tmp;\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'treefails': ['  {\n', '    if (! tree)\n', '    {\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '        kwset_link = (struct tree *) fail->links;\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'treedelta': ['    if (! tree)\n', '    {\n', '      return;\n', '    }\n', '    if (depth___0 < ((unsigned int) (* (delta + ((const int) tree->label)))))\n', '    {\n', '      * (delta + ((const int) tree->label)) = (unsigned char) depth___0;\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'hasevery': ['  {\n', '    if (! b)\n', '    {\n', '      {\n', '        if (a)\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'treenext': ['    if (! tree)\n', '    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'kwsprep': ['  int i;\n', '  unsigned char deltabuf[256];\n', '  unsigned char *delta;\n', '  unsigned char *tmp;\n', '  int tmp___0;\n', '  struct trie *curr;\n', '  struct trie *last;\n', '  struct trie *fail;\n', '  int tmp___1;\n', '  struct trie *nextbuf[256];\n', '  struct trie **next;\n', '  struct trie **tmp___2;\n', '  struct obstack *__h;\n', '  struct obstack *__o1;\n', '  void *__value;\n', '  char *tmp___4;\n', '  char *tmp___5;\n', '  struct obstack *__h___0;\n', '  struct obstack *__o1___0;\n', '  void *__value___0;\n', '  char *tmp___6;\n', '  char *tmp___7;\n', '  char gc1;\n', '  char tmp___8;\n', '  int gc1help;\n', '  const char *equiv2;\n', '  {\n', '    trans___0 = kwset___1->trans;\n', '    {\n', '      tmp = kwset___1->delta;\n', '    }\n', '    {\n', '      last = kwset___1->trie;\n', '      curr = last;\n', '    }\n', '    {\n', '      while (1)\n', '      {\n', '        if (! curr)\n', '        {\n', '          goto while_break;\n', '        }\n', '        {\n', '          enqueue(curr->links, & last);\n', '          curr->shift = kwset___1->mind;\n', '          {\n', '            {\n', '              goto while_break___0;\n', '            }\n', '            if (! tmp___1)\n', '            {\n', '              if ((curr->depth - fail->depth) < fail->shift)\n', '              {\n', '                fail->shift = curr->depth - fail->depth;\n', '              }\n', '            }\n', '            if (curr->accepting)\n', '            {\n', '              if (fail->maxshift > (curr->depth - fail->depth))\n', '              {\n', '                fail->maxshift = curr->depth - fail->depth;\n', '              }\n', '            }\n', '            fail = fail->fail;\n', '          }\n', '        }\n', '        while_break___0:\n', '        curr = curr->next;\n', '      }\n', '    }\n', '    while_break:\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break___1;\n', '        }\n', '        if (curr->maxshift > curr->parent->maxshift)\n', '        {\n', '          curr->maxshift = curr->parent->maxshift;\n', '        }\n', '        if (curr->shift > curr->maxshift)\n', '        {\n', '          curr->shift = curr->maxshift;\n', '        }\n', '        curr = curr->next;\n', '      }\n', '    }\n', '    while_break___1:\n', '    ;\n', '    {\n', '    }\n', '    if (trans___0)\n', '    {\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '          }\n', '          {\n', '          }\n', '        }\n', '      }\n', '    }\n', '    if (kwset___1->words == 1L)\n', '    {\n', '      __h = & kwset___1->obstack;\n', '      __o1 = __h;\n', '      __o1->next_free = tmp___4 + (((__o1->next_free - tmp___5) + ((long) __o1->alignment_mask)) & ((long) (~ __o1->alignment_mask)));\n', '      kwset___1->target = (char *) __value;\n', '      curr = kwset___1->trie;\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            goto while_break___3;\n', '          }\n', '          * (kwset___1->target + i) = (char) curr->links->label;\n', '        }\n', '        while_break___10:\n', '        ;\n', '      }\n', '      while_break___3:\n', '      {\n', '        __h___0 = & kwset___1->obstack;\n', '        {\n', '          tmp___6 = (char *) 0;\n', '        }\n', '        if ((sizeof(long)) < (sizeof(void *)))\n', '        {\n', '          tmp___7 = __o1___0->object_base;\n', '        }\n', '        else\n', '        {\n', '          tmp___7 = (char *) 0;\n', '        }\n', '        kwset___1->shift = (int *) __value___0;\n', '        i = 0;\n', '        {\n', '          while (1)\n', '          {\n', '            while_continue___4:\n', '            ;\n', '            if (! (i < (kwset___1->mind - 1)))\n', '            {\n', '              goto while_break___4;\n', '            }\n', '            * (kwset___1->shift + i) = curr->shift;\n', '            i++;\n', '          }\n', '          while_break___11:\n', '          ;\n', '        }\n', '        while_break___4:\n', '        gc1help = - 1;\n', '      }\n', '      if (trans___0)\n', '      {\n', '        {\n', '        }\n', '        if (equiv2)\n', '        {\n', '        }\n', '      }\n', '      kwset___1->gc1 = gc1;\n', '      kwset___1->gc1help = gc1help;\n', '      {\n', '        {\n', '          kwset___1->gc2 = tr(trans___0, * (kwset___1->target + (kwset___1->mind - 2)));\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'bm_delta2_search': ['  int d;\n', '  int skip;\n', '  int i;\n', '  char tmp___3;\n', '  {\n', '    tp = * tpp;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          i = 2;\n', '        }\n', '        if (((int) tmp___3) == ((int) gc2))\n', '        {\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '                {\n', '                  goto while_break___1;\n', '                }\n', '              }\n', '            }\n', '            while_break___1:\n', '            {\n', '            }\n', '          }\n', '        }\n', '        d = * (kwset___1->shift + (i - 2));\n', '        tp += d;\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '          goto while_break;\n', '        }\n', '        skip = i - 1;\n', '      }\n', '    }\n', '    while_break:\n', '    * tpp = tp;\n', '    return (_Bool) 0;\n', '  }\n', '}\n'], 'memchr_kwset': ['  {\n', '    if (kwset___1->gc1help < 0)\n', '    {\n', '      {\n', '        tmp = (const char *) memchr((const void *) s, (int) kwset___1->gc1, n);\n', '      }\n', '      return tmp;\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    {\n', '    }\n', '  }\n', '}\n'], 'bmexec_trans': ['  const char *tp;\n', '  long tmp;\n', '  {\n', '    {\n', '      {\n', '        tp = memchr_kwset(text, size, kwset___1);\n', '      }\n', '      if (tp)\n', '      {\n', '        tmp = tp - text;\n', '      }\n', '      else\n', '      {\n', '        tmp = - 1L;\n', '      }\n', '      return (size_t) tmp;\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            {\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'bmexec': ['  size_t tmp___0;\n', '  size_t tmp___1;\n', '  {\n', '    {\n', '      {\n', '        tmp___0 = bmexec_trans(kwset___1, text, size);\n', '        tmp___1 = tmp___0;\n', '      }\n', '    }\n', '    return (size_t) tmp___1;\n', '  }\n', '}\n'], 'kwsexec': ['  size_t tmp;\n', '  {\n', '    if (kwset___1->words == 1L)\n', '    {\n', '      {\n', '        tmp = bmexec(kwset___1, text, size);\n', '        ret = tmp;\n', '      }\n', '      if (ret != 0xffffffffffffffffUL)\n', '      {\n', '      }\n', '      return ret;\n', '    }\n', '  }\n', '}\n'], 'wordchar___0': ['  {\n', '  }\n', '}\n'], 'kwsmusts': ['  const struct dfamust *tmp;\n', '  size_t old_len;\n', '  size_t tmp___0;\n', '  size_t new_len;\n', '  char *must___0;\n', '  char *tmp___1;\n', '  char *mp;\n', '  size_t tmp___2;\n', '  {\n', '    {\n', '      tmp = (const struct dfamust *) dfamusts((const struct dfa *) dfa);\n', '      dm = tmp;\n', '    }\n', '    if (dm)\n', '    {\n', '      {\n', '        kwsinit(& kwset___0);\n', '        {\n', '        }\n', '      }\n', '      while_break:\n', '      {\n', '        {\n', '          {\n', '            tmp___2 = strlen((const char *) dm->must);\n', '            kwsincr(kwset___0, (const char *) dm->must, tmp___2);\n', '          }\n', '          __Cont___0:\n', '        }\n', '      }\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'GEAcompile': ['  char *motif;\n', '  const char *p;\n', '  int bk;\n', '  char *n;\n', '  char *tmp___1;\n', '  const char *tmp___2;\n', '  const char *tmp___3;\n', '  const char *tmp___4;\n', '  const char *tmp___5;\n', '  const char *tmp___6;\n', '  const char *tmp___7;\n', '  size_t tmp___8;\n', '  {\n', '    total = size;\n', '    {\n', '      dfasyntax(syntax_bits___0, match_icase, eolbyte);\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    {\n', '      dfa = dfaalloc();\n', '      dfacomp(pattern, size, dfa, 1);\n', '      kwsmusts();\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'EGexecute': ['  const char *end;\n', '  const char *ptr;\n', '  size_t len;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          {\n', '            {\n', '              {\n', '                {\n', '                  {\n', '                  }\n', '                  {\n', '                    if (len == ((size_t) ((end - ptr) - 1L)))\n', '                    {\n', '                    }\n', '                  }\n', '                  {\n', '                  }\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return (size_t) (- 1);\n', '  }\n', '}\n'], 'to_uchar___0': None, 'dfambcache': ['  {\n', '    i = - 128;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'mbs_to_wchar': ['  wint_t wc;\n', '  size_t nbytes;\n', '  {\n', '    uc = (unsigned char) (* (s + 0));\n', '    wc = d->mbrtowc_cache[uc];\n', '    {\n', '      {\n', '      }\n', '      if (0UL < nbytes)\n', '      {\n', '      }\n', '      {\n', '      }\n', '    }\n', '    * pwc = wc;\n', '    return (size_t) 1;\n', '  }\n', '}\n'], 'tstbit': None, 'setbit': ['    * (c + (b / 32U)) |= 1U << (b % 32U);\n', '  }\n', '}\n'], 'clrbit': ['    * (c + (b / 32U)) &= ~ (1U << (b % 32U));\n', '  }\n', '}\n'], 'copyset': None, 'zeroset': None, 'notset': ['  {\n', '    i = 0;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'equal': None, 'maybe_realloc': None, 'dfa_charclass_index': ['  {\n', '    i = (size_t) 0;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '        i++;\n', '      }\n', '    }\n', '    while_break:\n', '    {\n', '      d->charclasses = (charclass *) maybe_realloc((void *) d->charclasses, d->cindex, & d->calloc, sizeof(* d->charclasses));\n', '      copyset(s, * (d->charclasses + i));\n', '    }\n', '    return i;\n', '  }\n', '}\n'], 'charclass_index': None, 'char_context': None, 'dfasyntax': ['  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'setbit_wc': ['  {\n', '    {\n', '    }\n', '    if (b == (- 1))\n', '    {\n', '    }\n', '    {\n', '      setbit((unsigned int) b, c);\n', '    }\n', '    return (_Bool) 1;\n', '  }\n', '}\n'], 'using_utf8': ['  mbstate_t mbs;\n', '  int tmp___0;\n', '  {\n', '    if (utf8 < 0)\n', '    {\n', '      {\n', '      }\n', '      utf8 = tmp___0;\n', '    }\n', '    return utf8;\n', '  }\n', '}\n'], 'using_simple_locale': ['  {\n', '    if (dfa___0->multibyte)\n', '    {\n', '      return (_Bool) 0;\n', '    }\n', '    else\n', '    {\n', '      if (unibyte_c < 0)\n', '      {\n', '      }\n', '    }\n', '  }\n', '}\n'], 'case_folded_counterparts': ['  wint_t uc;\n', '  wint_t li;\n', '  wint_t tmp___5;\n', '  {\n', '    {\n', '    }\n', '    if (uc != ((wint_t) c))\n', '    {\n', '      {\n', '        {\n', '          {\n', '            if (li != ((wint_t) c))\n', '            {\n', '              {\n', '                tmp___5 = towupper(li);\n', '              }\n', '              if (tmp___5 == uc)\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '        i++;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'find_pred': ['  {\n', '    i = 0U;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'parse_bracket_exp': ['  int c;\n', '  int c1;\n', '  int c2;\n', '  charclass ccl;\n', '  _Bool known_bracket_exp;\n', '  int colon_warning_state;\n', '  wint_t wc;\n', '  wint_t wc2;\n', '  wint_t wc1;\n', '  struct mb_char_classes *work_mbc;\n', '  size_t chars_al;\n', '  size_t ranges_al;\n', '  size_t ch_classes_al;\n', '  size_t equivs_al;\n', '  size_t coll_elems_al;\n', '  size_t tmp;\n', '  char *tmp___1;\n', '  wint_t _wc;\n', '  size_t nbytes;\n', '  size_t tmp___2;\n', '  unsigned char tmp___3;\n', '  char *tmp___5;\n', '  wint_t _wc___0;\n', '  size_t nbytes___0;\n', '  size_t tmp___6;\n', '  unsigned char tmp___7;\n', '  char *tmp___9;\n', '  wint_t _wc___1;\n', '  size_t nbytes___1;\n', '  size_t tmp___10;\n', '  unsigned char tmp___11;\n', '  char str[33];\n', '  size_t len;\n', '  int tmp___25;\n', '  const struct dfa_ctype *pred;\n', '  int tmp___30;\n', '  char *tmp___32;\n', '  wint_t _wc___4;\n', '  size_t nbytes___4;\n', '  size_t nbytes___5;\n', '  size_t nbytes___8;\n', '  size_t tmp___52;\n', '  int tmp___55;\n', '  int tmp___56;\n', '  _Bool tmp___73;\n', '  {\n', '    {\n', '      {\n', '      }\n', '    }\n', '    {\n', '      {\n', '        {\n', '        }\n', '      }\n', '      while_break___0:\n', '      {\n', '      }\n', '    }\n', '    colon_warning_state = c == 58;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '                {\n', '                  tmp___10 = mbs_to_wchar(& _wc___1, lexptr, lexleft, dfa___0);\n', '                  nbytes___1 = tmp___10;\n', '                }\n', '                if (nbytes___1 == 1UL)\n', '                {\n', '                  {\n', '                  }\n', '                }\n', '                lexptr += nbytes___1;\n', '              }\n', '              goto while_break___2;\n', '            }\n', '          }\n', '          while_break___2:\n', '          ;\n', '          if (c1 == 58)\n', '          {\n', '          }\n', '          else\n', '          {\n', '            {\n', '              if (c1 == 61)\n', '              {\n', '                _L___0:\n', '                {\n', '                  while (1)\n', '                  {\n', '                    {\n', '                      while (1)\n', '                      {\n', '                      }\n', '                    }\n', '                    while_break___4:\n', '                    ;\n', '                    if (c == c1)\n', '                    {\n', '                    }\n', '                    else\n', '                    {\n', '                      {\n', '                      }\n', '                    }\n', '                    if (len < 32UL)\n', '                    {\n', '                    }\n', '                  }\n', '                  {\n', '                  }\n', '                }\n', '                while_break___5:\n', '                {\n', '                  if (case_fold)\n', '                  {\n', '                    {\n', '                    }\n', '                    {\n', '                      {\n', '                      }\n', '                      if (tmp___25 == 0)\n', '                      {\n', '                      }\n', '                    }\n', '                    {\n', '                      {\n', '                      }\n', '                    }\n', '                    {\n', '                    }\n', '                  }\n', '                  {\n', '                  }\n', '                }\n', '                while_break___7:\n', '              }\n', '            }\n', '          }\n', '        }\n', '        if (c == 92)\n', '        {\n', '          if (syntax_bits & 1UL)\n', '          {\n', '            if (c2 == 92)\n', '            {\n', '              if (syntax_bits & 1UL)\n', '              {\n', '                {\n', '                  while (1)\n', '                  {\n', '                    {\n', '                      {\n', '                      }\n', '                      if (nbytes___8 == 1UL)\n', '                      {\n', '                      }\n', '                    }\n', '                  }\n', '                }\n', '              }\n', '              {\n', '                if (wc2 != 4294967295U)\n', '                {\n', '                  {\n', '                    work_mbc->ranges = (struct __anonstruct_ranges_39 *) maybe_realloc((void *) work_mbc->ranges, work_mbc->nranges + 2UL, & ranges_al, sizeof(* work_mbc->ranges));\n', '                  }\n', '                  {\n', '                    {\n', '                    }\n', '                    {\n', '                    }\n', '                  }\n', '                }\n', '              }\n', '            }\n', '            while_break___14:\n', '          }\n', '        }\n', '        {\n', '          if (case_fold)\n', '          {\n', '          }\n', '        }\n', '        {\n', '          ;\n', '        }\n', '        {\n', '          goto while_break___1;\n', '        }\n', '      }\n', '    }\n', '    while_break___1:\n', '    {\n', '      return (token) 257;\n', '    }\n', '    if (dfa___0->multibyte)\n', '    {\n', '      {\n', '      }\n', '      if (tmp___73)\n', '      {\n', '        {\n', '        }\n', '      }\n', '      return (token) 273;\n', '    }\n', '    if (invert)\n', '    {\n', '    }\n', '    {\n', '    }\n', '  }\n', '}\n'], 'lex': ['  int c2;\n', '  _Bool backslash;\n', '  int i;\n', '  wint_t _wc;\n', '  size_t nbytes;\n', '  size_t tmp;\n', '  unsigned char tmp___0;\n', '  int tmp___3;\n', '  int tmp___4;\n', '  int tmp___7;\n', '  const char *p;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '        }\n', '        {\n', '          while (1)\n', '          {\n', '            if (! lexleft)\n', '            {\n', '              lasttok = (token) (- 1);\n', '              return lasttok;\n', '            }\n', '            else\n', '            {\n', '              {\n', '                tmp = mbs_to_wchar(& _wc, lexptr, lexleft, dfa___0);\n', '                nbytes = tmp;\n', '              }\n', '              if (nbytes == 1UL)\n', '              {\n', '                {\n', '                }\n', '              }\n', '              lexptr += nbytes;\n', '              lexleft -= nbytes;\n', '            }\n', '            goto while_break___0;\n', '          }\n', '        }\n', '        while_break___0:\n', '        {\n', '        }\n', '        {\n', '          goto case_40;\n', '        }\n', '        {\n', '          if (lexleft == 0UL)\n', '          {\n', '          }\n', '          else\n', '          {\n', '            {\n', '              {\n', '                if (lexleft > 1UL)\n', '                {\n', '                }\n', '              }\n', '              {\n', '                if (syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '          {\n', '          }\n', '        }\n', '        {\n', '          {\n', '          }\n', '        }\n', '        {\n', '          if (laststart)\n', '          {\n', '          }\n', '        }\n', '        {\n', '        }\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '            }\n', '            {\n', '              while (1)\n', '              {\n', '                {\n', '                  if (32768 < (((maxrep * 10) + ((int) (* p))) - 48))\n', '                  {\n', '                  }\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '        case_40:\n', '        if (! backslash)\n', '        {\n', '          goto normal_char;\n', '        }\n', '        {\n', '          {\n', '          }\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '              }\n', '            }\n', '          }\n', '          {\n', '            {\n', '            }\n', '            {\n', '            }\n', '          }\n', '        }\n', '        {\n', '          {\n', '            {\n', '              if (c2 == 95)\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '        {\n', '        }\n', '        normal_char:\n', '        {\n', '          lasttok = (token) 274;\n', '          return lasttok;\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'addtok_mb': ['  {\n', '    if (dfa___0->talloc == dfa___0->tindex)\n', '    {\n', '      {\n', '        dfa___0->tokens = (token *) x2nrealloc((void *) dfa___0->tokens, & dfa___0->talloc, sizeof(* dfa___0->tokens));\n', '      }\n', '      if (dfa___0->multibyte)\n', '      {\n', '        {\n', '          dfa___0->multibyte_prop = (int *) xnrealloc((void *) dfa___0->multibyte_prop, dfa___0->talloc, sizeof(* dfa___0->multibyte_prop));\n', '        }\n', '      }\n', '    }\n', '    tmp = dfa___0->tindex;\n', '    dfa___0->tindex++;\n', '    * (dfa___0->tokens + tmp) = t;\n', '    dfa___0->nleaves++;\n', '    depth++;\n', '    {\n', '      dfa___0->depth = depth;\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'addtok': ['  struct mb_char_classes *work_mbc;\n', '  size_t i;\n', '  {\n', '    if (dfa___0->multibyte)\n', '    {\n', '      if (t == 273L)\n', '      {\n', '        {\n', '          i = (size_t) 0;\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '              }\n', '            }\n', '          }\n', '          {\n', '            {\n', '              {\n', '                if (work_mbc->ncoll_elems != 0UL)\n', '                {\n', '                  {\n', '                    {\n', '                    }\n', '                  }\n', '                  {\n', '                    {\n', '                      addtok(275L + work_mbc->cset);\n', '                    }\n', '                    if (need_or)\n', '                    {\n', '                      {\n', '                      }\n', '                    }\n', '                  }\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '      else\n', '      {\n', '        {\n', '          addtok_mb(t, 3);\n', '        }\n', '      }\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'addtok_wc': ['  mbstate_t s;\n', '  size_t tmp;\n', '  int tmp___0;\n', '  {\n', '    {\n', '      tmp = wcrtomb((char *) ((char *) buf), (wchar_t) wc, (mbstate_t *) (& s));\n', '    }\n', '    {\n', '      addtok_mb((token) buf[0], tmp___0);\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'add_utf8_anychar': ['  unsigned int i;\n', '  charclass c;\n', '  {\n', '    {\n', '      i = 0U;\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            {\n', '              {\n', '                clrbit((unsigned int) eolbyte___0, c);\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'atom': ['  int tmp___1;\n', '  {\n', '    if (tok == 274L)\n', '    {\n', '      {\n', '        {\n', '          addtok_wc(wctok);\n', '        }\n', '        if (case_fold)\n', '        {\n', '          {\n', '            {\n', '              while_continue:\n', '              {\n', '              }\n', '            }\n', '          }\n', '          while_break:\n', '          ;\n', '        }\n', '      }\n', '      {\n', '        tok = lex();\n', '      }\n', '    }\n', '    else\n', '    {\n', '      if (tok == 272L)\n', '      {\n', '        {\n', '          tmp___1 = using_utf8();\n', '        }\n', '        if (tmp___1)\n', '        {\n', '          {\n', '          }\n', '        }\n', '        if (tok >= 0L)\n', '        {\n', '          {\n', '            if (tok == 257L)\n', '            {\n', '              {\n', '                {\n', '                  {\n', '                    {\n', '                      if (tok == 273L)\n', '                      {\n', '                        {\n', '                        }\n', '                      }\n', '                      else\n', '                      {\n', '                        {\n', '                          {\n', '                            if (tok == 263L)\n', '                            {\n', '                              if (tok == 270L)\n', '                              {\n', '                                {\n', '                                }\n', '                              }\n', '                            }\n', '                          }\n', '                        }\n', '                      }\n', '                    }\n', '                  }\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'closure': ['  {\n', '    {\n', '      atom();\n', '      {\n', '        {\n', '          if (! (tok == 265L))\n', '          {\n', '            if (! (tok == 266L))\n', '            {\n', '            }\n', '          }\n', '        }\n', '        if (tok == 267L)\n', '        {\n', '          {\n', '            if (maxrep)\n', '            {\n', '              {\n', '              }\n', '              {\n', '                {\n', '                  {\n', '                  }\n', '                  {\n', '                  }\n', '                }\n', '              }\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '        else\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'branch': ['    {\n', '      closure();\n', '      {\n', '        if (tok != 271L)\n', '        {\n', '          if (tok != 269L)\n', '          {\n', '          }\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'regexp': ['    {\n', '      branch();\n', '      {\n', '        while_continue:\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'dfaparse': ['  {\n', '    dfa___0 = d;\n', '    lexptr = s;\n', '    lexleft = len;\n', '    {\n', '      {\n', '      }\n', '    }\n', '    {\n', '      tok = lex();\n', '      regexp();\n', '    }\n', '    if (tok != (- 1L))\n', '    {\n', '      {\n', '      }\n', '    }\n', '    {\n', '      addtok((token) (0xffffffffffffffffUL - d->nregexps));\n', '    }\n', '  }\n', '}\n'], 'copy': ['    if (dst->alloc < ((size_t) src->nelem))\n', '    {\n', '      {\n', '      }\n', '    }\n', '    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'alloc_position_set': None, 'insert': ['  size_t lo;\n', '  size_t hi;\n', '  size_t i;\n', '  size_t mid;\n', '  {\n', '  }\n', '}\n'], 'merge': ['  {\n', '    {\n', '      while (1)\n', '      {\n', '        if (i < ((size_t) s1->nelem))\n', '        {\n', '          {\n', '          }\n', '        }\n', '      }\n', '      {\n', '      }\n', '      {\n', '      }\n', '    }\n', '  }\n', '}\n'], 'delete': ['  {\n', '    i = (size_t) 0;\n', '    {\n', '      while (1)\n', '      {\n', '      }\n', '      ;\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'state_index': ['  int constraint;\n', '  state_num i;\n', '  state_num j;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          goto while_break___0;\n', '        }\n', '        if (hash != (d->states + i)->hash)\n', '        {\n', '          {\n', '          }\n', '          {\n', '          }\n', '        }\n', '        __Cont:\n', '      }\n', '    }\n', '    while_break___0:\n', '    {\n', '      d->states = (dfa_state *) maybe_realloc((void *) d->states, (size_t) d->sindex, & d->salloc, sizeof(* d->states));\n', '      {\n', '        while_continue___2:\n', '      }\n', '    }\n', '    while_break___2:\n', '  }\n', '}\n'], 'epsclosure': ['  _Bool initialized;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '        if ((* (d->tokens + (s->elems + i)->index)) >= 256L)\n', '        {\n', '          if ((* (d->tokens + (s->elems + i)->index)) != 257L)\n', '          {\n', '            if ((* (d->tokens + (s->elems + i)->index)) != 272L)\n', '            {\n', '              if ((* (d->tokens + (s->elems + i)->index)) != 273L)\n', '              {\n', '                if ((* (d->tokens + (s->elems + i)->index)) < 275L)\n', '                {\n', '                  if (! initialized)\n', '                  {\n', '                    {\n', '                    }\n', '                  }\n', '                  {\n', '                  }\n', '                  {\n', '                    while (1)\n', '                    {\n', '                      {\n', '                      }\n', '                    }\n', '                  }\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'charclass_context': ['  {\n', '    {\n', '      {\n', '      }\n', '    }\n', '  }\n', '}\n'], 'state_separate_contexts': ['  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'dfaanalyze': ['  {\n', '    {\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '        {\n', '        }\n', '        {\n', '          {\n', '            while (1)\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break___3;\n', '        }\n', '      }\n', '    }\n', '    while_break___3:\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break___4;\n', '        }\n', '        {\n', '        }\n', '      }\n', '    }\n', '    while_break___4:\n', '  }\n', '}\n'], 'dfastate': ['  charclass labels[256];\n', '  size_t ngrps;\n', '  position pos;\n', '  charclass matches;\n', '  position_set follows;\n', '  position_set tmp;\n', '  int possible_contexts;\n', '  int separate_contexts;\n', '  state_num state;\n', '  state_num state_newline;\n', '  state_num state_letter;\n', '  _Bool next_isnt_1st_byte;\n', '  size_t i;\n', '  size_t j;\n', '  size_t k;\n', '  _Bool tmp___0;\n', '  const unsigned short **tmp___6;\n', '  int c;\n', '  const unsigned short **tmp___7;\n', '  {\n', '    {\n', '      {\n', '        if ((* (d->tokens + pos.index)) >= 0L)\n', '        {\n', '          if ((* (d->tokens + pos.index)) < 256L)\n', '          {\n', '            {\n', '              if ((* (d->tokens + pos.index)) == 272L)\n', '              {\n', '                {\n', '                }\n', '                {\n', '                }\n', '              }\n', '            }\n', '            goto __Cont;\n', '          }\n', '          {\n', '            j = (size_t) 0;\n', '            {\n', '              while (1)\n', '              {\n', '              }\n', '            }\n', '            while_break___0:\n', '            ;\n', '            ;\n', '            ;\n', '            {\n', '              while_continue___3:\n', '              ;\n', '              if (j < 8UL)\n', '              {\n', '                if (! (! matches[j]))\n', '                {\n', '                  goto while_break___3;\n', '                }\n', '              }\n', '            }\n', '          }\n', '          while_break___3:\n', '          {\n', '            goto __Cont;\n', '          }\n', '          {\n', '            {\n', '              if ((* (d->tokens + pos.index)) < 256L)\n', '              {\n', '                {\n', '                }\n', '              }\n', '            }\n', '            {\n', '              while (1)\n', '              {\n', '              }\n', '              {\n', '              }\n', '            }\n', '            __Cont___1:\n', '          }\n', '        }\n', '        while_break___4:\n', '        {\n', '          {\n', '          }\n', '        }\n', '        __Cont:\n', '      }\n', '    }\n', '    while_break:\n', '    {\n', '    }\n', '    if (d->searchflag)\n', '    {\n', '      {\n', '      }\n', '      if (separate_contexts & 4)\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '          i++;\n', '        }\n', '      }\n', '      while_break___7:\n', '    }\n', '    else\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          if (! d->multibyte)\n', '          {\n', '            {\n', '            }\n', '          }\n', '          else\n', '          {\n', '            if (! next_isnt_1st_byte)\n', '            {\n', '            }\n', '          }\n', '        }\n', '        {\n', '        }\n', '        if ((separate_contexts & possible_contexts) != possible_contexts)\n', '        {\n', '          {\n', '            {\n', '              while (1)\n', '              {\n', '                {\n', '                  c = (int) ((j * 32UL) + k);\n', '                  if (c == ((int) eolbyte___0))\n', '                  {\n', '                    * (trans___0 + c) = state_newline;\n', '                  }\n', '                  else\n', '                  {\n', '                    {\n', '                      tmp___7 = __ctype_b_loc();\n', '                    }\n', '                    if (((const int) (* ((* tmp___7) + c))) & 8)\n', '                    {\n', '                      if (c == 95)\n', '                      {\n', '                      }\n', '                    }\n', '                  }\n', '                }\n', '                k++;\n', '              }\n', '            }\n', '            while_break___14:\n', '          }\n', '        }\n', '        while_break___13:\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    while_break___15:\n', '    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'realloc_trans_if_necessary': ['  {\n', '    {\n', '      ;\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'build_state': ['  state_num i;\n', '  state_num maxstate;\n', '  {\n', '    if (d->trcount >= 1024)\n', '    {\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '          }\n', '          {\n', '          }\n', '        }\n', '      }\n', '      while_break:\n', '    }\n', '    {\n', '    }\n', '    while_break___0:\n', '  }\n', '}\n'], 'build_state_zero': ['  {\n', '    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'dfaexec': ['  {\n', '    {\n', '      {\n', '      }\n', '      {\n', '        if (d->multibyte)\n', '        {\n', '          {\n', '            while (1)\n', '            {\n', '            }\n', '          }\n', '          {\n', '          }\n', '        }\n', '        ;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'dfasuperset': None, 'dfaisfast': None, 'free_mbdata': ['  {\n', '    {\n', '      {\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '        while_break___0:\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'dfainit': ['  {\n', '    {\n', '      d->multibyte = (_Bool) (tmp > 1UL);\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'dfaoptimize': ['  {\n', '    {\n', '    }\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'dfassbuild': ['  size_t j;\n', '  charclass ccl;\n', '  _Bool have_achar;\n', '  _Bool have_nchar;\n', '  struct dfa *sup;\n', '  struct dfa *tmp;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          {\n', '            if ((* (d->tokens + (i + 1UL))) == 266L)\n', '            {\n', '              i++;\n', '            }\n', '          }\n', '        }\n', '        {\n', '          _L:\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '    if (have_nchar)\n', '    {\n', '      if (have_achar)\n', '      {\n', '        {\n', '          d->superset = sup;\n', '        }\n', '      }\n', '    }\n', '    else\n', '    {\n', '      {\n', '      }\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'dfacomp': ['    {\n', '      dfainit(d);\n', '    }\n', '    if (d->superset)\n', '    {\n', '      {\n', '      }\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'dfafree': ['  {\n', '    {\n', '    }\n', '  }\n', '}\n'], 'icatalloc': ['  {\n', '    {\n', '    }\n', '  }\n', '}\n'], 'istrstr': ['  {\n', '    {\n', '      {\n', '        {\n', '        }\n', '        cp++;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'freelist': ['  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'enlist': ['  size_t j;\n', '  void *tmp;\n', '  char *tmp___0;\n', '  char *tmp___1;\n', '  {\n', '    {\n', '      {\n', '        {\n', '        }\n', '        i++;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'comsubs': ['  {\n', '    {\n', '      {\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'addlists': ['  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'inboth': ['  {\n', '    {\n', '      {\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'allocmust': ['  {\n', '    {\n', '    }\n', '    return new_mp;\n', '  }\n', '}\n'], 'resetmust': ['  {\n', '    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'freemust': ['    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'dfamust': ['  const char *result;\n', '  size_t ri;\n', '  size_t i;\n', '  token t;\n', '  char **new;\n', '  must *rmp;\n', '  must *lmp;\n', '  size_t j;\n', '  size_t ln;\n', '  size_t rn;\n', '  size_t n;\n', '  int tmp;\n', '  size_t tmp___0;\n', '  size_t tmp___1;\n', '  int tmp___2;\n', '  must *rmp___0;\n', '  must *lmp___0;\n', '  _Bool tmp___7;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          while (1)\n', '          {\n', '            if (((int) (* (lmp->left + i))) != 0)\n', '            {\n', '            }\n', '            i++;\n', '          }\n', '          {\n', '          }\n', '          {\n', '          }\n', '        }\n', '        if (tmp___2 == 0)\n', '        {\n', '          if (lmp___0->begline)\n', '          {\n', '            _L:\n', '            if (((int) (* (rmp___0->is + 0))) != 0)\n', '            {\n', '              {\n', '              }\n', '            }\n', '            else\n', '            {\n', '              if (rmp___0->endline)\n', '              {\n', '                {\n', '                }\n', '              }\n', '              else\n', '              {\n', '              }\n', '            }\n', '          }\n', '          else\n', '          {\n', '          }\n', '        }\n', '        {\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '              }\n', '            }\n', '            {\n', '              {\n', '              }\n', '              if (tmp___7)\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'dfaalloc': None, 'dfamusts': None, 'kwsinit': ['  size_t tmp;\n', '  {\n', '    if (match_icase)\n', '    {\n', '      {\n', '      }\n', '      if (tmp == 1UL)\n', '      {\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '            }\n', '            {\n', '            }\n', '          }\n', '        }\n', '        {\n', '        }\n', '      }\n', '    }\n', '    else\n', '    {\n', '      {\n', '        * kwset___1 = kwsalloc((const char *) ((void *) 0));\n', '      }\n', '    }\n', '  }\n', '}\n'], 'build_mbclen_cache': ['  {\n', '    i = - 128;\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          goto while_break;\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'mb_goback': ['  size_t mbclen;\n', '  {\n', '    {\n', '      {\n', '        {\n', '        }\n', '        {\n', '          if (! (mbclen < 0xfffffffffffffffeUL))\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'mb_prev_wc': ['  {\n', '  }\n', '}\n'], 'mb_next_wc': ['  unsigned int tmp___0;\n', '  {\n', '    {\n', '      {\n', '      }\n', '    }\n', '    return tmp___0;\n', '  }\n', '}\n'], 'pr_sgr_start_if': None, 'pr_sgr_end_if': None, 'usable_st_size': None, 'clean_up_stdout': None, 'file_is_binary': ['  off_t hole_start;\n', '  {\n', '    if (! eolbyte)\n', '    {\n', '      {\n', '      }\n', '    }\n', '    {\n', '    }\n', '    {\n', '      {\n', '        {\n', '        }\n', '      }\n', '      if (0L <= hole_start)\n', '      {\n', '        {\n', '        }\n', '        {\n', '        }\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '}\n'], 'skipped_file': ['  int tmp___2;\n', '  int tmp___3;\n', '  {\n', '    if (is_dir)\n', '    {\n', '      {\n', '        {\n', '          {\n', '          }\n', '        }\n', '        {\n', '        }\n', '      }\n', '      tmp___3 = tmp___2;\n', '    }\n', '    return tmp___3;\n', '  }\n', '}\n'], 'reset': ['  {\n', '    if (! pagesize)\n', '    {\n', '      {\n', '        pagesize = (size_t) getpagesize();\n', '      }\n', '      {\n', '        tmp = (size_t) 32768;\n', '      }\n', '      {\n', '        bufalloc = (tmp + pagesize) + 1UL;\n', '        buffer = (char *) xmalloc(bufalloc);\n', '      }\n', '    }\n', '    {\n', '      buflim = (buffer + 1) + (pagesize - (((size_t) (buffer + 1)) % pagesize));\n', '    }\n', '    bufdesc = fd;\n', '    {\n', '      if (fd != 0)\n', '      {\n', '        {\n', '        }\n', '        if (bufoffset < 0L)\n', '        {\n', '        }\n', '      }\n', '    }\n', '    return 1;\n', '  }\n', '}\n'], 'fillbuf': ['  char *readbuf;\n', '  size_t newsize;\n', '  {\n', '    if (pagesize <= ((size_t) ((buffer + bufalloc) - buflim)))\n', '    {\n', '      readbuf = buflim;\n', '      bufbeg = buflim - save;\n', '    }\n', '    else\n', '    {\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            if ((((newsize * 2UL) + pagesize) + 1UL) < (newsize * 2UL))\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'undossify_input': ['  {\n', '    {\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            {\n', '              if (! dos_report_unix_offset)\n', '              {\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return (int) buflen;\n', '  }\n', '}\n'], 'add_count': ['  {\n', '  }\n', '}\n'], 'nlscan': ['  {\n', '  }\n', '}\n'], 'print_sep': ['    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'print_offset': ['  char *p;\n', '  {\n', '    p = buf + (sizeof(buf));\n', '    {\n', '      while (1)\n', '      {\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'print_line_head': ['  {\n', '    {\n', '      {\n', '      }\n', '      if (filename_mask)\n', '      {\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '      {\n', '      }\n', '      {\n', '      }\n', '      {\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'print_line_middle': ['  size_t match_offset;\n', '  const char *cur;\n', '  const char *mid;\n', '  const char *b;\n', '  int tmp;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          {\n', '          }\n', '        }\n', '        {\n', '        }\n', '        {\n', '          {\n', '            {\n', '              fputs_unlocked((const char *) "\\n", (FILE *) stdout);\n', '            }\n', '          }\n', '        }\n', '        cur = b + match_size;\n', '      }\n', '      {\n', '      }\n', '    }\n', '    return cur;\n', '  }\n', '}\n'], 'prline': ['  const char *match_color;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          if (* match_color)\n', '          {\n', '            {\n', '              {\n', '                if (* match_color)\n', '                {\n', '                }\n', '              }\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'prpending': ['  size_t tmp___0;\n', '  {\n', '    if (! lastout)\n', '    {\n', '    }\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '        }\n', '        {\n', '          {\n', '          }\n', '          if ((tmp___0 == 0xffffffffffffffffUL) == (! out_invert))\n', '          {\n', '          }\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'prtext': ['  const char *p;\n', '  const char *nl___0;\n', '  {\n', '    {\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            {\n', '              while (1)\n', '              {\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '        {\n', '          {\n', '          }\n', '        }\n', '      }\n', '      {\n', '        while (1)\n', '        {\n', '          {\n', '            {\n', "              prline(p, nl___0, ':');\n", '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'do_execute': ['  size_t tmp;\n', '  {\n', '    {\n', '      if (((unsigned long) execute) == ((unsigned long) (& Pexecute)))\n', '      {\n', '        {\n', '          if (! match_icase)\n', '          {\n', '          }\n', '        }\n', '      }\n', '      else\n', '      {\n', '        {\n', '          tmp = (* execute)(buf, size, match_size, start_ptr);\n', '        }\n', '        return tmp;\n', '      }\n', '    }\n', '    {\n', '      while (1)\n', '      {\n', '        ;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'grepbuf': ['  const char *p;\n', '  const char *endp;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          {\n', '            {\n', '            }\n', '            {\n', '              if (done_on_match)\n', '              {\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '        p = endp;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'grep': ['  intmax_t i;\n', '  int not_text;\n', '  size_t residue;\n', '  size_t save;\n', '  char oldc;\n', '  char *beg;\n', '  char *lim;\n', '  char eol;\n', '  int tmp;\n', '  int tmp___1;\n', '  {\n', '    {\n', '    }\n', '    if (! tmp)\n', '    {\n', '    }\n', '    {\n', '    }\n', '    if (! tmp___1)\n', '    {\n', '    }\n', '    else\n', '    {\n', '      {\n', '        _L:\n', '        ;\n', '      }\n', '      {\n', '        {\n', '          goto while_break;\n', '          {\n', '            {\n', '              {\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '        {\n', '          {\n', '            nlscan((const char *) beg);\n', '          }\n', '        }\n', '        {\n', '          {\n', '          }\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '    {\n', '      {\n', '      }\n', '    }\n', '  }\n', '}\n'], 'grepfile': ['  int *tmp___2;\n', '  {\n', '    {\n', '      {\n', '        {\n', '        }\n', '        if ((* tmp___2) != 40)\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'grepdesc': ['  int status;\n', '  struct stat st;\n', '  int tmp___0;\n', '  int tmp___1;\n', '  {\n', '    {\n', '    }\n', '    {\n', '      if (command_line)\n', '      {\n', '        {\n', '          tmp___1 = skipped_file(filename, 1, (st.st_mode & 61440U) == 16384U);\n', '        }\n', '        if (tmp___1)\n', '        {\n', '        }\n', '      }\n', '      {\n', '        if ((st.st_mode & 61440U) == 16384U)\n', '        {\n', '          {\n', '          }\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '              }\n', '              {\n', '              }\n', '            }\n', '          }\n', '          {\n', '          }\n', '          {\n', '            if (! command_line)\n', '            {\n', '              {\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '      {\n', '        if (1L < max_count)\n', '        {\n', '          if ((out_stat.st_mode & 61440U) == 32768U)\n', '          {\n', '            if (out_stat.st_ino)\n', '            {\n', '              if (st.st_ino == out_stat.st_ino)\n', '              {\n', '                if (st.st_dev == out_stat.st_dev)\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    {\n', '      {\n', '        set_binary_mode(desc, 0);\n', '      }\n', '    }\n', '    {\n', '      if (count_matches)\n', '      {\n', '        if (out_file)\n', '        {\n', '        }\n', '        {\n', '        }\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    return status;\n', '  }\n', '}\n'], 'grep_command_line_arg': ['  int tmp___2;\n', '  {\n', '    {\n', '      tmp___2 = strcmp(arg, "-");\n', '    }\n', '  }\n', '}\n'], 'Gcompile': None, 'Ecompile': None, 'setmatcher': ['  int tmp___0;\n', '  {\n', '    if (matcher)\n', '    {\n', '      {\n', '      }\n', '      if (! (tmp___0 == 0))\n', '      {\n', '      }\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '    {\n', '    }\n', '  }\n', '}\n'], 'prepend_default_options': ['  size_t prepended;\n', '  int argc;\n', '  {\n', '    if (options)\n', '    {\n', '      if (* options)\n', '      {\n', '        {\n', '        }\n', '        if (((size_t) (2147483647 - argc)) < prepended)\n', '        {\n', '        }\n', '        {\n', '        }\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '}\n'], 'get_nondigit_option': ['  int opt;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          opt = getopt_long(argc, (char *const *) ((char **) argv), short_options, long_options, (int *) ((void *) 0));\n', '        }\n', '        {\n', '          goto while_break;\n', '        }\n', '        {\n', '        }\n', '      }\n', '    }\n', '    while_break:\n', '  }\n', '}\n'], 'main': ['  size_t keycc;\n', '  int opt;\n', '  int status;\n', '  int tmp___15;\n', '  size_t tmp___38;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          {\n', '          }\n', '        }\n', '        goto switch_break;\n', '        {\n', '        }\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '        {\n', '        }\n', '        {\n', '          while (1)\n', '          {\n', '            {\n', '            }\n', '          }\n', '        }\n', '        {\n', '          {\n', '          }\n', '          {\n', '            {\n', '            }\n', '            if (tmp___15 == 0)\n', '            {\n', '            }\n', '          }\n', '        }\n', '        ;\n', '        {\n', '        }\n', '        switch_break:\n', '        ;\n', '      }\n', '      ;\n', '      {\n', '      }\n', '    }\n', '    {\n', '    }\n', '  }\n', '}\n']}[{'name': 'xnmalloc', 'start_line': 751, 'end_line': 775}, {'name': 'xnrealloc', 'start_line': 780, 'end_line': 804}, {'name': 'x2nrealloc', 'start_line': 807, 'end_line': 838}, {'name': 'xmalloc', 'start_line': 860, 'end_line': 878}, {'name': 'xrealloc', 'start_line': 882, 'end_line': 905}, {'name': 'xzalloc', 'start_line': 913, 'end_line': 923}, {'name': 'xcalloc', 'start_line': 927, 'end_line': 941}, {'name': 'xmemdup', 'start_line': 945, 'end_line': 955}, {'name': 'xstrdup', 'start_line': 959, 'end_line': 969}, {'name': 'safe_read', 'start_line': 1038, 'end_line': 1088}, {'name': 'set_program_name', 'start_line': 1186, 'end_line': 1227}, {'name': 'openat_safer', 'start_line': 1237, 'end_line': 1256}, {'name': 'fd_safer', 'start_line': 1626, 'end_line': 1645}, {'name': 'init_colorize', 'start_line': 1775, 'end_line': 1779}, {'name': 'close_stdout', 'start_line': 1795, 'end_line': 1842}, {'name': 'close_stream', 'start_line': 1846, 'end_line': 1897}, {'name': 'set_binary_mode', 'start_line': 1922, 'end_line': 1926}, {'name': 'to_uchar', 'start_line': 2031, 'end_line': 2035}, {'name': 'tr', 'start_line': 2040, 'end_line': 2056}, {'name': 'kwsalloc', 'start_line': 2059, 'end_line': 2130}, {'name': 'kwsincr', 'start_line': 2133, 'end_line': 2509}, {'name': 'enqueue', 'start_line': 2512, 'end_line': 2529}, {'name': 'treefails', 'start_line': 2532, 'end_line': 2611}, {'name': 'treedelta', 'start_line': 2614, 'end_line': 2632}, {'name': 'hasevery', 'start_line': 2635, 'end_line': 2697}, {'name': 'treenext', 'start_line': 2700, 'end_line': 2714}, {'name': 'kwsprep', 'start_line': 2717, 'end_line': 3109}, {'name': 'bm_delta2_search', 'start_line': 3112, 'end_line': 3247}, {'name': 'memchr_kwset', 'start_line': 3250, 'end_line': 3304}, {'name': 'bmexec_trans', 'start_line': 3307, 'end_line': 3516}, {'name': 'bmexec', 'start_line': 3519, 'end_line': 3539}, {'name': 'kwsexec', 'start_line': 3546, 'end_line': 3568}, {'name': 'wordchar___0', 'start_line': 3586, 'end_line': 3610}, {'name': 'kwsmusts', 'start_line': 3630, 'end_line': 3740}, {'name': 'GEAcompile', 'start_line': 3751, 'end_line': 3912}, {'name': 'EGexecute', 'start_line': 3915, 'end_line': 4419}, {'name': 'to_uchar___0', 'start_line': 4449, 'end_line': 4453}, {'name': 'dfambcache', 'start_line': 4458, 'end_line': 4507}, {'name': 'mbs_to_wchar', 'start_line': 4510, 'end_line': 4534}, {'name': 'tstbit', 'start_line': 4537, 'end_line': 4541}, {'name': 'setbit', 'start_line': 4544, 'end_line': 4549}, {'name': 'clrbit', 'start_line': 4552, 'end_line': 4557}, {'name': 'copyset', 'start_line': 4560, 'end_line': 4567}, {'name': 'zeroset', 'start_line': 4570, 'end_line': 4577}, {'name': 'notset', 'start_line': 4580, 'end_line': 4608}, {'name': 'equal', 'start_line': 4611, 'end_line': 4619}, {'name': 'maybe_realloc', 'start_line': 4622, 'end_line': 4636}, {'name': 'dfa_charclass_index', 'start_line': 4639, 'end_line': 4679}, {'name': 'charclass_index', 'start_line': 4683, 'end_line': 4691}, {'name': 'char_context', 'start_line': 4701, 'end_line': 4727}, {'name': 'dfasyntax', 'start_line': 4734, 'end_line': 4793}, {'name': 'setbit_wc', 'start_line': 4796, 'end_line': 4813}, {'name': 'using_utf8', 'start_line': 4821, 'end_line': 4849}, {'name': 'using_simple_locale', 'start_line': 4854, 'end_line': 4874}, {'name': 'case_folded_counterparts', 'start_line': 4887, 'end_line': 4980}, {'name': 'find_pred', 'start_line': 4984, 'end_line': 5019}, {'name': 'parse_bracket_exp', 'start_line': 5023, 'end_line': 6119}, {'name': 'lex', 'start_line': 6122, 'end_line': 6983}, {'name': 'addtok_mb', 'start_line': 6988, 'end_line': 7075}, {'name': 'addtok', 'start_line': 7079, 'end_line': 7194}, {'name': 'addtok_wc', 'start_line': 7197, 'end_line': 7264}, {'name': 'add_utf8_anychar', 'start_line': 7269, 'end_line': 7380}, {'name': 'atom', 'start_line': 7383, 'end_line': 7606}, {'name': 'closure', 'start_line': 7617, 'end_line': 7750}, {'name': 'branch', 'start_line': 7753, 'end_line': 7800}, {'name': 'regexp', 'start_line': 7803, 'end_line': 7835}, {'name': 'dfaparse', 'start_line': 7838, 'end_line': 7888}, {'name': 'copy', 'start_line': 7891, 'end_line': 7908}, {'name': 'alloc_position_set', 'start_line': 7911, 'end_line': 7920}, {'name': 'insert', 'start_line': 7923, 'end_line': 8000}, {'name': 'merge', 'start_line': 8003, 'end_line': 8139}, {'name': 'delete', 'start_line': 8142, 'end_line': 8200}, {'name': 'state_index', 'start_line': 8203, 'end_line': 8375}, {'name': 'epsclosure', 'start_line': 8378, 'end_line': 8532}, {'name': 'charclass_context', 'start_line': 8535, 'end_line': 8583}, {'name': 'state_separate_contexts', 'start_line': 8586, 'end_line': 8624}, {'name': 'dfaanalyze', 'start_line': 8627, 'end_line': 8985}, {'name': 'dfastate', 'start_line': 8988, 'end_line': 9723}, {'name': 'realloc_trans_if_necessary', 'start_line': 9726, 'end_line': 9784}, {'name': 'build_state', 'start_line': 9787, 'end_line': 9883}, {'name': 'build_state_zero', 'start_line': 9886, 'end_line': 9902}, {'name': 'dfaexec', 'start_line': 9929, 'end_line': 10174}, {'name': 'dfasuperset', 'start_line': 10178, 'end_line': 10182}, {'name': 'dfaisfast', 'start_line': 10186, 'end_line': 10190}, {'name': 'free_mbdata', 'start_line': 10193, 'end_line': 10286}, {'name': 'dfainit', 'start_line': 10289, 'end_line': 10300}, {'name': 'dfaoptimize', 'start_line': 10303, 'end_line': 10389}, {'name': 'dfassbuild', 'start_line': 10392, 'end_line': 10585}, {'name': 'dfacomp', 'start_line': 10588, 'end_line': 10609}, {'name': 'dfafree', 'start_line': 10612, 'end_line': 10737}, {'name': 'icatalloc', 'start_line': 10740, 'end_line': 10762}, {'name': 'istrstr', 'start_line': 10765, 'end_line': 10805}, {'name': 'freelist', 'start_line': 10808, 'end_line': 10838}, {'name': 'enlist', 'start_line': 10841, 'end_line': 10934}, {'name': 'comsubs', 'start_line': 10937, 'end_line': 11043}, {'name': 'addlists', 'start_line': 11046, 'end_line': 11076}, {'name': 'inboth', 'start_line': 11079, 'end_line': 11143}, {'name': 'allocmust', 'start_line': 11146, 'end_line': 11163}, {'name': 'resetmust', 'start_line': 11166, 'end_line': 11183}, {'name': 'freemust', 'start_line': 11186, 'end_line': 11198}, {'name': 'dfamust', 'start_line': 11201, 'end_line': 11810}, {'name': 'dfaalloc', 'start_line': 11813, 'end_line': 11821}, {'name': 'dfamusts', 'start_line': 11824, 'end_line': 11828}, {'name': 'kwsinit', 'start_line': 11835, 'end_line': 11886}, {'name': 'build_mbclen_cache', 'start_line': 11896, 'end_line': 11934}, {'name': 'mb_goback', 'start_line': 11937, 'end_line': 12000}, {'name': 'mb_prev_wc', 'start_line': 12003, 'end_line': 12021}, {'name': 'mb_next_wc', 'start_line': 12024, 'end_line': 12047}, {'name': 'pr_sgr_start_if', 'start_line': 12091, 'end_line': 12101}, {'name': 'pr_sgr_end_if', 'start_line': 12104, 'end_line': 12114}, {'name': 'usable_st_size', 'start_line': 12153, 'end_line': 12171}, {'name': 'clean_up_stdout', 'start_line': 12180, 'end_line': 12191}, {'name': 'file_is_binary', 'start_line': 12194, 'end_line': 12255}, {'name': 'skipped_file', 'start_line': 12262, 'end_line': 12314}, {'name': 'reset', 'start_line': 12325, 'end_line': 12393}, {'name': 'fillbuf', 'start_line': 12396, 'end_line': 12488}, {'name': 'undossify_input', 'start_line': 12531, 'end_line': 12681}, {'name': 'add_count', 'start_line': 12688, 'end_line': 12702}, {'name': 'nlscan', 'start_line': 12705, 'end_line': 12745}, {'name': 'print_sep', 'start_line': 12752, 'end_line': 12761}, {'name': 'print_offset', 'start_line': 12764, 'end_line': 12824}, {'name': 'print_line_head', 'start_line': 12827, 'end_line': 12893}, {'name': 'print_line_middle', 'start_line': 12896, 'end_line': 13002}, {'name': 'prline', 'start_line': 13009, 'end_line': 13134}, {'name': 'prpending', 'start_line': 13137, 'end_line': 13191}, {'name': 'prtext', 'start_line': 13195, 'end_line': 13388}, {'name': 'do_execute', 'start_line': 13391, 'end_line': 13473}, {'name': 'grepbuf', 'start_line': 13476, 'end_line': 13594}, {'name': 'grep', 'start_line': 13597, 'end_line': 13872}, {'name': 'grepfile', 'start_line': 13879, 'end_line': 13919}, {'name': 'grepdesc', 'start_line': 13922, 'end_line': 14178}, {'name': 'grep_command_line_arg', 'start_line': 14181, 'end_line': 14210}, {'name': 'Gcompile', 'start_line': 14218, 'end_line': 14225}, {'name': 'Ecompile', 'start_line': 14228, 'end_line': 14235}, {'name': 'setmatcher', 'start_line': 14251, 'end_line': 14305}, {'name': 'prepend_default_options', 'start_line': 14312, 'end_line': 14369}, {'name': 'get_nondigit_option', 'start_line': 14374, 'end_line': 14441}, {'name': 'main', 'start_line': 14456, 'end_line': 15372}]