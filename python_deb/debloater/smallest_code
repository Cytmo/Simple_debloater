{'close_stdout': ['  int tmp___3;\n', '  {\n', '    {\n', '      tmp___3 = close_stream(stdout);\n', '    }\n', '    if (tmp___3 != 0)\n', '    {\n', '      {\n', '        {\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'close_stream': ['  int *tmp___3;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          if ((* tmp___3) != 9)\n', '          {\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '}\n'], 'to_uchar': None, 'xnmalloc': None, 'xstrtoul': ['  char **p;\n', '  unsigned long tmp;\n', '  strtol_error err;\n', '  const char *q;\n', '  unsigned char ch;\n', '  const unsigned short **tmp___0;\n', '  int *tmp___1;\n', '  int *tmp___3;\n', '  int *tmp___4;\n', '  char *tmp___5;\n', '  char *tmp___6;\n', '  {\n', '    {\n', '    }\n', '    if (((unsigned long) (* p)) == ((unsigned long) s))\n', '    {\n', '      {\n', '      }\n', '    }\n', '    if (((int) (* (* p))) != 0)\n', '    {\n', '      {\n', '        {\n', '          ;\n', '        }\n', '      }\n', '      {\n', '        ;\n', '      }\n', '    }\n', '  }\n', '}\n'], 'xmemcoll': ['  int tmp;\n', '  int collation_errno;\n', '  int *tmp___0;\n', '  {\n', '    {\n', '      tmp = memcoll(s1, s1len, s2, s2len);\n', '      tmp___0 = __errno_location();\n', '      collation_errno = * tmp___0;\n', '    }\n', '    if (collation_errno)\n', '    {\n', '      exit(-1);\n', '    }\n', '    return diff;\n', '  }\n', '}\n'], 'x2nrealloc': ['  void *tmp;\n', '  {\n', '    n = * pn;\n', '    if (! p)\n', '    {\n', '      if (! n)\n', '      {\n', '        n = 128UL / s;\n', '      }\n', '    }\n', '    else\n', '    {\n', '      if ((0xaaaaaaaaaaaaaaaaUL / s) <= n)\n', '      {\n', '        exit(-1);\n', '      }\n', '      n += (n + 1UL) / 2UL;\n', '    }\n', '    {\n', '      * pn = n;\n', '      tmp = xrealloc(p, n * s);\n', '    }\n', '    return tmp;\n', '  }\n', '}\n'], 'xrealloc': None, 'x2realloc': None, 'set_program_name': ['  {\n', '    {\n', '      {\n', '      }\n', '    }\n', '  }\n', '}\n'], 'strcoll_loop': ['  int *tmp___1;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '          tmp___1 = __errno_location();\n', '          * tmp___1 = 0;\n', '        }\n', '        {\n', '          goto while_break;\n', '        }\n', '        {\n', '        }\n', '      }\n', '      while_break:\n', '      ;\n', '    }\n', '    return diff;\n', '  }\n', '}\n'], 'memcoll': ['  int tmp___0;\n', '  {\n', '    if (s1len == s2len)\n', '    {\n', '      {\n', '        tmp___0 = memcmp((const void *) s1, (const void *) s2, s1len);\n', '      }\n', '      {\n', '        goto _L;\n', '      }\n', '    }\n', '    else\n', '    {\n', '      _L:\n', '      {\n', '        diff = strcoll_loop((const char *) s1, s1len + 1UL, (const char *) s2, s2len + 1UL);\n', '      }\n', '    }\n', '    return diff;\n', '  }\n', '}\n'], 'memcasecmp': ['  int diff;\n', '  {\n', '    {\n', '      while (1)\n', '      {\n', '        {\n', '        }\n', '        if (diff)\n', '        {\n', '          return diff;\n', '        }\n', '        i++;\n', '      }\n', '    }\n', '    return 0;\n', '  }\n', '}\n'], 'initbuffer': None, 'readlinebuffer_delim': ['  char *buffer;\n', '  char *p;\n', '  char *end;\n', '  size_t oldsize;\n', '  char *tmp___1;\n', '  {\n', '    {\n', '      buffer = linebuffer->buffer;\n', '      p = linebuffer->buffer;\n', '      end = buffer + linebuffer->size;\n', '      {\n', '        {\n', '          c = getc_unlocked(stream);\n', '        }\n', '        if (c == (- 1))\n', '        {\n', '          if (((unsigned long) p) == ((unsigned long) buffer))\n', '          {\n', '            return (struct linebuffer *) ((void *) 0);\n', '          }\n', '          else\n', '          {\n', '          }\n', '        }\n', '        if (((unsigned long) p) == ((unsigned long) end))\n', '        {\n', '          {\n', '            oldsize = linebuffer->size;\n', '            buffer = (char *) x2realloc((void *) buffer, & linebuffer->size);\n', '            p = buffer + oldsize;\n', '            linebuffer->buffer = buffer;\n', '          }\n', '        }\n', '        tmp___1 = p;\n', '        p++;\n', '      }\n', '    }\n', '    linebuffer->length = (size_t) (p - buffer);\n', '  }\n', '}\n'], 'hard_locale': ['  const char *p;\n', '  int tmp___0;\n', '  char *locale;\n', '  int tmp___3;\n', '  {\n', '    {\n', '      {\n', '        {\n', '          tmp___0 = strcmp(p, "C");\n', '        }\n', '        {\n', '          {\n', '          }\n', '        }\n', '        {\n', '          {\n', '            p = (const char *) setlocale(category, "C");\n', '          }\n', '          if (p)\n', '          {\n', '            {\n', '              tmp___3 = strcmp(p, (const char *) locale);\n', '            }\n', '            {\n', '              {\n', '              }\n', '            }\n', '          }\n', '          {\n', '          }\n', '        }\n', '      }\n', '    }\n', '    return hard;\n', '  }\n', '}\n'], 'freopen_safer': ['  _Bool protect_out;\n', '  _Bool protect_err;\n', '  int *tmp___6;\n', '  {\n', '    {\n', '    }\n', '    {\n', '      {\n', '        _L:\n', '        if (protect_err)\n', '        {\n', '        }\n', '        else\n', '        {\n', '          {\n', '            f = freopen((const char *) name, (const char *) mode, (FILE *) f);\n', '          }\n', '        }\n', '      }\n', '    }\n', '    {\n', '      tmp___6 = __errno_location();\n', '    }\n', '    return f;\n', '  }\n', '}\n'], 'clear_ungetc_buffer_preserving_position': None, 'rpl_fflush': None, 'rpl_fclose': ['  int fd;\n', '  int result;\n', '  {\n', '    {\n', '    }\n', '    if (fd < 0)\n', '    {\n', '      {\n', '        _L:\n', '        {\n', '        }\n', '      }\n', '    }\n', '    {\n', '      result = fclose(fp);\n', '    }\n', '  }\n', '}\n'], 'fdadvise': ['  {\n', '    {\n', '    }\n', '    return;\n', '  }\n', '}\n'], 'fadvise': ['  {\n', '  }\n', '}\n'], 'size_opt': ['  unsigned long tmp___1;\n', '  {\n', '    {\n', '      ;\n', '    }\n', '    return tmp___1;\n', '  }\n', '}\n'], 'find_field': ['  size_t size;\n', '  size_t i;\n', '  const unsigned short **tmp___1;\n', '  unsigned char tmp___2;\n', '  size_t tmp___3;\n', '  {\n', '    i = (size_t) 0;\n', '    {\n', '      while (1)\n', '      {\n', '        if (count < skip_fields)\n', '        {\n', '          if (! (i < size))\n', '          {\n', '            goto while_break;\n', '          }\n', '        }\n', '        else\n', '        {\n', '          goto while_break;\n', '          {\n', '          }\n', '        }\n', '        {\n', '          while (1)\n', '          {\n', '            if (i < size)\n', '            {\n', '              {\n', '              }\n', '              if (((const int) (* ((* tmp___1) + ((int) tmp___2)))) & 1)\n', '              {\n', '                goto while_break___1;\n', '              }\n', '            }\n', '            i++;\n', '          }\n', '          while_break___1:\n', '          ;\n', '        }\n', '        count++;\n', '      }\n', '      while_break:\n', '      ;\n', '    }\n', '    if (skip_chars < (size - i))\n', '    {\n', '      tmp___3 = skip_chars;\n', '    }\n', '    else\n', '    {\n', '      tmp___3 = size - i;\n', '    }\n', '    i += tmp___3;\n', '    return (char *) (line->buffer + i);\n', '  }\n', '}\n'], 'different': ['  int tmp___0;\n', '  int tmp___1;\n', '  int tmp___2;\n', '  {\n', '    if (check_chars < oldlen)\n', '    {\n', '      oldlen = check_chars;\n', '    }\n', '    if (check_chars < newlen)\n', '    {\n', '      newlen = check_chars;\n', '    }\n', '    if (ignore_case)\n', '    {\n', '      if (oldlen != newlen)\n', '      {\n', '        tmp___0 = 1;\n', '      }\n', '      else\n', '      {\n', '        {\n', '          tmp = memcasecmp((const void *) old, (const void *) new, oldlen);\n', '        }\n', '        if (tmp)\n', '        {\n', '          tmp___0 = 1;\n', '        }\n', '        else\n', '        {\n', '          tmp___0 = 0;\n', '        }\n', '      }\n', '      return (_Bool) tmp___0;\n', '    }\n', '    else\n', '    {\n', '      if (hard_LC_COLLATE)\n', '      {\n', '        {\n', '          tmp___1 = xmemcoll(old, oldlen, new, newlen);\n', '        }\n', '        return (_Bool) (tmp___1 != 0);\n', '      }\n', '      else\n', '      {\n', '        if (oldlen != newlen)\n', '        {\n', '          exit(-1);\n', '        }\n', '        else\n', '        {\n', '          if (tmp___2)\n', '          {\n', '            exit(-1);\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'writeline': None, 'check_file': ['  int tmp___0;\n', '  FILE *tmp___1;\n', '  {\n', '    {\n', '      tmp___0 = strcmp(infile, "-");\n', '    }\n', '    if (! (tmp___0 == 0))\n', '    {\n', '      {\n', '        tmp___1 = freopen_safer(infile, "r", stdin);\n', '        {\n', '          {\n', '            while (1)\n', '            {\n', '              {\n', '                goto while_break;\n', '              }\n', '              {\n', '              }\n', '              {\n', '                {\n', '                  {\n', '                    {\n', '                    }\n', '                  }\n', '                }\n', '              }\n', '            }\n', '            while_break:\n', '            ;\n', '          }\n', '        }\n', '      }\n', '      {\n', '        {\n', '          {\n', '            {\n', '            }\n', '          }\n', '          {\n', '            {\n', '            }\n', '            {\n', '              {\n', '                {\n', '                }\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '    }\n', '  }\n', '}\n'], 'main': ['  _Bool posixly_correct;\n', '  {\n', '    {\n', '      {\n', '        if (optc == (- 1))\n', '        {\n', '          if (posixly_correct)\n', '          {\n', '            {\n', '              {\n', '                if (((int) (* (optarg + 0))) == 43)\n', '                {\n', '                  {\n', '                  }\n', '                }\n', '                ;\n', '              }\n', '            }\n', '          }\n', '        }\n', '      }\n', '      while_break:\n', '      ;\n', '    }\n', '    if (((unsigned int) countmode) == 0U)\n', '    {\n', '    }\n', '    {\n', '    }\n', '  }\n', '}\n']}[{'name': 'close_stdout', 'start_line': 1307, 'end_line': 1355, 'lines': ['{', '  const char *write_error;', '  const char *tmp;', '  char *tmp___0;', '  int *tmp___1;', '  int *tmp___2;', '  int tmp___3;', '  int *tmp___4;', '  int tmp___5;', '  char *__cil_tmp10;', '  {', '    {', '      tmp___3 = close_stream(stdout);', '    }', '    if (tmp___3 != 0)', '    {', '      if (ignore_EPIPE)', '      {', '        exit(-1);', '      }', '      else', '      {', '        _L:', '        ;', '', '        {', '        }', '        if (file_name)', '        {', '          exit(-1);', '        }', '', '        {', '        }', '      }', '', '    }', '', '    {', '      tmp___5 = close_stream(stderr);', '    }', '    if (tmp___5 != 0)', '    {', '      exit(-1);', '    }', '', '    return;', '  }', '}']}, {'name': 'close_stream', 'start_line': 1365, 'end_line': 1417, 'lines': ['{', '  _Bool some_pending;', '  size_t tmp;', '  _Bool prev_fail;', '  int tmp___0;', '  _Bool fclose_fail;', '  int tmp___1;', '  int *tmp___2;', '  int *tmp___3;', '  {', '    {', '      tmp = __fpending(stream);', '      some_pending = (_Bool) (tmp != 0UL);', '      tmp___0 = ferror_unlocked(stream);', '      prev_fail = (_Bool) (tmp___0 != 0);', '      tmp___1 = rpl_fclose(stream);', '      fclose_fail = (_Bool) (tmp___1 != 0);', '    }', '    if (prev_fail)', '    {', '      exit(-1);', '    }', '    else', '    {', '      if (fclose_fail)', '      {', '        if (some_pending)', '        {', '          exit(-1);', '        }', '        else', '        {', '          if ((* tmp___3) != 9)', '          {', '            _L___0:', '            ;', '', '            if (! fclose_fail)', '            {', '              exit(-1);', '            }', '', '          }', '', '        }', '', '      }', '', '    }', '', '    return 0;', '  }', '}']}, {'name': 'to_uchar', 'start_line': 1466, 'end_line': 1470, 'lines': ['{', '  {', '    return (unsigned char) ch;', '  }', '}']}, {'name': 'xnmalloc', 'start_line': 1533, 'end_line': 1558, 'lines': ['{', '  int tmp;', '  void *tmp___0;', '  {', '    if ((sizeof(ptrdiff_t)) <= (sizeof(size_t)))', '    {', '      tmp = - 1;', '    }', '    else', '    {', '      tmp = - 2;', '    }', '', '    if ((((size_t) tmp) / s) < n)', '    {', '      {', '        xalloc_die();', '      }', '    }', '', '    {', '      tmp___0 = xmalloc(n * s);', '    }', '    return tmp___0;', '  }', '}']}, {'name': 'xstrtoul', 'start_line': 1575, 'end_line': 1891, 'lines': ['{', '  char *t_ptr;', '  char **p;', '  unsigned long tmp;', '  strtol_error err;', '  const char *q;', '  unsigned char ch;', '  const unsigned short **tmp___0;', '  int *tmp___1;', '  char *tmp___2;', '  int *tmp___3;', '  int *tmp___4;', '  int base;', '  int suffixes;', '  strtol_error overflow;', '  char *tmp___5;', '  char *tmp___6;', '  {', '    err = (strtol_error) 0;', '    if (0 <= strtol_base)', '    {', '      if (! (strtol_base <= 36))', '      {', '        exit(-1);', '      }', '', '    }', '', '    if (ptr)', '    {', '      exit(-1);', '    }', '    else', '    {', '      p = & t_ptr;', '    }', '', '    q = s;', '    ch = (unsigned char) (* q);', '    {', '      while (1)', '      {', '        while_continue:', '        ;', '', '        {', '          tmp___0 = __ctype_b_loc();', '        }', '        if (! (((const int) (* ((* tmp___0) + ((int) ch)))) & 8192))', '        {', '          goto while_break;', '        }', '', '      }', '', '      while_break:', '      ;', '', '    }', '    if (((int) ch) == 45)', '    {', '      exit(-1);', '    }', '', '    {', '      tmp___1 = __errno_location();', '      * tmp___1 = 0;', '      tmp = strtoul((const char *) s, (char **) p, strtol_base);', '    }', '    if (((unsigned long) (* p)) == ((unsigned long) s))', '    {', '      if (valid_suffixes)', '      {', '        exit(-1);', '      }', '', '    }', '    else', '    {', '      {', '        tmp___4 = __errno_location();', '      }', '      if ((* tmp___4) != 0)', '      {', '        if ((* tmp___3) != 34)', '        {', '          exit(-1);', '        }', '', '      }', '', '    }', '', '    if (! valid_suffixes)', '    {', '      exit(-1);', '    }', '', '    if (((int) (* (* p))) != 0)', '    {', '      if (! tmp___5)', '      {', '        exit(-1);', '      }', '', '      {', '      }', '      if (tmp___6)', '      {', '        {', '          if (((int) (* ((* (p + 0)) + 1))) == 105)', '          {', '            exit(-1);', '          }', '', '          if (((int) (* ((* (p + 0)) + 1))) == 66)', '          {', '            exit(-1);', '          }', '', '          if (((int) (* ((* (p + 0)) + 1))) == 68)', '          {', '            exit(-1);', '          }', '', '          case_105:', '          ;', '', '          if (((int) (* ((* (p + 0)) + 2))) == 66)', '          {', '            exit(-1);', '          }', '', '          case_66:', '          ;', '', '          case_68:', '          ;', '', '          base = 1000;', '          switch_break:', '          ;', '', '        }', '      }', '', '      {', '        if (((int) (* (* p))) == 98)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 66)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 99)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 69)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 71)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 103)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 107)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 75)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 77)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 109)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 80)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 84)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 116)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 119)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 89)', '        {', '          exit(-1);', '        }', '', '        if (((int) (* (* p))) == 90)', '        {', '          exit(-1);', '        }', '', '        case_98:', '        ;', '', '        {', '        }', '        case_66___0:', '        ;', '', '        {', '        }', '        case_99:', '        ;', '', '        overflow = (strtol_error) 0;', '        case_69:', '        ;', '', '        {', '        }', '        case_71:', '        ;', '', '        case_103:', '        ;', '', '        {', '        }', '        case_107:', '        ;', '', '        case_75:', '        ;', '', '        {', '        }', '        case_77:', '        ;', '', '        case_109:', '        ;', '', '        {', '        }', '        case_80:', '        ;', '', '        {', '        }', '        case_84:', '        ;', '', '        case_116:', '        ;', '', '        {', '        }', '        case_119:', '        ;', '', '        {', '        }', '        case_89:', '        ;', '', '        {', '        }', '        case_90:', '        ;', '', '        {', '        }', '        switch_default:', '        ;', '', '        * val = tmp;', '        switch_break___0:', '        ;', '', '      }', '      if (* (* p))', '      {', '        exit(-1);', '      }', '', '    }', '', '    * val = tmp;', '    return err;', '  }', '}']}, {'name': 'xmemcoll', 'start_line': 1906, 'end_line': 1925, 'lines': ['{', '  int diff;', '  int tmp;', '  int collation_errno;', '  int *tmp___0;', '  {', '    {', '      tmp = memcoll(s1, s1len, s2, s2len);', '      diff = tmp;', '      tmp___0 = __errno_location();', '      collation_errno = * tmp___0;', '    }', '    if (collation_errno)', '    {', '      exit(-1);', '    }', '', '    return diff;', '  }', '}']}, {'name': 'x2nrealloc', 'start_line': 1929, 'end_line': 1959, 'lines': ['{', '  size_t n;', '  void *tmp;', '  {', '    n = * pn;', '    if (! p)', '    {', '      if (! n)', '      {', '        n = 128UL / s;', '        n += (size_t) (! n);', '      }', '', '    }', '    else', '    {', '      if ((0xaaaaaaaaaaaaaaaaUL / s) <= n)', '      {', '        exit(-1);', '      }', '', '      n += (n + 1UL) / 2UL;', '    }', '', '    {', '      * pn = n;', '      tmp = xrealloc(p, n * s);', '    }', '    return tmp;', '  }', '}']}, {'name': 'xrealloc', 'start_line': 1971, 'end_line': 1996, 'lines': ['{', '  {', '    if (! n)', '    {', '      if (p)', '      {', '        exit(-1);', '      }', '', '    }', '', '    {', '      p = realloc(p, n);', '    }', '    if (! p)', '    {', '      if (n)', '      {', '        exit(-1);', '      }', '', '    }', '', '    return p;', '  }', '}']}, {'name': 'x2realloc', 'start_line': 1999, 'end_line': 2007, 'lines': ['{', '  void *tmp;', '  {', '    {', '      tmp = x2nrealloc(p, pn, (size_t) 1);', '    }', '    return tmp;', '  }', '}']}, {'name': 'set_program_name', 'start_line': 2247, 'end_line': 2286, 'lines': ['{', '  const char *slash;', '  const char *base;', '  int tmp;', '  int tmp___0;', '  {', '    if (((unsigned long) argv0) == ((unsigned long) ((void *) 0)))', '    {', '      exit(-1);', '    }', '', '    {', "      slash = (const char *) strrchr(argv0, '/');", '    }', '    if (((unsigned long) slash) != ((unsigned long) ((void *) 0)))', '    {', '      base = slash + 1;', '    }', '', '    if ((base - argv0) >= 7L)', '    {', '      {', '        tmp___0 = strncmp(base - 7, "/.libs/", (size_t) 7);', '      }', '      if (tmp___0 == 0)', '      {', '        if (tmp == 0)', '        {', '          exit(-1);', '        }', '', '      }', '', '    }', '', '    program_name = argv0;', '    program_invocation_name = (char *) argv0;', '    return;', '  }', '}']}, {'name': 'strcoll_loop', 'start_line': 2343, 'end_line': 2402, 'lines': ['{', '  int diff;', '  size_t size1;', '  size_t tmp;', '  size_t size2;', '  size_t tmp___0;', '  int *tmp___1;', '  int *tmp___2;', '  int tmp___3;', '  {', '    {', '      while (1)', '      {', '        while_continue:', '        ;', '', '        {', '          tmp___1 = __errno_location();', '          * tmp___1 = 0;', '          diff = strcoll(s1, s2);', '        }', '        if (diff)', '        {', '          tmp___3 = 1;', '        }', '        else', '        {', '          if (* tmp___2)', '          {', '            exit(-1);', '          }', '', '        }', '', '        if (tmp___3)', '        {', '          goto while_break;', '        }', '', '        {', '        }', '        if (s1size == 0UL)', '        {', '          exit(-1);', '        }', '', '        if (s2size == 0UL)', '        {', '          exit(-1);', '        }', '', '      }', '', '      while_break:', '      ;', '', '    }', '    return diff;', '  }', '}']}, {'name': 'memcoll', 'start_line': 2405, 'end_line': 2448, 'lines': ['{', '  int diff;', '  int *tmp;', '  char n1;', '  char n2;', '  int tmp___0;', '  {', '    if (s1len == s2len)', '    {', '      {', '        tmp___0 = memcmp((const void *) s1, (const void *) s2, s1len);', '      }', '      if (tmp___0 == 0)', '      {', '        {', '          tmp = __errno_location();', '          * tmp = 0;', '          diff = 0;', '        }', '      }', '      else', '      {', '        goto _L;', '      }', '', '    }', '    else', '    {', '      _L:', '      {', '        n1 = * (s1 + s1len);', '        n2 = * (s2 + s2len);', "        * (s1 + s1len) = (char) '\\000';", "        * (s2 + s2len) = (char) '\\000';", '        diff = strcoll_loop((const char *) s1, s1len + 1UL, (const char *) s2, s2len + 1UL);', '        * (s1 + s1len) = n1;', '        * (s2 + s2len) = n2;', '      }', '', '    }', '', '    return diff;', '  }', '}']}, {'name': 'memcasecmp', 'start_line': 2453, 'end_line': 2502, 'lines': ['{', '  size_t i;', '  const char *s1;', '  const char *s2;', '  unsigned char u1;', '  unsigned char u2;', '  int U1;', '  int tmp;', '  int U2;', '  int tmp___0;', '  int diff;', '  {', '    s1 = (const char *) vs1;', '    s2 = (const char *) vs2;', '    i = (size_t) 0;', '    {', '      while (1)', '      {', '        while_continue:', '        ;', '', '        if (! (i < n))', '        {', '          goto while_break;', '        }', '', '        {', '          u1 = (unsigned char) (* (s1 + i));', '          u2 = (unsigned char) (* (s2 + i));', '          tmp = toupper((int) u1);', '          U1 = tmp;', '          tmp___0 = toupper((int) u2);', '          U2 = tmp___0;', '          diff = U1 - U2;', '        }', '        if (diff)', '        {', '          return diff;', '        }', '', '        i++;', '      }', '', '      while_break:', '      ;', '', '    }', '    return 0;', '  }', '}']}, {'name': 'initbuffer', 'start_line': 2564, 'end_line': 2571, 'lines': ['{', '  {', '    {', '      memset((void *) linebuffer, 0, sizeof(* linebuffer));', '    }', '    return;', '  }', '}']}, {'name': 'readlinebuffer_delim', 'start_line': 2574, 'end_line': 2654, 'lines': ['{', '  int c;', '  char *buffer;', '  char *p;', '  char *end;', '  int tmp;', '  int tmp___0;', '  size_t oldsize;', '  char *tmp___1;', '  {', '    {', '      buffer = linebuffer->buffer;', '      p = linebuffer->buffer;', '      end = buffer + linebuffer->size;', '      tmp = feof_unlocked(stream);', '    }', '    if (tmp)', '    {', '      exit(-1);', '    }', '', '    {', '      while (1)', '      {', '        while_continue:', '        ;', '', '        {', '          c = getc_unlocked(stream);', '        }', '        if (c == (- 1))', '        {', '          if (((unsigned long) p) == ((unsigned long) buffer))', '          {', '            return (struct linebuffer *) ((void *) 0);', '          }', '          else', '          {', '            if (tmp___0)', '            {', '              exit(-1);', '            }', '', '          }', '', '          if (((int) (* (p + (- 1)))) == ((int) delimiter))', '          {', '            exit(-1);', '          }', '', '        }', '', '        if (((unsigned long) p) == ((unsigned long) end))', '        {', '          {', '            oldsize = linebuffer->size;', '            buffer = (char *) x2realloc((void *) buffer, & linebuffer->size);', '            p = buffer + oldsize;', '            linebuffer->buffer = buffer;', '            end = buffer + linebuffer->size;', '          }', '        }', '', '        tmp___1 = p;', '        p++;', '        * tmp___1 = (char) c;', '        if (! (c != ((int) delimiter)))', '        {', '          goto while_break;', '        }', '', '      }', '', '      while_break:', '      ;', '', '    }', '    linebuffer->length = (size_t) (p - buffer);', '    return linebuffer;', '  }', '}']}, {'name': 'hard_locale', 'start_line': 2672, 'end_line': 2771, 'lines': ['{', '  _Bool hard;', '  const char *p;', '  const char *tmp;', '  int tmp___0;', '  int tmp___1;', '  char *locale;', '  char *tmp___2;', '  int tmp___3;', '  int tmp___4;', '  {', '    {', '      hard = (_Bool) 1;', '      tmp = (const char *) setlocale(category, (const char *) ((void *) 0));', '      p = tmp;', '    }', '    if (p)', '    {', '      if (1)', '      {', '        {', '          tmp___0 = strcmp(p, "C");', '        }', '        if (tmp___0 == 0)', '        {', '          exit(-1);', '        }', '        else', '        {', '          {', '            tmp___1 = strcmp(p, "POSIX");', '          }', '          if (tmp___1 == 0)', '          {', '            exit(-1);', '          }', '', '        }', '', '      }', '      else', '      {', '        {', '          tmp___2 = strdup(p);', '          locale = tmp___2;', '        }', '        if (locale)', '        {', '          {', '            p = (const char *) setlocale(category, "C");', '          }', '          if (p)', '          {', '            {', '              tmp___3 = strcmp(p, (const char *) locale);', '            }', '            if (tmp___3 == 0)', '            {', '              hard = (_Bool) 0;', '            }', '            else', '            {', '              goto _L;', '            }', '', '          }', '          else', '          {', '            _L:', '            {', '              p = (const char *) setlocale(category, "POSIX");', '            }', '', '            if (p)', '            {', '              {', '                tmp___4 = strcmp(p, (const char *) locale);', '              }', '              if (tmp___4 == 0)', '              {', '                hard = (_Bool) 0;', '              }', '', '            }', '', '          }', '', '          {', '            setlocale(category, (const char *) locale);', '            free((void *) locale);', '          }', '        }', '', '      }', '', '    }', '', '    return hard;', '  }', '}']}, {'name': 'freopen_safer', 'start_line': 2801, 'end_line': 2945, 'lines': ['{', '  _Bool protect_in;', '  _Bool protect_out;', '  _Bool protect_err;', '  int saved_errno;', '  int tmp;', '  int tmp___0;', '  int tmp___1;', '  int tmp___2;', '  _Bool tmp___3;', '  _Bool tmp___4;', '  _Bool tmp___5;', '  int *tmp___6;', '  int *tmp___7;', '  {', '    {', '      protect_in = (_Bool) 0;', '      protect_out = (_Bool) 0;', '      protect_err = (_Bool) 0;', '      tmp = fileno(f);', '    }', '    {', '      if (tmp == 2)', '      {', '        exit(-1);', '      }', '', '      if (tmp == 1)', '      {', '        exit(-1);', '      }', '', '      if (tmp == 0)', '      {', '        goto case_0;', '      }', '', '      switch_default:', '      ;', '', '      {', '      }', '      if (tmp___0 != 2)', '      {', '        exit(-1);', '      }', '', '      case_2:', '      ;', '', '      {', '      }', '      if (tmp___1 != 1)', '      {', '        exit(-1);', '      }', '', '      case_1:', '      ;', '', '      {', '      }', '      if (tmp___2 != 0)', '      {', '        exit(-1);', '      }', '', '      case_0:', '      ;', '', '      goto switch_break;', '      switch_break:', '      ;', '', '    }', '    if (protect_in)', '    {', '      if (tmp___5)', '      {', '        exit(-1);', '      }', '', '    }', '    else', '    {', '      _L___0:', '      if (protect_out)', '      {', '        if (tmp___4)', '        {', '          exit(-1);', '        }', '', '      }', '      else', '      {', '        _L:', '        if (protect_err)', '        {', '          if (tmp___3)', '          {', '            exit(-1);', '          }', '', '        }', '        else', '        {', '          {', '            f = freopen((const char *) name, (const char *) mode, (FILE *) f);', '          }', '        }', '', '', '      }', '', '', '    }', '', '    {', '      tmp___6 = __errno_location();', '      saved_errno = * tmp___6;', '    }', '    if (protect_err)', '    {', '      exit(-1);', '    }', '', '    if (protect_out)', '    {', '      exit(-1);', '    }', '', '    if (protect_in)', '    {', '      exit(-1);', '    }', '', '    if (! f)', '    {', '      exit(-1);', '    }', '', '    return f;', '  }', '}']}, {'name': 'clear_ungetc_buffer_preserving_position', 'start_line': 2953, 'end_line': 2962, 'lines': ['{', '  {', '    if (fp->_flags & 256)', '    {', '      exit(-1);', '    }', '', '    return;', '  }', '}']}, {'name': 'rpl_fflush', 'start_line': 2965, 'end_line': 2995, 'lines': ['{', '  int tmp;', '  int tmp___0;', '  int tmp___1;', '  {', '    if (((unsigned long) stream) == ((unsigned long) ((void *) 0)))', '    {', '      exit(-1);', '    }', '    else', '    {', '      {', '        tmp___0 = __freading(stream);', '      }', '      if (! (tmp___0 != 0))', '      {', '        {', '          tmp = fflush(stream);', '        }', '        return tmp;', '      }', '', '    }', '', '    {', '      clear_ungetc_buffer_preserving_position(stream);', '      tmp___1 = fflush(stream);', '    }', '    return tmp___1;', '  }', '}']}, {'name': 'rpl_fclose', 'start_line': 3001, 'end_line': 3062, 'lines': ['{', '  int saved_errno;', '  int fd;', '  int result;', '  int tmp;', '  int *tmp___0;', '  int tmp___1;', '  int tmp___2;', '  __off_t tmp___3;', '  int tmp___4;', '  int *tmp___5;', '  {', '    {', '      saved_errno = 0;', '      result = 0;', '      fd = fileno(fp);', '    }', '    if (fd < 0)', '    {', '      exit(-1);', '    }', '', '    {', '      tmp___1 = __freading(fp);', '    }', '    if (tmp___1 != 0)', '    {', '      {', '        tmp___2 = fileno(fp);', '        tmp___3 = lseek(tmp___2, (__off_t) 0, 1);', '      }', '      if (tmp___3 != (- 1L))', '      {', '        _L:', '        {', '          tmp___4 = rpl_fflush(fp);', '        }', '', '        if (tmp___4)', '        {', '          exit(-1);', '        }', '', '      }', '', '    }', '    else', '    {', '      goto _L;', '    }', '', '    {', '      result = fclose(fp);', '    }', '    if (saved_errno != 0)', '    {', '      exit(-1);', '    }', '', '    return result;', '  }', '}']}, {'name': 'fdadvise', 'start_line': 3081, 'end_line': 3091, 'lines': ['{', '  int __x;', '  int tmp;', '  {', '    {', '      tmp = posix_fadvise(fd, offset, len, (int) advice);', '      __x = tmp;', '    }', '    return;', '  }', '}']}, {'name': 'fadvise', 'start_line': 3094, 'end_line': 3107, 'lines': ['{', '  int tmp;', '  {', '    if (fp)', '    {', '      {', '        tmp = fileno(fp);', '        fdadvise(tmp, (off_t) 0, (off_t) 0, advice);', '      }', '    }', '', '    return;', '  }', '}']}, {'name': 'size_opt', 'start_line': 3182, 'end_line': 3224, 'lines': ['{', '  unsigned long size;', '  strtol_error tmp;', '  char *tmp___0;', '  unsigned long tmp___1;', '  char *__cil_tmp7;', '  {', '    {', '      tmp = xstrtoul(opt, (char **) ((void *) 0), 10, & size, "");', '    }', '    {', '      if (((unsigned int) tmp) == 0U)', '      {', '        goto case_0;', '      }', '', '      if (((unsigned int) tmp) == 1U)', '      {', '        exit(-1);', '      }', '', '      case_0:', '      case_1:', '      goto switch_break;', '', '', '      switch_default:', '      ;', '', '      {', '      }', '      switch_break:', '      ;', '', '    }', '    if (size < 0xffffffffffffffffUL)', '    {', '      tmp___1 = size;', '    }', '', '    return tmp___1;', '  }', '}']}, {'name': 'find_field', 'start_line': 3227, 'end_line': 3340, 'lines': ['{', '  size_t count;', '  const char *lp;', '  size_t size;', '  size_t i;', '  const unsigned short **tmp;', '  unsigned char tmp___0;', '  const unsigned short **tmp___1;', '  unsigned char tmp___2;', '  size_t tmp___3;', '  {', '    lp = (const char *) line->buffer;', '    size = (size_t) (line->length - 1UL);', '    i = (size_t) 0;', '    count = (size_t) 0;', '    {', '      while (1)', '      {', '        while_continue:', '        ;', '', '        if (count < skip_fields)', '        {', '          if (! (i < size))', '          {', '            goto while_break;', '          }', '', '        }', '        else', '        {', '          goto while_break;', '        }', '', '        {', '          while (1)', '          {', '            while_continue___0:', '            ;', '', '            if (i < size)', '            {', '              {', '                tmp = __ctype_b_loc();', '                tmp___0 = to_uchar((char) (* (lp + i)));', '              }', '              if (! (((const int) (* ((* tmp) + ((int) tmp___0)))) & 1))', '              {', '                goto while_break___0;', '              }', '', '            }', '            else', '            {', '              goto while_break___0;', '            }', '', '            i++;', '          }', '', '          while_break___0:', '          ;', '', '        }', '        {', '          while (1)', '          {', '            while_continue___1:', '            ;', '', '            if (i < size)', '            {', '              {', '                tmp___1 = __ctype_b_loc();', '                tmp___2 = to_uchar((char) (* (lp + i)));', '              }', '              if (((const int) (* ((* tmp___1) + ((int) tmp___2)))) & 1)', '              {', '                goto while_break___1;', '              }', '', '            }', '            else', '            {', '              goto while_break___1;', '            }', '', '            i++;', '          }', '', '          while_break___1:', '          ;', '', '        }', '        count++;', '      }', '', '      while_break:', '      ;', '', '    }', '    if (skip_chars < (size - i))', '    {', '      tmp___3 = skip_chars;', '    }', '    else', '    {', '      tmp___3 = size - i;', '    }', '', '    i += tmp___3;', '    return (char *) (line->buffer + i);', '  }', '}']}, {'name': 'different', 'start_line': 3343, 'end_line': 3413, 'lines': ['{', '  int tmp;', '  int tmp___0;', '  int tmp___1;', '  int tmp___2;', '  int tmp___3;', '  {', '    if (check_chars < oldlen)', '    {', '      oldlen = check_chars;', '    }', '', '    if (check_chars < newlen)', '    {', '      newlen = check_chars;', '    }', '', '    if (ignore_case)', '    {', '      if (oldlen != newlen)', '      {', '        tmp___0 = 1;', '      }', '      else', '      {', '        {', '          tmp = memcasecmp((const void *) old, (const void *) new, oldlen);', '        }', '        if (tmp)', '        {', '          tmp___0 = 1;', '        }', '        else', '        {', '          tmp___0 = 0;', '        }', '', '      }', '', '      return (_Bool) tmp___0;', '    }', '    else', '    {', '      if (hard_LC_COLLATE)', '      {', '        {', '          tmp___1 = xmemcoll(old, oldlen, new, newlen);', '        }', '        return (_Bool) (tmp___1 != 0);', '      }', '      else', '      {', '        if (oldlen != newlen)', '        {', '          exit(-1);', '        }', '        else', '        {', '          if (tmp___2)', '          {', '            exit(-1);', '          }', '', '        }', '', '      }', '', '    }', '', '  }', '}']}, {'name': 'writeline', 'start_line': 3416, 'end_line': 3451, 'lines': ['{', '  int tmp;', '  int tmp___0;', '  {', '    if (linecount == 0UL)', '    {', '      tmp___0 = (int) output_unique;', '    }', '    else', '    {', '      if (! match)', '      {', '        tmp = (int) output_first_repeated;', '      }', '', '      tmp___0 = tmp;', '    }', '', '    if (! tmp___0)', '    {', '      return;', '    }', '', '    if (((unsigned int) countmode) == 0U)', '    {', '      {', '        printf((const char *) "%7lu ", linecount + 1UL);', '      }', '    }', '', '    {', '      fwrite_unlocked((const void *) line->buffer, sizeof(char), (size_t) line->length, (FILE *) stdout);', '    }', '    return;', '  }', '}']}, {'name': 'check_file', 'start_line': 3454, 'end_line': 3783, 'lines': ['{', '  struct linebuffer lb1;', '  struct linebuffer lb2;', '  struct linebuffer *thisline;', '  struct linebuffer *prevline;', '  int *tmp;', '  int tmp___0;', '  FILE *tmp___1;', '  int *tmp___2;', '  int tmp___3;', '  FILE *tmp___4;', '  char *prevfield;', '  size_t prevlen;', '  char *thisfield;', '  size_t thislen;', '  struct linebuffer *tmp___5;', '  struct linebuffer *_tmp;', '  _Bool tmp___6;', '  int tmp___7;', '  char *prevfield___0;', '  size_t prevlen___0;', '  uintmax_t match_count;', '  _Bool first_delimiter;', '  struct linebuffer *tmp___8;', '  _Bool match;', '  char *thisfield___0;', '  size_t thislen___0;', '  int tmp___9;', '  struct linebuffer *tmp___10;', '  _Bool tmp___11;', '  int tmp___12;', '  struct linebuffer *_tmp___0;', '  int tmp___14;', '  char *tmp___15;', '  int tmp___16;', '  int tmp___17;', '  char *__cil_tmp42;', '  char *__cil_tmp43;', '  char *__cil_tmp44;', '  char *__cil_tmp45;', '  {', '    {', '      tmp___0 = strcmp(infile, "-");', '    }', '    if (! (tmp___0 == 0))', '    {', '      {', '        tmp___1 = freopen_safer(infile, "r", stdin);', '      }', '      if (! tmp___1)', '      {', '        exit(-1);', '      }', '', '    }', '', '    {', '      tmp___3 = strcmp(outfile, "-");', '    }', '    if (! (tmp___3 == 0))', '    {', '      if (! tmp___4)', '      {', '        exit(-1);', '      }', '', '    }', '', '    {', '      fadvise(stdin, (fadvice_t) 2);', '      thisline = & lb1;', '      prevline = & lb2;', '      initbuffer(thisline);', '      initbuffer(prevline);', '    }', '    if (output_unique)', '    {', '      if (output_first_repeated)', '      {', '        if (((unsigned int) countmode) == 1U)', '        {', '          {', '            while (1)', '            {', '              while_continue:', '              ;', '', '              {', '                tmp___7 = feof_unlocked(stdin);', '              }', '              if (tmp___7)', '              {', '                exit(-1);', '              }', '', '              {', '                tmp___5 = readlinebuffer_delim(thisline, stdin, delimiter);', '              }', '              if (((unsigned long) tmp___5) == ((unsigned long) ((struct linebuffer *) 0)))', '              {', '                goto while_break;', '              }', '', '              {', '                thisfield = (char *) find_field((const struct linebuffer *) thisline);', '                thislen = (thisline->length - 1UL) - ((size_t) (thisfield - thisline->buffer));', '              }', '              if (prevline->length == 0UL)', '              {', '                goto _L;', '              }', '              else', '              {', '                {', '                  tmp___6 = different(thisfield, prevfield, thislen, prevlen);', '                }', '                if (tmp___6)', '                {', '                  _L:', '                  {', '                    fwrite_unlocked((const void *) thisline->buffer, sizeof(char), thisline->length, (FILE *) stdout);', '                  }', '', '                  {', '                    while (1)', '                    {', '                      while_continue___0:', '                      ;', '', '                      _tmp = prevline;', '                      prevline = thisline;', '                      thisline = _tmp;', '                      goto while_break___0;', '                    }', '', '                    while_break___0:', '                    ;', '', '                  }', '                  prevfield = thisfield;', '                  prevlen = thislen;', '                }', '', '              }', '', '            }', '', '            while_break:', '            ;', '', '          }', '        }', '        else', '        {', '          goto _L___2;', '        }', '', '      }', '      else', '      {', '        goto _L___2;', '      }', '', '    }', '    else', '    {', '      _L___2:', '      {', '        match_count = (uintmax_t) 0;', '        first_delimiter = (_Bool) 1;', '        tmp___8 = readlinebuffer_delim(prevline, stdin, delimiter);', '      }', '', '      if (((unsigned long) tmp___8) == ((unsigned long) ((struct linebuffer *) 0)))', '      {', '        exit(-1);', '      }', '', '      {', '        prevfield___0 = (char *) find_field((const struct linebuffer *) prevline);', '        prevlen___0 = (prevline->length - 1UL) - ((size_t) (prevfield___0 - prevline->buffer));', '      }', '      {', '        while (1)', '        {', '          while_continue___1:', '          ;', '', '          {', '            tmp___14 = feof_unlocked(stdin);', '          }', '          if (tmp___14)', '          {', '            exit(-1);', '          }', '', '          {', '            tmp___10 = readlinebuffer_delim(thisline, stdin, delimiter);', '          }', '          if (((unsigned long) tmp___10) == ((unsigned long) ((struct linebuffer *) 0)))', '          {', '            {', '              tmp___9 = ferror_unlocked(stdin);', '            }', '            if (tmp___9)', '            {', '              exit(-1);', '            }', '', '            goto while_break___1;', '          }', '', '          {', '            thisfield___0 = (char *) find_field((const struct linebuffer *) thisline);', '            thislen___0 = (thisline->length - 1UL) - ((size_t) (thisfield___0 - thisline->buffer));', '            tmp___11 = different(thisfield___0, prevfield___0, thislen___0, prevlen___0);', '          }', '          if (tmp___11)', '          {', '            tmp___12 = 0;', '          }', '          else', '          {', '            tmp___12 = 1;', '          }', '', '          match = (_Bool) tmp___12;', '          match_count += (uintmax_t) match;', '          if (match_count == 0xffffffffffffffffUL)', '          {', '            exit(-1);', '          }', '', '          if (((unsigned int) delimit_groups) != 0U)', '          {', '            if (! match)', '            {', '              exit(-1);', '            }', '            else', '            {', '              if (match_count == 1UL)', '              {', '                exit(-1);', '              }', '', '            }', '', '          }', '', '          if (! match)', '          {', '            goto _L___0;', '          }', '          else', '          {', '            if (output_later_repeated)', '            {', '              _L___0:', '              ;', '', '              {', '                writeline((const struct linebuffer *) prevline, match, match_count);', '              }', '              {', '                while (1)', '                {', '                  while_continue___2:', '                  ;', '', '                  _tmp___0 = prevline;', '                  prevline = thisline;', '                  thisline = _tmp___0;', '                  goto while_break___2;', '                }', '', '                while_break___2:', '                ;', '', '              }', '              prevfield___0 = thisfield___0;', '              prevlen___0 = thislen___0;', '              if (! match)', '              {', '                match_count = (uintmax_t) 0;', '              }', '', '            }', '', '          }', '', '        }', '', '        while_break___1:', '        ;', '', '      }', '      {', '        writeline((const struct linebuffer *) prevline, (_Bool) 0, match_count);', '      }', '    }', '', '    closefiles:', '    {', '      tmp___16 = ferror_unlocked(stdin);', '    }', '', '    if (tmp___16)', '    {', '      exit(-1);', '    }', '    else', '    {', '      {', '        tmp___17 = rpl_fclose(stdin);', '      }', '      if (tmp___17 != 0)', '      {', '        exit(-1);', '      }', '', '    }', '', '    {', '      free((void *) lb1.buffer);', '      free((void *) lb2.buffer);', '    }', '    return;', '  }', '}']}, {'name': 'main', 'start_line': 3786, 'end_line': 4158, 'lines': ['{', '  int optc;', '  _Bool posixly_correct;', '  char *tmp;', '  enum Skip_field_option_type skip_field_option_type;', '  int nfiles;', '  const char *file[2];', '  char delimiter;', '  const char *tmp___0;', '  char *tmp___1;', '  int tmp___2;', '  int tmp___3;', '  unsigned long size;', '  const char *tmp___4;', '  char *tmp___5;', '  int tmp___6;', '  int tmp___7;', '  strtol_error tmp___8;', '  ptrdiff_t tmp___9;', '  char *tmp___10;', '  void *__cil_tmp22;', '  char *__cil_tmp23;', '  char *__cil_tmp24;', '  char *__cil_tmp25;', '  char *__cil_tmp26;', '  char *__cil_tmp27;', '  char *__cil_tmp28;', '  char *__cil_tmp29;', '  char *__cil_tmp30;', '  char *__cil_tmp31;', '  char *__cil_tmp32;', '  char *__cil_tmp33;', '  char *__cil_tmp34;', '  char *__cil_tmp35;', '  char *__cil_tmp36;', '  {', '    {', '      optc = 0;', '      tmp = getenv("POSIXLY_CORRECT");', '      posixly_correct = (_Bool) (((unsigned long) tmp) != ((unsigned long) ((void *) 0)));', '      skip_field_option_type = (enum Skip_field_option_type) 0;', '      nfiles = 0;', "      delimiter = (char) '\\n';", '      file[1] = "-";', '      file[0] = file[1];', '      set_program_name((const char *) (* (argv + 0)));', '      setlocale(6, "");', '      bindtextdomain("coreutils", "/usr/local/share/locale");', '      textdomain("coreutils");', '      hard_LC_COLLATE = hard_locale(3);', '      atexit(& close_stdout);', '      skip_chars = (size_t) 0;', '      skip_fields = (size_t) 0;', '      check_chars = 0xffffffffffffffffUL;', '      output_first_repeated = (_Bool) 1;', '      output_unique = output_first_repeated;', '      output_later_repeated = (_Bool) 0;', '      countmode = (enum countmode) 1;', '      delimit_groups = (enum delimit_method) 0;', '    }', '    {', '      while (1)', '      {', '        while_continue:', '        ;', '', '        if (optc == (- 1))', '        {', '          exit(-1);', '        }', '        else', '        {', '          if (posixly_correct)', '          {', '            if (nfiles != 0)', '            {', '              exit(-1);', '            }', '', '          }', '          else', '          {', '            _L___3:', '            {', '              optc = getopt_long(argc, (char *const *) argv, "-0123456789Dcdf:is:uw:z", longopts, (int *) ((void *) 0));', '            }', '', '            if (optc == (- 1))', '            {', '              _L___2:', '              if (argc <= optind)', '              {', '                goto while_break;', '              }', '', '', '              if (nfiles == 2)', '              {', '                exit(-1);', '              }', '', '            }', '            else', '            {', '              {', '                if (optc == 1)', '                {', '                  goto case_1;', '                }', '', '                if (optc == 48)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 49)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 50)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 51)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 52)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 53)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 54)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 55)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 56)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 57)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 99)', '                {', '                  goto case_99;', '                }', '', '                if (optc == 100)', '                {', '                  goto case_100;', '                }', '', '                if (optc == 68)', '                {', '                  exit(-1);', '                }', '', '                if (optc == 102)', '                {', '                  goto case_102;', '                }', '', '                if (optc == 105)', '                {', '                  goto case_105;', '                }', '', '                if (optc == 115)', '                {', '                  goto case_115;', '                }', '', '                if (optc == 117)', '                {', '                  goto case_117;', '                }', '', '                if (optc == 119)', '                {', '                  goto case_119;', '                }', '', '                if (optc == 122)', '                {', '                  exit(-1);', '                }', '', '                if (optc == (- 130))', '                {', '                  exit(-1);', '                }', '', '                if (optc == (- 131))', '                {', '                  exit(-1);', '                }', '', '                case_1:', '                if (((int) (* (optarg + 0))) == 43)', '                {', '                  if (tmp___7 < 200112)', '                  {', '                    exit(-1);', '                  }', '', '                }', '                else', '                {', '                  _L___1:', '                  if (nfiles == 2)', '                  {', '                    exit(-1);', '                  }', '                  else', '                  {', '                    tmp___6 = nfiles;', '                    nfiles++;', '                    file[tmp___6] = (const char *) optarg;', '                  }', '', '', '                }', '', '', '                goto switch_break;', '                case_48:', '                ;', '', '                case_49:', '                ;', '', '                case_50:', '                ;', '', '                case_51:', '                ;', '', '                case_52:', '                ;', '', '                case_53:', '                ;', '', '                case_54:', '                ;', '', '                case_55:', '                ;', '', '                case_56:', '                ;', '', '                case_57:', '                ;', '', '                if (((unsigned int) skip_field_option_type) == 2U)', '                {', '                  exit(-1);', '                }', '', '                case_99:', '                countmode = (enum countmode) 0;', '', '                goto switch_break;', '                case_100:', '                output_unique = (_Bool) 0;', '', '                goto switch_break;', '                case_68:', '                ;', '', '                output_unique = (_Bool) 0;', '                if (((unsigned long) optarg) == ((unsigned long) ((void *) 0)))', '                {', '                  exit(-1);', '                }', '', '                case_102:', '                {', '                  skip_field_option_type = (enum Skip_field_option_type) 2;', '                  skip_fields = size_opt((const char *) optarg, "invalid number of fields to skip");', '                }', '', '                goto switch_break;', '                case_105:', '                ignore_case = (_Bool) 1;', '', '                goto switch_break;', '                case_115:', '                {', '                  skip_chars = size_opt((const char *) optarg, "invalid number of bytes to skip");', '                }', '', '                goto switch_break;', '                case_117:', '                output_first_repeated = (_Bool) 0;', '', '                goto switch_break;', '                case_119:', '                {', '                  check_chars = size_opt((const char *) optarg, "invalid number of bytes to compare");', '                }', '', '                goto switch_break;', '                case_122:', '                ;', '', "                delimiter = (char) '\\000';", '                case_neg_130:', '                ;', '', '                {', '                }', '                case_neg_131:', '                ;', '', '                {', '                }', '                goto switch_break;', '                switch_default:', '                ;', '', '                {', '                }', '                switch_break:', '                ;', '', '              }', '            }', '', '          }', '', '        }', '', '      }', '', '      while_break:', '      ;', '', '    }', '    if (((unsigned int) countmode) == 0U)', '    {', '      if (output_later_repeated)', '      {', '        exit(-1);', '      }', '', '    }', '', '    {', '      check_file(file[0], file[1], delimiter);', '      exit(0);', '    }', '  }', '}']}]