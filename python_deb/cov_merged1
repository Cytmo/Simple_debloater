        -:    0:Source:gzip-1.2.4.c.origin.c
        -:    0:Graph:./gzip-1.2.4.c.origin.gcno
        -:    0:Data:./gzip-1.2.4.c.origin.gcda
        -:    1:typedef void *voidp;
        -:    2:typedef unsigned char uch;
        -:    3:typedef unsigned short ush;
        -:    4:typedef unsigned long ulg;
        -:    5:typedef long __off_t;
        -:    6:typedef long __off64_t;
        -:    7:typedef long __ssize_t;
        -:    8:typedef __ssize_t ssize_t;
        -:    9:typedef unsigned long size_t;
        -:   10:struct _IO_FILE;
        -:   11:struct _IO_FILE;
        -:   12:typedef struct _IO_FILE FILE;
        -:   13:typedef void _IO_lock_t;
        -:   14:struct _IO_marker {
        -:   15:  struct _IO_marker *_next;
        -:   16:  struct _IO_FILE *_sbuf;
        -:   17:  int _pos;
        -:   18:};
        -:   19:struct _IO_FILE {
        -:   20:  int _flags;
        -:   21:  char *_IO_read_ptr;
        -:   22:  char *_IO_read_end;
        -:   23:  char *_IO_read_base;
        -:   24:  char *_IO_write_base;
        -:   25:  char *_IO_write_ptr;
        -:   26:  char *_IO_write_end;
        -:   27:  char *_IO_buf_base;
        -:   28:  char *_IO_buf_end;
        -:   29:  char *_IO_save_base;
        -:   30:  char *_IO_backup_base;
        -:   31:  char *_IO_save_end;
        -:   32:  struct _IO_marker *_markers;
        -:   33:  struct _IO_FILE *_chain;
        -:   34:  int _fileno;
        -:   35:  int _flags2;
        -:   36:  __off_t _old_offset;
        -:   37:  unsigned short _cur_column;
        -:   38:  signed char _vtable_offset;
        -:   39:  char _shortbuf[1];
        -:   40:  _IO_lock_t *_lock;
        -:   41:  __off64_t _offset;
        -:   42:  void *__pad1;
        -:   43:  void *__pad2;
        -:   44:  void *__pad3;
        -:   45:  void *__pad4;
        -:   46:  size_t __pad5;
        -:   47:  int _mode;
        -:   48:  char _unused2[(15UL * sizeof(int) - 4UL * sizeof(void *)) - sizeof(size_t)];
        -:   49:};
        -:   50:typedef unsigned char char_type;
        -:   51:typedef long code_int;
        -:   52:typedef unsigned long cmp_code_int;
        -:   53:typedef struct _IO_FILE _IO_FILE;
        -:   54:struct huft;
        -:   55:union __anonunion_v_25 {
        -:   56:  ush n;
        -:   57:  struct huft *t;
        -:   58:};
        -:   59:struct huft {
        -:   60:  uch e;
        -:   61:  uch b;
        -:   62:  union __anonunion_v_25 v;
        -:   63:};
        -:   64:typedef int file_t;
        -:   65:union __anonunion_fc_7 {
        -:   66:  ush freq;
        -:   67:  ush code;
        -:   68:};
        -:   69:union __anonunion_dl_8 {
        -:   70:  ush dad;
        -:   71:  ush len;
        -:   72:};
        -:   73:struct ct_data {
        -:   74:  union __anonunion_fc_7 fc;
        -:   75:  union __anonunion_dl_8 dl;
        -:   76:};
        -:   77:typedef struct ct_data ct_data;
        -:   78:struct tree_desc {
        -:   79:  ct_data *dyn_tree;
        -:   80:  ct_data *static_tree;
        -:   81:  int *extra_bits;
        -:   82:  int extra_base;
        -:   83:  int elems;
        -:   84:  int max_length;
        -:   85:  int max_code;
        -:   86:};
        -:   87:typedef struct tree_desc tree_desc;
        -:   88:typedef ush Pos;
        -:   89:typedef unsigned int IPos;
        -:   90:struct config {
        -:   91:  ush good_length;
        -:   92:  ush max_lazy;
        -:   93:  ush nice_length;
        -:   94:  ush max_chain;
        -:   95:};
        -:   96:typedef struct config config;
        -:   97:typedef unsigned long __dev_t;
        -:   98:typedef unsigned int __uid_t;
        -:   99:typedef unsigned int __gid_t;
        -:  100:typedef unsigned long __ino_t;
        -:  101:typedef unsigned int __mode_t;
        -:  102:typedef unsigned long __nlink_t;
        -:  103:typedef long __time_t;
        -:  104:typedef long __blksize_t;
        -:  105:typedef long __blkcnt_t;
        -:  106:typedef long __syscall_slong_t;
        -:  107:typedef __off_t off_t;
        -:  108:typedef __time_t time_t;
        -:  109:struct timespec {
        -:  110:  __time_t tv_sec;
        -:  111:  __syscall_slong_t tv_nsec;
        -:  112:};
        -:  113:typedef void (*__sighandler_t)(int);
        -:  114:struct stat {
        -:  115:  __dev_t st_dev;
        -:  116:  __ino_t st_ino;
        -:  117:  __nlink_t st_nlink;
        -:  118:  __mode_t st_mode;
        -:  119:  __uid_t st_uid;
        -:  120:  __gid_t st_gid;
        -:  121:  int __pad0;
        -:  122:  __dev_t st_rdev;
        -:  123:  __off_t st_size;
        -:  124:  __blksize_t st_blksize;
        -:  125:  __blkcnt_t st_blocks;
        -:  126:  struct timespec st_atim;
        -:  127:  struct timespec st_mtim;
        -:  128:  struct timespec st_ctim;
        -:  129:  __syscall_slong_t __glibc_reserved[3];
        -:  130:};
        -:  131:struct option {
        -:  132:  char const *name;
        -:  133:  int has_arg;
        -:  134:  int *flag;
        -:  135:  int val;
        -:  136:};
        -:  137:struct dirent {
        -:  138:  __ino_t d_ino;
        -:  139:  __off_t d_off;
        -:  140:  unsigned short d_reclen;
        -:  141:  unsigned char d_type;
        -:  142:  char d_name[256];
        -:  143:};
        -:  144:struct __dirstream;
        -:  145:struct __dirstream;
        -:  146:typedef struct __dirstream DIR;
        -:  147:typedef struct dirent dir_type;
        -:  148:struct utimbuf {
        -:  149:  __time_t actime;
        -:  150:  __time_t modtime;
        -:  151:};
        -:  152:uch inbuf[32832];
        -:  153:uch outbuf[18432];
        -:  154:ush d_buf[32768];
        -:  155:uch window[65536L];
        -:  156:ush prev[1L << 16];
        -:  157:unsigned int insize;
        -:  158:unsigned int inptr;
        -:  159:int ifd;
        -:  160:int ofd;
        -:  161:int test;
        -:  162:int unlzh(int in, int out);
        -:  163:int fill_inbuf(int eof_ok);
        -:  164:void write_buf(int fd, voidp buf, unsigned int cnt);
        -:  165:void error(char *m);
        -:  166:static unsigned int decode(unsigned int count, uch *buffer);
        -:  167:static void decode_start(void);
        -:  168:static void huf_decode_start(void);
        -:  169:static unsigned int decode_c(void);
        -:  170:static unsigned int decode_p(void);
        -:  171:static void read_pt_len(int nn, int nbit, int i_special);
        -:  172:static void read_c_len(void);
        -:  173:static void fillbuf(int n);
        -:  174:static unsigned int getbits(int n);
        -:  175:static void init_getbits(void);
        -:  176:static void make_table(int nchar, uch *bitlen, int tablebits, ush *table);
        -:  177:static uch pt_len[19];
        -:  178:static unsigned int blocksize;
        -:  179:static ush pt_table[256];
        -:  180:static ush bitbuf;
        -:  181:static unsigned int subbitbuf;
        -:  182:static int bitcount;
    #####:  183:static void fillbuf(int n) {
        -:  184:  unsigned int tmp;
        -:  185:  int tmp___0;
        -:  186:  int tmp___1;
        -:  187:
        -:  188:  {
    #####:  189:    bitbuf = (ush)((int)bitbuf << n);
        -:  190:    {
        -:  191:      while (1) {
    #####:  192:      while_continue: /* CIL Label */;
    #####:  193:        if (!(n > bitcount)) {
    #####:  194:          goto while_break;
        -:  195:        }
    #####:  196:        n -= bitcount;
    #####:  197:        bitbuf = (ush)((unsigned int)bitbuf | (subbitbuf << n));
    #####:  198:        if (inptr < insize) {
    #####:  199:          tmp = inptr;
    #####:  200:          inptr++;
    #####:  201:          tmp___1 = (int)inbuf[tmp];
        -:  202:        } else {
        -:  203:          {
    #####:  204:            tmp___0 = fill_inbuf(1);
    #####:  205:            tmp___1 = tmp___0;
        -:  206:          }
        -:  207:        }
    #####:  208:        subbitbuf = (unsigned int)tmp___1;
    #####:  209:        if ((int)subbitbuf == -1) {
    #####:  210:          subbitbuf = 0U;
        -:  211:        }
    #####:  212:        bitcount = 8;
        -:  213:      }
    #####:  214:    while_break: /* CIL Label */;
        -:  215:    }
    #####:  216:    bitcount -= n;
    #####:  217:    bitbuf = (ush)((unsigned int)bitbuf | (subbitbuf >> bitcount));
    #####:  218:    return;
        -:  219:  }
        -:  220:}
    #####:  221:static unsigned int getbits(int n) {
        -:  222:  unsigned int x;
        -:  223:
        -:  224:  {
        -:  225:    {
    #####:  226:      x = (unsigned int)((int)bitbuf >>
    #####:  227:                         (16UL * sizeof(char) - (unsigned long)n));
    #####:  228:      fillbuf(n);
        -:  229:    }
    #####:  230:    return (x);
        -:  231:  }
        -:  232:}
    #####:  233:static void init_getbits(void) {
        -:  234:
        -:  235:  {
        -:  236:    {
    #####:  237:      bitbuf = (ush)0;
    #####:  238:      subbitbuf = 0U;
    #####:  239:      bitcount = 0;
    #####:  240:      fillbuf((int)(16UL * sizeof(char)));
        -:  241:    }
    #####:  242:    return;
        -:  243:  }
        -:  244:}
    #####:  245:static void make_table(int nchar, uch *bitlen, int tablebits, ush *table) {
        -:  246:  ush count[17];
        -:  247:  ush weight[17];
        -:  248:  ush start[18];
        -:  249:  ush *p;
        -:  250:  unsigned int i___0;
        -:  251:  unsigned int k;
        -:  252:  unsigned int len;
        -:  253:  unsigned int ch;
        -:  254:  unsigned int jutbits;
        -:  255:  unsigned int avail;
        -:  256:  unsigned int nextcode;
        -:  257:  unsigned int mask;
        -:  258:  unsigned int tmp;
        -:  259:  ush tmp___0;
        -:  260:  unsigned int tmp___1;
        -:  261:  void *__cil_tmp20;
        -:  262:  void *__cil_tmp21;
        -:  263:  void *__cil_tmp22;
        -:  264:  char *__cil_tmp23;
        -:  265:
        -:  266:  {
    #####:  267:    i___0 = 1U;
        -:  268:    {
        -:  269:      while (1) {
    #####:  270:      while_continue: /* CIL Label */;
    #####:  271:        if (!(i___0 <= 16U)) {
    #####:  272:          goto while_break;
        -:  273:        }
    #####:  274:        count[i___0] = (ush)0;
    #####:  275:        i___0++;
        -:  276:      }
    #####:  277:    while_break: /* CIL Label */;
        -:  278:    }
    #####:  279:    i___0 = 0U;
        -:  280:    {
        -:  281:      while (1) {
    #####:  282:      while_continue___0: /* CIL Label */;
    #####:  283:        if (!(i___0 < (unsigned int)nchar)) {
    #####:  284:          goto while_break___0;
        -:  285:        }
    #####:  286:        count[*(bitlen + i___0)] = (ush)((int)count[*(bitlen + i___0)] + 1);
    #####:  287:        i___0++;
        -:  288:      }
    #####:  289:    while_break___0: /* CIL Label */;
        -:  290:    }
    #####:  291:    start[1] = (ush)0;
    #####:  292:    i___0 = 1U;
        -:  293:    {
        -:  294:      while (1) {
    #####:  295:      while_continue___1: /* CIL Label */;
    #####:  296:        if (!(i___0 <= 16U)) {
    #####:  297:          goto while_break___1;
        -:  298:        }
    #####:  299:        start[i___0 + 1U] =
    #####:  300:            (ush)((int)start[i___0] + ((int)count[i___0] << (16U - i___0)));
    #####:  301:        i___0++;
        -:  302:      }
    #####:  303:    while_break___1: /* CIL Label */;
        -:  304:    }
    #####:  305:    if (((int)start[17] & 65535) != 0) {
        -:  306:      {
    #####:  307:        error((char *)"Bad table\n");
        -:  308:      }
        -:  309:    }
    #####:  310:    jutbits = (unsigned int)(16 - tablebits);
    #####:  311:    i___0 = 1U;
        -:  312:    {
        -:  313:      while (1) {
    #####:  314:      while_continue___2: /* CIL Label */;
    #####:  315:        if (!(i___0 <= (unsigned int)tablebits)) {
    #####:  316:          goto while_break___2;
        -:  317:        }
    #####:  318:        start[i___0] = (ush)((int)start[i___0] >> jutbits);
    #####:  319:        weight[i___0] = (ush)(1U << ((unsigned int)tablebits - i___0));
    #####:  320:        i___0++;
        -:  321:      }
    #####:  322:    while_break___2: /* CIL Label */;
        -:  323:    }
        -:  324:    {
        -:  325:      while (1) {
    #####:  326:      while_continue___3: /* CIL Label */;
    #####:  327:        if (!(i___0 <= 16U)) {
    #####:  328:          goto while_break___3;
        -:  329:        }
    #####:  330:        weight[i___0] = (ush)(1U << (16U - i___0));
    #####:  331:        i___0++;
        -:  332:      }
    #####:  333:    while_break___3: /* CIL Label */;
        -:  334:    }
    #####:  335:    i___0 = (unsigned int)((int)start[tablebits + 1] >> jutbits);
    #####:  336:    if (i___0 != 0U) {
    #####:  337:      k = (unsigned int)(1 << tablebits);
        -:  338:      {
        -:  339:        while (1) {
    #####:  340:        while_continue___4: /* CIL Label */;
    #####:  341:          if (!(i___0 != k)) {
    #####:  342:            goto while_break___4;
        -:  343:          }
    #####:  344:          tmp = i___0;
    #####:  345:          i___0++;
    #####:  346:          *(table + tmp) = (ush)0;
        -:  347:        }
    #####:  348:      while_break___4: /* CIL Label */;
        -:  349:      }
        -:  350:    }
    #####:  351:    avail = (unsigned int)nchar;
    #####:  352:    mask = 1U << (15 - tablebits);
    #####:  353:    ch = 0U;
        -:  354:    {
        -:  355:      while (1) {
    #####:  356:      while_continue___5: /* CIL Label */;
    #####:  357:        if (!(ch < (unsigned int)nchar)) {
    #####:  358:          goto while_break___5;
        -:  359:        }
    #####:  360:        len = (unsigned int)*(bitlen + ch);
    #####:  361:        if (len == 0U) {
    #####:  362:          goto __Cont;
        -:  363:        }
    #####:  364:        nextcode = (unsigned int)((int)start[len] + (int)weight[len]);
    #####:  365:        if (len <= (unsigned int)tablebits) {
    #####:  366:          i___0 = (unsigned int)start[len];
        -:  367:          {
        -:  368:            while (1) {
    #####:  369:            while_continue___6: /* CIL Label */;
    #####:  370:              if (!(i___0 < nextcode)) {
    #####:  371:                goto while_break___6;
        -:  372:              }
    #####:  373:              *(table + i___0) = (ush)ch;
    #####:  374:              i___0++;
        -:  375:            }
    #####:  376:          while_break___6: /* CIL Label */;
        -:  377:          }
        -:  378:        } else {
    #####:  379:          k = (unsigned int)start[len];
    #####:  380:          p = table + (k >> jutbits);
    #####:  381:          i___0 = len - (unsigned int)tablebits;
        -:  382:          {
        -:  383:            while (1) {
    #####:  384:            while_continue___7: /* CIL Label */;
    #####:  385:              if (!(i___0 != 0U)) {
    #####:  386:                goto while_break___7;
        -:  387:              }
    #####:  388:              if ((int)*p == 0) {
    #####:  389:                tmp___0 = (ush)0;
    #####:  390:                prev[avail] = tmp___0;
    #####:  391:                *((prev + 32768) + avail) = tmp___0;
    #####:  392:                tmp___1 = avail;
    #####:  393:                avail++;
    #####:  394:                *p = (ush)tmp___1;
        -:  395:              }
    #####:  396:              if (k & mask) {
    #####:  397:                p = (prev + 32768) + (int)*p;
        -:  398:              } else {
    #####:  399:                p = &prev[*p];
        -:  400:              }
    #####:  401:              k <<= 1;
    #####:  402:              i___0--;
        -:  403:            }
    #####:  404:          while_break___7: /* CIL Label */;
        -:  405:          }
    #####:  406:          *p = (ush)ch;
        -:  407:        }
    #####:  408:        start[len] = (ush)nextcode;
    #####:  409:      __Cont:
    #####:  410:        ch++;
        -:  411:      }
    #####:  412:    while_break___5: /* CIL Label */;
        -:  413:    }
    #####:  414:    return;
        -:  415:  }
        -:  416:}
    #####:  417:static void read_pt_len(int nn, int nbit, int i_special) {
        -:  418:  int i___0;
        -:  419:  int c;
        -:  420:  int n;
        -:  421:  unsigned int mask;
        -:  422:  int tmp;
        -:  423:  int tmp___0;
        -:  424:  int tmp___1;
        -:  425:  int tmp___2;
        -:  426:
        -:  427:  {
    #####:  428:    { n = (int)getbits(nbit); }
    #####:  429:    if (n == 0) {
        -:  430:      {
    #####:  431:        c = (int)getbits(nbit);
    #####:  432:        i___0 = 0;
        -:  433:      }
        -:  434:      {
        -:  435:        while (1) {
    #####:  436:        while_continue: /* CIL Label */;
    #####:  437:          if (!(i___0 < nn)) {
    #####:  438:            goto while_break;
        -:  439:          }
    #####:  440:          pt_len[i___0] = (uch)0;
    #####:  441:          i___0++;
        -:  442:        }
    #####:  443:      while_break: /* CIL Label */;
        -:  444:      }
    #####:  445:      i___0 = 0;
        -:  446:      {
        -:  447:        while (1) {
    #####:  448:        while_continue___0: /* CIL Label */;
    #####:  449:          if (!(i___0 < 256)) {
    #####:  450:            goto while_break___0;
        -:  451:          }
    #####:  452:          pt_table[i___0] = (ush)c;
    #####:  453:          i___0++;
        -:  454:        }
    #####:  455:      while_break___0: /* CIL Label */;
        -:  456:      }
        -:  457:    } else {
    #####:  458:      i___0 = 0;
        -:  459:      {
        -:  460:        while (1) {
    #####:  461:        while_continue___1: /* CIL Label */;
    #####:  462:          if (!(i___0 < n)) {
    #####:  463:            goto while_break___1;
        -:  464:          }
    #####:  465:          c = (int)bitbuf >> (16UL * sizeof(char) - 3UL);
    #####:  466:          if (c == 7) {
    #####:  467:            mask = 1U << ((16UL * sizeof(char) - 1UL) - 3UL);
        -:  468:            {
        -:  469:              while (1) {
    #####:  470:              while_continue___2: /* CIL Label */;
    #####:  471:                if (!(mask & (unsigned int)bitbuf)) {
    #####:  472:                  goto while_break___2;
        -:  473:                }
    #####:  474:                mask >>= 1;
    #####:  475:                c++;
        -:  476:              }
    #####:  477:            while_break___2: /* CIL Label */;
        -:  478:            }
        -:  479:          }
    #####:  480:          if (c < 7) {
    #####:  481:            tmp = 3;
        -:  482:          } else {
    #####:  483:            tmp = c - 3;
        -:  484:          }
        -:  485:          {
    #####:  486:            fillbuf(tmp);
    #####:  487:            tmp___0 = i___0;
    #####:  488:            i___0++;
    #####:  489:            pt_len[tmp___0] = (uch)c;
        -:  490:          }
    #####:  491:          if (i___0 == i_special) {
        -:  492:            {
    #####:  493:              c = (int)getbits(2);
        -:  494:            }
        -:  495:            {
        -:  496:              while (1) {
    #####:  497:              while_continue___3: /* CIL Label */;
    #####:  498:                c--;
    #####:  499:                if (!(c >= 0)) {
    #####:  500:                  goto while_break___3;
        -:  501:                }
    #####:  502:                tmp___1 = i___0;
    #####:  503:                i___0++;
    #####:  504:                pt_len[tmp___1] = (uch)0;
        -:  505:              }
    #####:  506:            while_break___3: /* CIL Label */;
        -:  507:            }
        -:  508:          }
        -:  509:        }
    #####:  510:      while_break___1: /* CIL Label */;
        -:  511:      }
        -:  512:      {
        -:  513:        while (1) {
    #####:  514:        while_continue___4: /* CIL Label */;
    #####:  515:          if (!(i___0 < nn)) {
    #####:  516:            goto while_break___4;
        -:  517:          }
    #####:  518:          tmp___2 = i___0;
    #####:  519:          i___0++;
    #####:  520:          pt_len[tmp___2] = (uch)0;
        -:  521:        }
    #####:  522:      while_break___4: /* CIL Label */;
        -:  523:      }
    #####:  524:      { make_table(nn, pt_len, 8, pt_table); }
        -:  525:    }
    #####:  526:    return;
        -:  527:  }
        -:  528:}
    #####:  529:static void read_c_len(void) {
        -:  530:  int i___0;
        -:  531:  int c;
        -:  532:  int n;
        -:  533:  unsigned int mask;
        -:  534:  unsigned int tmp;
        -:  535:  unsigned int tmp___0;
        -:  536:  int tmp___1;
        -:  537:  int tmp___2;
        -:  538:  int tmp___3;
        -:  539:
        -:  540:  {
    #####:  541:    { n = (int)getbits(9); }
    #####:  542:    if (n == 0) {
        -:  543:      {
    #####:  544:        c = (int)getbits(9);
    #####:  545:        i___0 = 0;
        -:  546:      }
        -:  547:      {
        -:  548:        while (1) {
    #####:  549:        while_continue: /* CIL Label */;
    #####:  550:          if (!(i___0 < 510)) {
    #####:  551:            goto while_break;
        -:  552:          }
    #####:  553:          outbuf[i___0] = (uch)0;
    #####:  554:          i___0++;
        -:  555:        }
    #####:  556:      while_break: /* CIL Label */;
        -:  557:      }
    #####:  558:      i___0 = 0;
        -:  559:      {
        -:  560:        while (1) {
    #####:  561:        while_continue___0: /* CIL Label */;
    #####:  562:          if (!(i___0 < 4096)) {
    #####:  563:            goto while_break___0;
        -:  564:          }
    #####:  565:          d_buf[i___0] = (ush)c;
    #####:  566:          i___0++;
        -:  567:        }
    #####:  568:      while_break___0: /* CIL Label */;
        -:  569:      }
        -:  570:    } else {
    #####:  571:      i___0 = 0;
        -:  572:      {
        -:  573:        while (1) {
    #####:  574:        while_continue___1: /* CIL Label */;
    #####:  575:          if (!(i___0 < n)) {
    #####:  576:            goto while_break___1;
        -:  577:          }
    #####:  578:          c = (int)pt_table[(int)bitbuf >> (16UL * sizeof(char) - 8UL)];
    #####:  579:          if (c >= 19) {
    #####:  580:            mask = 1U << ((16UL * sizeof(char) - 1UL) - 8UL);
        -:  581:            {
        -:  582:              while (1) {
    #####:  583:              while_continue___2: /* CIL Label */;
    #####:  584:                if ((unsigned int)bitbuf & mask) {
    #####:  585:                  c = (int)*((prev + 32768) + c);
        -:  586:                } else {
    #####:  587:                  c = (int)prev[c];
        -:  588:                }
    #####:  589:                mask >>= 1;
    #####:  590:                if (!(c >= 19)) {
    #####:  591:                  goto while_break___2;
        -:  592:                }
        -:  593:              }
    #####:  594:            while_break___2: /* CIL Label */;
        -:  595:            }
        -:  596:          }
    #####:  597:          { fillbuf((int)pt_len[c]); }
    #####:  598:          if (c <= 2) {
    #####:  599:            if (c == 0) {
    #####:  600:              c = 1;
        -:  601:            } else {
    #####:  602:              if (c == 1) {
        -:  603:                {
    #####:  604:                  tmp = getbits(4);
    #####:  605:                  c = (int)(tmp + 3U);
        -:  606:                }
        -:  607:              } else {
        -:  608:                {
    #####:  609:                  tmp___0 = getbits(9);
    #####:  610:                  c = (int)(tmp___0 + 20U);
        -:  611:                }
        -:  612:              }
        -:  613:            }
        -:  614:            {
        -:  615:              while (1) {
    #####:  616:              while_continue___3: /* CIL Label */;
    #####:  617:                c--;
    #####:  618:                if (!(c >= 0)) {
    #####:  619:                  goto while_break___3;
        -:  620:                }
    #####:  621:                tmp___1 = i___0;
    #####:  622:                i___0++;
    #####:  623:                outbuf[tmp___1] = (uch)0;
        -:  624:              }
    #####:  625:            while_break___3: /* CIL Label */;
        -:  626:            }
        -:  627:          } else {
    #####:  628:            tmp___2 = i___0;
    #####:  629:            i___0++;
    #####:  630:            outbuf[tmp___2] = (uch)(c - 2);
        -:  631:          }
        -:  632:        }
    #####:  633:      while_break___1: /* CIL Label */;
        -:  634:      }
        -:  635:      {
        -:  636:        while (1) {
    #####:  637:        while_continue___4: /* CIL Label */;
    #####:  638:          if (!(i___0 < 510)) {
    #####:  639:            goto while_break___4;
        -:  640:          }
    #####:  641:          tmp___3 = i___0;
    #####:  642:          i___0++;
    #####:  643:          outbuf[tmp___3] = (uch)0;
        -:  644:        }
    #####:  645:      while_break___4: /* CIL Label */;
        -:  646:      }
    #####:  647:      { make_table(510, outbuf, 12, d_buf); }
        -:  648:    }
    #####:  649:    return;
        -:  650:  }
        -:  651:}
    #####:  652:static unsigned int decode_c(void) {
        -:  653:  unsigned int j___0;
        -:  654:  unsigned int mask;
        -:  655:
        -:  656:  {
    #####:  657:    if (blocksize == 0U) {
        -:  658:      {
    #####:  659:        blocksize = getbits(16);
        -:  660:      }
    #####:  661:      if (blocksize == 0U) {
    #####:  662:        return (510U);
        -:  663:      }
        -:  664:      {
    #####:  665:        read_pt_len(19, 5, 3);
    #####:  666:        read_c_len();
    #####:  667:        read_pt_len(14, 4, -1);
        -:  668:      }
        -:  669:    }
    #####:  670:    blocksize--;
    #####:  671:    j___0 = (unsigned int)d_buf[(int)bitbuf >> (16UL * sizeof(char) - 12UL)];
    #####:  672:    if (j___0 >= 510U) {
    #####:  673:      mask = 1U << ((16UL * sizeof(char) - 1UL) - 12UL);
        -:  674:      {
        -:  675:        while (1) {
    #####:  676:        while_continue: /* CIL Label */;
    #####:  677:          if ((unsigned int)bitbuf & mask) {
    #####:  678:            j___0 = (unsigned int)*((prev + 32768) + j___0);
        -:  679:          } else {
    #####:  680:            j___0 = (unsigned int)prev[j___0];
        -:  681:          }
    #####:  682:          mask >>= 1;
    #####:  683:          if (!(j___0 >= 510U)) {
    #####:  684:            goto while_break;
        -:  685:          }
        -:  686:        }
    #####:  687:      while_break: /* CIL Label */;
        -:  688:      }
        -:  689:    }
    #####:  690:    { fillbuf((int)outbuf[j___0]); }
    #####:  691:    return (j___0);
        -:  692:  }
        -:  693:}
    #####:  694:static unsigned int decode_p(void) {
        -:  695:  unsigned int j___0;
        -:  696:  unsigned int mask;
        -:  697:  unsigned int tmp;
        -:  698:
        -:  699:  {
    #####:  700:    j___0 = (unsigned int)pt_table[(int)bitbuf >> (16UL * sizeof(char) - 8UL)];
    #####:  701:    if (j___0 >= 14U) {
    #####:  702:      mask = 1U << ((16UL * sizeof(char) - 1UL) - 8UL);
        -:  703:      {
        -:  704:        while (1) {
    #####:  705:        while_continue: /* CIL Label */;
    #####:  706:          if ((unsigned int)bitbuf & mask) {
    #####:  707:            j___0 = (unsigned int)*((prev + 32768) + j___0);
        -:  708:          } else {
    #####:  709:            j___0 = (unsigned int)prev[j___0];
        -:  710:          }
    #####:  711:          mask >>= 1;
    #####:  712:          if (!(j___0 >= 14U)) {
    #####:  713:            goto while_break;
        -:  714:          }
        -:  715:        }
    #####:  716:      while_break: /* CIL Label */;
        -:  717:      }
        -:  718:    }
    #####:  719:    { fillbuf((int)pt_len[j___0]); }
    #####:  720:    if (j___0 != 0U) {
        -:  721:      {
    #####:  722:        tmp = getbits((int)(j___0 - 1U));
    #####:  723:        j___0 = (1U << (j___0 - 1U)) + tmp;
        -:  724:      }
        -:  725:    }
    #####:  726:    return (j___0);
        -:  727:  }
        -:  728:}
    #####:  729:static void huf_decode_start(void) {
        -:  730:
        -:  731:  {
        -:  732:    {
    #####:  733:      init_getbits();
    #####:  734:      blocksize = 0U;
        -:  735:    }
    #####:  736:    return;
        -:  737:  }
        -:  738:}
        -:  739:static int j;
        -:  740:static int done;
    #####:  741:static void decode_start(void) {
        -:  742:
        -:  743:  {
        -:  744:    {
    #####:  745:      huf_decode_start();
    #####:  746:      j = 0;
    #####:  747:      done = 0;
        -:  748:    }
    #####:  749:    return;
        -:  750:  }
        -:  751:}
        -:  752:static unsigned int i;
    #####:  753:static unsigned int decode(unsigned int count, uch *buffer) {
        -:  754:  unsigned int r;
        -:  755:  unsigned int c;
        -:  756:  unsigned int tmp;
        -:  757:
        -:  758:  {
    #####:  759:    r = 0U;
        -:  760:    {
        -:  761:      while (1) {
    #####:  762:      while_continue: /* CIL Label */;
    #####:  763:        j--;
    #####:  764:        if (!(j >= 0)) {
    #####:  765:          goto while_break;
        -:  766:        }
    #####:  767:        *(buffer + r) = *(buffer + i);
    #####:  768:        i = (i + 1U) & ((1U << 13) - 1U);
    #####:  769:        r++;
    #####:  770:        if (r == count) {
    #####:  771:          return (r);
        -:  772:        }
        -:  773:      }
    #####:  774:    while_break: /* CIL Label */;
        -:  775:    }
        -:  776:    {
        -:  777:      while (1) {
    #####:  778:      while_continue___0: /* CIL Label */;
    #####:  779:        { c = decode_c(); }
    #####:  780:        if (c == 510U) {
    #####:  781:          done = 1;
    #####:  782:          return (r);
        -:  783:        }
    #####:  784:        if (c <= 255U) {
    #####:  785:          *(buffer + r) = (uch)c;
    #####:  786:          r++;
    #####:  787:          if (r == count) {
    #####:  788:            return (r);
        -:  789:          }
        -:  790:        } else {
        -:  791:          {
    #####:  792:            j = (int)(c - 253U);
    #####:  793:            tmp = decode_p();
    #####:  794:            i = ((r - tmp) - 1U) & ((1U << 13) - 1U);
        -:  795:          }
        -:  796:          {
        -:  797:            while (1) {
    #####:  798:            while_continue___1: /* CIL Label */;
    #####:  799:              j--;
    #####:  800:              if (!(j >= 0)) {
    #####:  801:                goto while_break___1;
        -:  802:              }
    #####:  803:              *(buffer + r) = *(buffer + i);
    #####:  804:              i = (i + 1U) & ((1U << 13) - 1U);
    #####:  805:              r++;
    #####:  806:              if (r == count) {
    #####:  807:                return (r);
        -:  808:              }
        -:  809:            }
    #####:  810:          while_break___1: /* CIL Label */;
        -:  811:          }
        -:  812:        }
        -:  813:      }
        -:  814:    while_break___0: /* CIL Label */;
        -:  815:    }
        -:  816:  }
        -:  817:}
    #####:  818:int unlzh(int in, int out) {
        -:  819:  unsigned int n;
        -:  820:
        -:  821:  {
        -:  822:    {
    #####:  823:      ifd = in;
    #####:  824:      ofd = out;
    #####:  825:      decode_start();
        -:  826:    }
        -:  827:    {
        -:  828:      while (1) {
    #####:  829:      while_continue: /* CIL Label */;
    #####:  830:        if (!(!done)) {
    #####:  831:          goto while_break;
        -:  832:        }
    #####:  833:        { n = decode(1U << 13, window); }
    #####:  834:        if (!test) {
    #####:  835:          if (n > 0U) {
        -:  836:            {
    #####:  837:              write_buf(out, (voidp)((char *)(window)), n);
        -:  838:            }
        -:  839:          }
        -:  840:        }
        -:  841:      }
    #####:  842:    while_break: /* CIL Label */;
        -:  843:    }
    #####:  844:    return (0);
        -:  845:  }
        -:  846:}
        -:  847:unsigned int outcnt;
        -:  848:long bytes_out;
        -:  849:int unpack(int in, int out);
        -:  850:void flush_window(void);
        -:  851:static ulg orig_len;
        -:  852:static int max_len;
        -:  853:static uch literal[256];
        -:  854:static int lit_base[26];
        -:  855:static int leaves[26];
        -:  856:static int parents[26];
        -:  857:static int peek_bits;
        -:  858:static ulg bitbuf___0;
        -:  859:static int valid;
        -:  860:static void read_tree(void);
        -:  861:static void build_tree(void);
    #####:  862:static void read_tree(void) {
        -:  863:  int len;
        -:  864:  int base;
        -:  865:  int n;
        -:  866:  unsigned int tmp;
        -:  867:  int tmp___0;
        -:  868:  int tmp___1;
        -:  869:  unsigned int tmp___2;
        -:  870:  int tmp___3;
        -:  871:  int tmp___4;
        -:  872:  unsigned int tmp___5;
        -:  873:  int tmp___6;
        -:  874:  int tmp___7;
        -:  875:  int tmp___8;
        -:  876:  unsigned int tmp___9;
        -:  877:  int tmp___10;
        -:  878:  int tmp___11;
        -:  879:  char *__cil_tmp17;
        -:  880:  char *__cil_tmp18;
        -:  881:
        -:  882:  {
    #####:  883:    orig_len = (ulg)0;
    #####:  884:    n = 1;
        -:  885:    {
        -:  886:      while (1) {
    #####:  887:      while_continue: /* CIL Label */;
    #####:  888:        if (!(n <= 4)) {
    #####:  889:          goto while_break;
        -:  890:        }
    #####:  891:        if (inptr < insize) {
    #####:  892:          tmp = inptr;
    #####:  893:          inptr++;
    #####:  894:          tmp___1 = (int)inbuf[tmp];
        -:  895:        } else {
        -:  896:          {
    #####:  897:            tmp___0 = fill_inbuf(0);
    #####:  898:            tmp___1 = tmp___0;
        -:  899:          }
        -:  900:        }
    #####:  901:        orig_len = (orig_len << 8) | (ulg)tmp___1;
    #####:  902:        n++;
        -:  903:      }
    #####:  904:    while_break: /* CIL Label */;
        -:  905:    }
    #####:  906:    if (inptr < insize) {
    #####:  907:      tmp___2 = inptr;
    #####:  908:      inptr++;
    #####:  909:      tmp___4 = (int)inbuf[tmp___2];
        -:  910:    } else {
        -:  911:      {
    #####:  912:        tmp___3 = fill_inbuf(0);
    #####:  913:        tmp___4 = tmp___3;
        -:  914:      }
        -:  915:    }
    #####:  916:    max_len = tmp___4;
    #####:  917:    if (max_len > 25) {
        -:  918:      {
    #####:  919:        error((char *)"invalid compressed data -- Huffman code > 32 bits");
        -:  920:      }
        -:  921:    }
    #####:  922:    n = 0;
    #####:  923:    len = 1;
        -:  924:    {
        -:  925:      while (1) {
    #####:  926:      while_continue___0: /* CIL Label */;
    #####:  927:        if (!(len <= max_len)) {
    #####:  928:          goto while_break___0;
        -:  929:        }
    #####:  930:        if (inptr < insize) {
    #####:  931:          tmp___5 = inptr;
    #####:  932:          inptr++;
    #####:  933:          tmp___7 = (int)inbuf[tmp___5];
        -:  934:        } else {
        -:  935:          {
    #####:  936:            tmp___6 = fill_inbuf(0);
    #####:  937:            tmp___7 = tmp___6;
        -:  938:          }
        -:  939:        }
    #####:  940:        leaves[len] = tmp___7;
    #####:  941:        n += leaves[len];
    #####:  942:        len++;
        -:  943:      }
    #####:  944:    while_break___0: /* CIL Label */;
        -:  945:    }
    #####:  946:    if (n > 256) {
        -:  947:      {
    #####:  948:        error((char *)"too many leaves in Huffman tree");
        -:  949:      }
        -:  950:    }
    #####:  951:    (leaves[max_len])++;
    #####:  952:    base = 0;
    #####:  953:    len = 1;
        -:  954:    {
        -:  955:      while (1) {
    #####:  956:      while_continue___1: /* CIL Label */;
    #####:  957:        if (!(len <= max_len)) {
    #####:  958:          goto while_break___1;
        -:  959:        }
    #####:  960:        lit_base[len] = base;
    #####:  961:        n = leaves[len];
        -:  962:        {
        -:  963:          while (1) {
    #####:  964:          while_continue___2: /* CIL Label */;
    #####:  965:            if (!(n > 0)) {
    #####:  966:              goto while_break___2;
        -:  967:            }
    #####:  968:            tmp___8 = base;
    #####:  969:            base++;
    #####:  970:            if (inptr < insize) {
    #####:  971:              tmp___9 = inptr;
    #####:  972:              inptr++;
    #####:  973:              tmp___11 = (int)inbuf[tmp___9];
        -:  974:            } else {
        -:  975:              {
    #####:  976:                tmp___10 = fill_inbuf(0);
    #####:  977:                tmp___11 = tmp___10;
        -:  978:              }
        -:  979:            }
    #####:  980:            literal[tmp___8] = (uch)tmp___11;
    #####:  981:            n--;
        -:  982:          }
    #####:  983:        while_break___2: /* CIL Label */;
        -:  984:        }
    #####:  985:        len++;
        -:  986:      }
    #####:  987:    while_break___1: /* CIL Label */;
        -:  988:    }
    #####:  989:    (leaves[max_len])++;
    #####:  990:    return;
        -:  991:  }
        -:  992:}
    #####:  993:static void build_tree(void) {
        -:  994:  int nodes;
        -:  995:  int len;
        -:  996:  uch *prefixp;
        -:  997:  int prefixes;
        -:  998:  int tmp;
        -:  999:
        -: 1000:  {
    #####: 1001:    nodes = 0;
    #####: 1002:    len = max_len;
        -: 1003:    {
        -: 1004:      while (1) {
    #####: 1005:      while_continue: /* CIL Label */;
    #####: 1006:        if (!(len >= 1)) {
    #####: 1007:          goto while_break;
        -: 1008:        }
    #####: 1009:        nodes >>= 1;
    #####: 1010:        parents[len] = nodes;
    #####: 1011:        lit_base[len] -= nodes;
    #####: 1012:        nodes += leaves[len];
    #####: 1013:        len--;
        -: 1014:      }
    #####: 1015:    while_break: /* CIL Label */;
        -: 1016:    }
    #####: 1017:    if (max_len <= 12) {
    #####: 1018:      peek_bits = max_len;
        -: 1019:    } else {
    #####: 1020:      peek_bits = 12;
        -: 1021:    }
    #####: 1022:    prefixp = &outbuf[1 << peek_bits];
    #####: 1023:    len = 1;
        -: 1024:    {
        -: 1025:      while (1) {
    #####: 1026:      while_continue___0: /* CIL Label */;
    #####: 1027:        if (!(len <= peek_bits)) {
    #####: 1028:          goto while_break___0;
        -: 1029:        }
    #####: 1030:        prefixes = leaves[len] << (peek_bits - len);
        -: 1031:        {
        -: 1032:          while (1) {
    #####: 1033:          while_continue___1: /* CIL Label */;
    #####: 1034:            tmp = prefixes;
    #####: 1035:            prefixes--;
    #####: 1036:            if (!tmp) {
    #####: 1037:              goto while_break___1;
        -: 1038:            }
    #####: 1039:            prefixp--;
    #####: 1040:            *prefixp = (uch)len;
        -: 1041:          }
    #####: 1042:        while_break___1: /* CIL Label */;
        -: 1043:        }
    #####: 1044:        len++;
        -: 1045:      }
    #####: 1046:    while_break___0: /* CIL Label */;
        -: 1047:    }
        -: 1048:    {
        -: 1049:      while (1) {
    #####: 1050:      while_continue___2: /* CIL Label */;
    #####: 1051:        if (!((unsigned long)prefixp > (unsigned long)(outbuf))) {
    #####: 1052:          goto while_break___2;
        -: 1053:        }
    #####: 1054:        prefixp--;
    #####: 1055:        *prefixp = (uch)0;
        -: 1056:      }
    #####: 1057:    while_break___2: /* CIL Label */;
        -: 1058:    }
    #####: 1059:    return;
        -: 1060:  }
        -: 1061:}
    #####: 1062:int unpack(int in, int out) {
        -: 1063:  int len;
        -: 1064:  unsigned int eob;
        -: 1065:  register unsigned int peek;
        -: 1066:  unsigned int peek_mask;
        -: 1067:  unsigned int tmp;
        -: 1068:  int tmp___0;
        -: 1069:  int tmp___1;
        -: 1070:  ulg mask;
        -: 1071:  unsigned int tmp___2;
        -: 1072:  int tmp___3;
        -: 1073:  int tmp___4;
        -: 1074:  unsigned int tmp___5;
        -: 1075:  char *__cil_tmp15;
        -: 1076:
        -: 1077:  {
        -: 1078:    {
    #####: 1079:      ifd = in;
    #####: 1080:      ofd = out;
    #####: 1081:      read_tree();
    #####: 1082:      build_tree();
    #####: 1083:      valid = 0;
    #####: 1084:      bitbuf___0 = (ulg)0;
    #####: 1085:      peek_mask = (unsigned int)((1 << peek_bits) - 1);
    #####: 1086:      eob = (unsigned int)(leaves[max_len] - 1);
        -: 1087:    }
        -: 1088:    {
        -: 1089:      while (1) {
    #####: 1090:      while_continue: /* CIL Label */;
        -: 1091:        {
        -: 1092:          while (1) {
    #####: 1093:          while_continue___0: /* CIL Label */;
    #####: 1094:            if (!(valid < peek_bits)) {
    #####: 1095:              goto while_break___0;
        -: 1096:            }
    #####: 1097:            if (inptr < insize) {
    #####: 1098:              tmp = inptr;
    #####: 1099:              inptr++;
    #####: 1100:              tmp___1 = (int)inbuf[tmp];
        -: 1101:            } else {
        -: 1102:              {
    #####: 1103:                tmp___0 = fill_inbuf(0);
    #####: 1104:                tmp___1 = tmp___0;
        -: 1105:              }
        -: 1106:            }
    #####: 1107:            bitbuf___0 = (bitbuf___0 << 8) | (ulg)tmp___1;
    #####: 1108:            valid += 8;
        -: 1109:          }
    #####: 1110:        while_break___0: /* CIL Label */;
        -: 1111:        }
    #####: 1112:        peek = (unsigned int)((bitbuf___0 >> (valid - peek_bits)) &
        -: 1113:                              (unsigned long)peek_mask);
    #####: 1114:        len = (int)outbuf[peek];
    #####: 1115:        if (len > 0) {
    #####: 1116:          peek >>= peek_bits - len;
        -: 1117:        } else {
    #####: 1118:          mask = (ulg)peek_mask;
    #####: 1119:          len = peek_bits;
        -: 1120:          {
        -: 1121:            while (1) {
    #####: 1122:            while_continue___1: /* CIL Label */;
    #####: 1123:              len++;
    #####: 1124:              mask = (mask << 1) + 1UL;
        -: 1125:              {
        -: 1126:                while (1) {
    #####: 1127:                while_continue___2: /* CIL Label */;
    #####: 1128:                  if (!(valid < len)) {
    #####: 1129:                    goto while_break___2;
        -: 1130:                  }
    #####: 1131:                  if (inptr < insize) {
    #####: 1132:                    tmp___2 = inptr;
    #####: 1133:                    inptr++;
    #####: 1134:                    tmp___4 = (int)inbuf[tmp___2];
        -: 1135:                  } else {
        -: 1136:                    {
    #####: 1137:                      tmp___3 = fill_inbuf(0);
    #####: 1138:                      tmp___4 = tmp___3;
        -: 1139:                    }
        -: 1140:                  }
    #####: 1141:                  bitbuf___0 = (bitbuf___0 << 8) | (ulg)tmp___4;
    #####: 1142:                  valid += 8;
        -: 1143:                }
    #####: 1144:              while_break___2: /* CIL Label */;
        -: 1145:              }
    #####: 1146:              peek = (unsigned int)((bitbuf___0 >> (valid - len)) & mask);
    #####: 1147:              if (!(peek < (unsigned int)parents[len])) {
    #####: 1148:                goto while_break___1;
        -: 1149:              }
        -: 1150:            }
    #####: 1151:          while_break___1: /* CIL Label */;
        -: 1152:          }
        -: 1153:        }
    #####: 1154:        if (peek == eob) {
    #####: 1155:          if (len == max_len) {
    #####: 1156:            goto while_break;
        -: 1157:          }
        -: 1158:        }
    #####: 1159:        tmp___5 = outcnt;
    #####: 1160:        outcnt++;
    #####: 1161:        window[tmp___5] = literal[peek + (unsigned int)lit_base[len]];
    #####: 1162:        if (outcnt == 32768U) {
        -: 1163:          {
    #####: 1164:            flush_window();
        -: 1165:          }
        -: 1166:        }
    #####: 1167:        valid -= len;
        -: 1168:      }
    #####: 1169:    while_break: /* CIL Label */;
        -: 1170:    }
    #####: 1171:    { flush_window(); }
    #####: 1172:    if (orig_len != (ulg)bytes_out) {
        -: 1173:      {
    #####: 1174:        error((char *)"invalid compressed data--length error");
        -: 1175:      }
        -: 1176:    }
    #####: 1177:    return (0);
        -: 1178:  }
        -: 1179:}
        -: 1180:extern ssize_t read(int __fd, void *__buf, size_t __nbytes);
        -: 1181:extern struct _IO_FILE *stderr;
        -: 1182:extern int fprintf(FILE *__restrict __stream, char const *__restrict __format,
        -: 1183:                   ...);
        -: 1184:extern __attribute__((__nothrow__)) void *(
        -: 1185:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 1186:    memcpy)(void *__restrict __dest, void const *__restrict __src, size_t __n);
        -: 1187:extern
        -: 1188:    __attribute__((__nothrow__)) void *(__attribute__((__nonnull__(1),
        -: 1189:                                                       __leaf__))
        -: 1190:                                        memset)(void *__s, int __c, size_t __n);
        -: 1191:long bytes_in;
        -: 1192:char ifname[1024];
        -: 1193:char *progname;
        -: 1194:int exit_code;
        -: 1195:int quiet;
        -: 1196:int to_stdout;
        -: 1197:void read_error(void);
        -: 1198:int maxbits;
        -: 1199:int block_mode;
        -: 1200:int unlzw(int in, int out);
        -: 1201:int block_mode = 128;
    #####: 1202:int unlzw(int in, int out) {
        -: 1203:  register char_type *stackp;
        -: 1204:  code_int code;
        -: 1205:  int finchar;
        -: 1206:  code_int oldcode;
        -: 1207:  code_int incode;
        -: 1208:  long inbits;
        -: 1209:  long posbits;
        -: 1210:  int outpos;
        -: 1211:  unsigned int bitmask;
        -: 1212:  code_int free_ent;
        -: 1213:  code_int maxcode;
        -: 1214:  code_int maxmaxcode;
        -: 1215:  int n_bits;
        -: 1216:  int rsize;
        -: 1217:  unsigned int tmp;
        -: 1218:  int tmp___0;
        -: 1219:  register int i___0;
        -: 1220:  int e;
        -: 1221:  int o;
        -: 1222:  register char_type *p;
        -: 1223:  int tmp___1;
        -: 1224:  char const *tmp___2;
        -: 1225:  register int i___1;
        -: 1226:  char *__cil_tmp27;
        -: 1227:  char *__cil_tmp28;
        -: 1228:  char *__cil_tmp29;
        -: 1229:
        -: 1230:  {
    #####: 1231:    if (inptr < insize) {
    #####: 1232:      tmp = inptr;
    #####: 1233:      inptr++;
    #####: 1234:      maxbits = (int)inbuf[tmp];
        -: 1235:    } else {
        -: 1236:      {
    #####: 1237:        tmp___0 = fill_inbuf(0);
    #####: 1238:        maxbits = tmp___0;
        -: 1239:      }
        -: 1240:    }
    #####: 1241:    block_mode = maxbits & 128;
    #####: 1242:    if ((maxbits & 96) != 0) {
    #####: 1243:      if (!quiet) {
        -: 1244:        {
    #####: 1245:          fprintf((FILE * /* __restrict  */) stderr,
        -: 1246:                  (char const * /* __restrict  */) "\n%s: %s: warning, unknown "
        -: 1247:                                                   "flags 0x%x\n",
        -: 1248:                  progname, ifname, maxbits & 96);
        -: 1249:        }
        -: 1250:      }
    #####: 1251:      if (exit_code == 0) {
    #####: 1252:        exit_code = 2;
        -: 1253:      }
        -: 1254:    }
    #####: 1255:    maxbits &= 31;
    #####: 1256:    maxmaxcode = 1L << maxbits;
    #####: 1257:    if (maxbits > 16) {
        -: 1258:      {
    #####: 1259:        fprintf(
        -: 1260:            (FILE * /* __restrict  */) stderr,
        -: 1261:            (char const * /* __restrict  */) "\n%s: %s: compressed with %d "
        -: 1262:                                             "bits, can only handle %d bits\n",
        -: 1263:            progname, ifname, maxbits, 16);
    #####: 1264:        exit_code = 1;
        -: 1265:      }
    #####: 1266:      return (1);
        -: 1267:    }
    #####: 1268:    rsize = (int)insize;
    #####: 1269:    n_bits = 9;
    #####: 1270:    maxcode = (1L << n_bits) - 1L;
    #####: 1271:    bitmask = (unsigned int)((1 << n_bits) - 1);
    #####: 1272:    oldcode = (code_int)-1;
    #####: 1273:    finchar = 0;
    #####: 1274:    outpos = 0;
    #####: 1275:    posbits = (long)(inptr << 3);
    #####: 1276:    if (block_mode) {
    #####: 1277:      free_ent = (code_int)257;
        -: 1278:    } else {
    #####: 1279:      free_ent = (code_int)256;
        -: 1280:    }
        -: 1281:    {
    #####: 1282:      memset((voidp)(prev), 0, (size_t)256);
    #####: 1283:      code = (code_int)255;
        -: 1284:    }
        -: 1285:    {
        -: 1286:      while (1) {
    #####: 1287:      while_continue: /* CIL Label */;
    #####: 1288:        if (!(code >= 0L)) {
    #####: 1289:          goto while_break;
        -: 1290:        }
    #####: 1291:        window[code] = (char_type)code;
    #####: 1292:        code--;
        -: 1293:      }
    #####: 1294:    while_break: /* CIL Label */;
        -: 1295:    }
        -: 1296:    {
        -: 1297:      while (1) {
    #####: 1298:      while_continue___0: /* CIL Label */;
    #####: 1299:      resetbuf:
    #####: 1300:        o = (int)(posbits >> 3);
    #####: 1301:        e = (int)(insize - (unsigned int)o);
    #####: 1302:        i___0 = 0;
        -: 1303:        {
        -: 1304:          while (1) {
    #####: 1305:          while_continue___1: /* CIL Label */;
    #####: 1306:            if (!(i___0 < e)) {
    #####: 1307:              goto while_break___1;
        -: 1308:            }
    #####: 1309:            inbuf[i___0] = inbuf[i___0 + o];
    #####: 1310:            i___0++;
        -: 1311:          }
    #####: 1312:        while_break___1: /* CIL Label */;
        -: 1313:        }
    #####: 1314:        insize = (unsigned int)e;
    #####: 1315:        posbits = 0L;
    #####: 1316:        if (insize < 64U) {
        -: 1317:          {
    #####: 1318:            rsize = (int)read(in, (void *)((char *)(inbuf) + insize),
        -: 1319:                              (size_t)32768);
        -: 1320:          }
    #####: 1321:          if (rsize == -1) {
        -: 1322:            {
    #####: 1323:              read_error();
        -: 1324:            }
        -: 1325:          }
    #####: 1326:          insize += (unsigned int)rsize;
    #####: 1327:          bytes_in = (long)((ulg)bytes_in + (ulg)rsize);
        -: 1328:        }
    #####: 1329:        if (rsize != 0) {
    #####: 1330:          inbits = ((long)insize - (long)(insize % (unsigned int)n_bits)) << 3;
        -: 1331:        } else {
    #####: 1332:          inbits = ((long)insize << 3) - (long)(n_bits - 1);
        -: 1333:        }
        -: 1334:        {
        -: 1335:          while (1) {
    #####: 1336:          while_continue___2: /* CIL Label */;
    #####: 1337:            if (!(inbits > posbits)) {
    #####: 1338:              goto while_break___2;
        -: 1339:            }
    #####: 1340:            if (free_ent > maxcode) {
    #####: 1341:              posbits =
    #####: 1342:                  (posbits - 1L) + ((long)(n_bits << 3) -
    #####: 1343:                                    ((posbits - 1L) + (long)(n_bits << 3)) %
    #####: 1344:                                        (long)(n_bits << 3));
    #####: 1345:              n_bits++;
    #####: 1346:              if (n_bits == maxbits) {
    #####: 1347:                maxcode = maxmaxcode;
        -: 1348:              } else {
    #####: 1349:                maxcode = (1L << n_bits) - 1L;
        -: 1350:              }
    #####: 1351:              bitmask = (unsigned int)((1 << n_bits) - 1);
    #####: 1352:              goto resetbuf;
        -: 1353:            }
    #####: 1354:            p = &inbuf[posbits >> 3];
    #####: 1355:            code = ((((long)*(p + 0) | ((long)*(p + 1) << 8)) |
    #####: 1356:                     ((long)*(p + 2) << 16)) >>
    #####: 1357:                    (posbits & 7L)) &
    #####: 1358:                   (long)bitmask;
    #####: 1359:            posbits += (long)n_bits;
    #####: 1360:            if (oldcode == -1L) {
    #####: 1361:              if (code >= 256L) {
        -: 1362:                {
    #####: 1363:                  error((char *)"corrupt input.");
        -: 1364:                }
        -: 1365:              }
    #####: 1366:              tmp___1 = outpos;
    #####: 1367:              outpos++;
    #####: 1368:              oldcode = code;
    #####: 1369:              finchar = (int)oldcode;
    #####: 1370:              outbuf[tmp___1] = (char_type)finchar;
    #####: 1371:              goto while_continue___2;
        -: 1372:            }
    #####: 1373:            if (code == 256L) {
    #####: 1374:              if (block_mode) {
        -: 1375:                {
    #####: 1376:                  memset((voidp)(prev), 0, (size_t)256);
    #####: 1377:                  free_ent = (code_int)256;
    #####: 1378:                  posbits =
    #####: 1379:                      (posbits - 1L) + ((long)(n_bits << 3) -
    #####: 1380:                                        ((posbits - 1L) + (long)(n_bits << 3)) %
    #####: 1381:                                            (long)(n_bits << 3));
    #####: 1382:                  n_bits = 9;
    #####: 1383:                  maxcode = (1L << n_bits) - 1L;
    #####: 1384:                  bitmask = (unsigned int)((1 << n_bits) - 1);
        -: 1385:                }
    #####: 1386:                goto resetbuf;
        -: 1387:              }
        -: 1388:            }
    #####: 1389:            incode = code;
    #####: 1390:            stackp = (char_type *)(&d_buf[32767]);
    #####: 1391:            if (code >= free_ent) {
    #####: 1392:              if (code > free_ent) {
    #####: 1393:                if (!test) {
    #####: 1394:                  if (outpos > 0) {
        -: 1395:                    {
    #####: 1396:                      write_buf(out, (voidp)((char *)(outbuf)),
        -: 1397:                                (unsigned int)outpos);
    #####: 1398:                      bytes_out = (long)((ulg)bytes_out + (ulg)outpos);
        -: 1399:                    }
        -: 1400:                  }
        -: 1401:                }
    #####: 1402:                if (to_stdout) {
    #####: 1403:                  tmp___2 = "corrupt input.";
        -: 1404:                } else {
    #####: 1405:                  tmp___2 = "corrupt input. Use zcat to recover some data.";
        -: 1406:                }
    #####: 1407:                { error((char *)tmp___2); }
        -: 1408:              }
    #####: 1409:              stackp--;
    #####: 1410:              *stackp = (char_type)finchar;
    #####: 1411:              code = oldcode;
        -: 1412:            }
        -: 1413:            {
        -: 1414:              while (1) {
    #####: 1415:              while_continue___3: /* CIL Label */;
    #####: 1416:                if (!((cmp_code_int)code >= 256UL)) {
    #####: 1417:                  goto while_break___3;
        -: 1418:                }
    #####: 1419:                stackp--;
    #####: 1420:                *stackp = window[code];
    #####: 1421:                code = (code_int)prev[code];
        -: 1422:              }
    #####: 1423:            while_break___3: /* CIL Label */;
        -: 1424:            }
    #####: 1425:            stackp--;
    #####: 1426:            finchar = (int)window[code];
    #####: 1427:            *stackp = (char_type)finchar;
    #####: 1428:            i___1 = (int)((char_type *)(&d_buf[32767]) - stackp);
    #####: 1429:            if (outpos + i___1 >= 16384) {
        -: 1430:              {
        -: 1431:                while (1) {
    #####: 1432:                while_continue___4: /* CIL Label */;
    #####: 1433:                  if (i___1 > 16384 - outpos) {
    #####: 1434:                    i___1 = 16384 - outpos;
        -: 1435:                  }
    #####: 1436:                  if (i___1 > 0) {
        -: 1437:                    {
    #####: 1438:                      memcpy((void * /* __restrict  */)(outbuf + outpos),
        -: 1439:                             (void const * /* __restrict  */)stackp,
        -: 1440:                             (size_t)i___1);
    #####: 1441:                      outpos += i___1;
        -: 1442:                    }
        -: 1443:                  }
    #####: 1444:                  if (outpos >= 16384) {
    #####: 1445:                    if (!test) {
        -: 1446:                      {
    #####: 1447:                        write_buf(out, (voidp)((char *)(outbuf)),
        -: 1448:                                  (unsigned int)outpos);
    #####: 1449:                        bytes_out = (long)((ulg)bytes_out + (ulg)outpos);
        -: 1450:                      }
        -: 1451:                    }
    #####: 1452:                    outpos = 0;
        -: 1453:                  }
    #####: 1454:                  stackp += i___1;
    #####: 1455:                  i___1 = (int)((char_type *)(&d_buf[32767]) - stackp);
    #####: 1456:                  if (!(i___1 > 0)) {
    #####: 1457:                    goto while_break___4;
        -: 1458:                  }
        -: 1459:                }
    #####: 1460:              while_break___4: /* CIL Label */;
        -: 1461:              }
        -: 1462:            } else {
        -: 1463:              {
    #####: 1464:                memcpy((void * /* __restrict  */)(outbuf + outpos),
        -: 1465:                       (void const * /* __restrict  */)stackp, (size_t)i___1);
    #####: 1466:                outpos += i___1;
        -: 1467:              }
        -: 1468:            }
    #####: 1469:            code = free_ent;
    #####: 1470:            if (code < maxmaxcode) {
    #####: 1471:              prev[code] = (unsigned short)oldcode;
    #####: 1472:              window[code] = (char_type)finchar;
    #####: 1473:              free_ent = code + 1L;
        -: 1474:            }
    #####: 1475:            oldcode = incode;
        -: 1476:          }
    #####: 1477:        while_break___2: /* CIL Label */;
        -: 1478:        }
    #####: 1479:        if (!(rsize != 0)) {
    #####: 1480:          goto while_break___0;
        -: 1481:        }
        -: 1482:      }
    #####: 1483:    while_break___0: /* CIL Label */;
        -: 1484:    }
    #####: 1485:    if (!test) {
    #####: 1486:      if (outpos > 0) {
        -: 1487:        {
    #####: 1488:          write_buf(out, (voidp)((char *)(outbuf)), (unsigned int)outpos);
    #####: 1489:          bytes_out = (long)((ulg)bytes_out + (ulg)outpos);
        -: 1490:        }
        -: 1491:      }
        -: 1492:    }
    #####: 1493:    return (0);
        -: 1494:  }
        -: 1495:}
        -: 1496:int lzw(int in, int out);
        -: 1497:static int msg_done = 0;
    #####: 1498:int lzw(int in, int out) {
        -: 1499:
        -: 1500:  {
    #####: 1501:    if (msg_done) {
    #####: 1502:      return (1);
        -: 1503:    }
        -: 1504:    {
    #####: 1505:      msg_done = 1;
    #####: 1506:      fprintf((FILE * /* __restrict  */) stderr,
        -: 1507:              (char const * /* __restrict  */) "output in compress .Z format "
        -: 1508:                                               "not supported\n");
        -: 1509:    }
    #####: 1510:    if (in != out) {
    #####: 1511:      exit_code = 1;
        -: 1512:    }
    #####: 1513:    return (1);
        -: 1514:  }
        -: 1515:}
        -: 1516:extern __attribute__((__nothrow__)) unsigned short const **(
        -: 1517:    __attribute__((__leaf__)) __ctype_b_loc)(void)__attribute__((__const__));
        -: 1518:extern __attribute__((__nothrow__)) int *(
        -: 1519:    __attribute__((__leaf__)) __errno_location)(void)__attribute__((__const__));
        -: 1520:extern ssize_t write(int __fd, void const *__buf, size_t __n);
        -: 1521:extern __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
        -: 1522:                                           malloc)(size_t __size)
        -: 1523:    __attribute__((__malloc__));
        -: 1524:extern
        -: 1525:    __attribute__((__nothrow__)) void *(__attribute__((__leaf__))
        -: 1526:                                        calloc)(size_t __nmemb, size_t __size)
        -: 1527:        __attribute__((__malloc__));
        -: 1528:extern __attribute__((__nothrow__)) void(__attribute__((__leaf__))
        -: 1529:                                         free)(void *__ptr);
        -: 1530:extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
        -: 1531:                                                          __leaf__))
        -: 1532:                                           getenv)(char const *__name);
        -: 1533:extern int _IO_putc(int __c, _IO_FILE *__fp);
        -: 1534:extern void perror(char const *__s);
        -: 1535:extern __attribute__((__nothrow__)) char *(
        -: 1536:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 1537:    strcpy)(char *__restrict __dest, char const *__restrict __src);
        -: 1538:extern __attribute__((__nothrow__)) char *(__attribute__((__nonnull__(1),
        -: 1539:                                                          __leaf__))
        -: 1540:                                           strrchr)(char const *__s, int __c)
        -: 1541:    __attribute__((__pure__));
        -: 1542:extern __attribute__((__nothrow__))
        -: 1543:size_t(__attribute__((__nonnull__(1, 2), __leaf__))
        -: 1544:       strcspn)(char const *__s, char const *__reject)
        -: 1545:    __attribute__((__pure__));
        -: 1546:extern __attribute__((__nothrow__))
        -: 1547:size_t(__attribute__((__nonnull__(1, 2), __leaf__))
        -: 1548:       strspn)(char const *__s, char const *__accept) __attribute__((__pure__));
        -: 1549:extern __attribute__((__nothrow__))
        -: 1550:size_t(__attribute__((__nonnull__(1), __leaf__)) strlen)(char const *__s)
        -: 1551:    __attribute__((__pure__));
        -: 1552:char ofname[1024];
        -: 1553:void abort_gzip(void);
        -: 1554:int copy(int in, int out);
        -: 1555:ulg updcrc(uch *s, unsigned int n);
        -: 1556:void clear_bufs(void);
        -: 1557:void flush_outbuf(void);
        -: 1558:char *strlwr(char *s);
        -: 1559:char *basename(char *fname);
        -: 1560:char *add_envopt(int *argcp, char ***argvp, char *env___0);
        -: 1561:void write_error(void);
        -: 1562:void display_ratio(long num, long den, FILE *file);
        -: 1563:voidp xmalloc(unsigned int size);
        -: 1564:ulg crc_32_tab[256];
    #####: 1565:int copy(int in, int out) {
        -: 1566:  int *tmp;
        -: 1567:  int *tmp___0;
        -: 1568:
        -: 1569:  {
        -: 1570:    {
    #####: 1571:      tmp = __errno_location();
    #####: 1572:      *tmp = 0;
        -: 1573:    }
        -: 1574:    {
        -: 1575:      while (1) {
    #####: 1576:      while_continue: /* CIL Label */;
    #####: 1577:        if (insize != 0U) {
    #####: 1578:          if (!((int)insize != -1)) {
    #####: 1579:            goto while_break;
        -: 1580:          }
        -: 1581:        } else {
    #####: 1582:          goto while_break;
        -: 1583:        }
        -: 1584:        {
    #####: 1585:          write_buf(out, (voidp)((char *)(inbuf)), insize);
    #####: 1586:          bytes_out += (long)insize;
    #####: 1587:          insize =
    #####: 1588:              (unsigned int)read(in, (void *)((char *)(inbuf)), (size_t)32768);
        -: 1589:        }
        -: 1590:      }
    #####: 1591:    while_break: /* CIL Label */;
        -: 1592:    }
    #####: 1593:    if ((int)insize == -1) {
        -: 1594:      {
    #####: 1595:        tmp___0 = __errno_location();
        -: 1596:      }
    #####: 1597:      if (*tmp___0 != 0) {
        -: 1598:        {
    #####: 1599:          read_error();
        -: 1600:        }
        -: 1601:      }
        -: 1602:    }
    #####: 1603:    bytes_in = bytes_out;
    #####: 1604:    return (0);
        -: 1605:  }
        -: 1606:}
        -: 1607:static ulg crc = (ulg)4294967295L;
    #####: 1608:ulg updcrc(uch *s, unsigned int n) {
        -: 1609:  register ulg c;
        -: 1610:  uch *tmp;
        -: 1611:
        -: 1612:  {
    #####: 1613:    if ((unsigned long)s == (unsigned long)((void *)0)) {
    #####: 1614:      c = (ulg)4294967295L;
        -: 1615:    } else {
    #####: 1616:      c = crc;
    #####: 1617:      if (n) {
        -: 1618:        {
        -: 1619:          while (1) {
    #####: 1620:          while_continue: /* CIL Label */;
    #####: 1621:            tmp = s;
    #####: 1622:            s++;
    #####: 1623:            c = crc_32_tab[((int)c ^ (int)*tmp) & 255] ^ (c >> 8);
    #####: 1624:            n--;
    #####: 1625:            if (!n) {
    #####: 1626:              goto while_break;
        -: 1627:            }
        -: 1628:          }
    #####: 1629:        while_break: /* CIL Label */;
        -: 1630:        }
        -: 1631:      }
        -: 1632:    }
    #####: 1633:    crc = c;
    #####: 1634:    return (c ^ 4294967295UL);
        -: 1635:  }
        -: 1636:}
    #####: 1637:void clear_bufs(void) {
        -: 1638:
        -: 1639:  {
    #####: 1640:    outcnt = 0U;
    #####: 1641:    inptr = 0U;
    #####: 1642:    insize = inptr;
    #####: 1643:    bytes_out = 0L;
    #####: 1644:    bytes_in = bytes_out;
    #####: 1645:    return;
        -: 1646:  }
        -: 1647:}
    #####: 1648:int fill_inbuf(int eof_ok) {
        -: 1649:  int len;
        -: 1650:  int *tmp;
        -: 1651:
        -: 1652:  {
        -: 1653:    {
    #####: 1654:      insize = 0U;
    #####: 1655:      tmp = __errno_location();
    #####: 1656:      *tmp = 0;
        -: 1657:    }
        -: 1658:    {
        -: 1659:      while (1) {
    #####: 1660:      while_continue: /* CIL Label */;
        -: 1661:        {
    #####: 1662:          len = (int)read(ifd, (void *)((char *)(inbuf) + insize),
    #####: 1663:                          (size_t)(32768U - insize));
        -: 1664:        }
    #####: 1665:        if (len == 0) {
    #####: 1666:          goto while_break;
        -: 1667:        } else {
    #####: 1668:          if (len == -1) {
    #####: 1669:            goto while_break;
        -: 1670:          }
        -: 1671:        }
    #####: 1672:        insize += (unsigned int)len;
    #####: 1673:        if (!(insize < 32768U)) {
    #####: 1674:          goto while_break;
        -: 1675:        }
        -: 1676:      }
    #####: 1677:    while_break: /* CIL Label */;
        -: 1678:    }
    #####: 1679:    if (insize == 0U) {
    #####: 1680:      if (eof_ok) {
    #####: 1681:        return (-1);
        -: 1682:      }
    #####: 1683:      { read_error(); }
        -: 1684:    }
    #####: 1685:    bytes_in = (long)((ulg)bytes_in + (ulg)insize);
    #####: 1686:    inptr = 1U;
    #####: 1687:    return ((int)inbuf[0]);
        -: 1688:  }
        -: 1689:}
    #####: 1690:void flush_outbuf(void) {
        -: 1691:
        -: 1692:  {
    #####: 1693:    if (outcnt == 0U) {
    #####: 1694:      return;
        -: 1695:    }
        -: 1696:    {
    #####: 1697:      write_buf(ofd, (voidp)((char *)(outbuf)), outcnt);
    #####: 1698:      bytes_out = (long)((ulg)bytes_out + (ulg)outcnt);
    #####: 1699:      outcnt = 0U;
        -: 1700:    }
    #####: 1701:    return;
        -: 1702:  }
        -: 1703:}
    #####: 1704:void flush_window(void) {
        -: 1705:
        -: 1706:  {
    #####: 1707:    if (outcnt == 0U) {
    #####: 1708:      return;
        -: 1709:    }
    #####: 1710:    { updcrc(window, outcnt); }
    #####: 1711:    if (!test) {
        -: 1712:      {
    #####: 1713:        write_buf(ofd, (voidp)((char *)(window)), outcnt);
        -: 1714:      }
        -: 1715:    }
    #####: 1716:    bytes_out = (long)((ulg)bytes_out + (ulg)outcnt);
    #####: 1717:    outcnt = 0U;
    #####: 1718:    return;
        -: 1719:  }
        -: 1720:}
    #####: 1721:void write_buf(int fd, voidp buf, unsigned int cnt) {
        -: 1722:  unsigned int n;
        -: 1723:
        -: 1724:  {
        -: 1725:    {
        -: 1726:      while (1) {
    #####: 1727:      while_continue: /* CIL Label */;
    #####: 1728:        { n = (unsigned int)write(fd, (void const *)buf, (size_t)cnt); }
    #####: 1729:        if (!(n != cnt)) {
    #####: 1730:          goto while_break;
        -: 1731:        }
    #####: 1732:        if (n == 4294967295U) {
        -: 1733:          {
    #####: 1734:            write_error();
        -: 1735:          }
        -: 1736:        }
    #####: 1737:        cnt -= n;
    #####: 1738:        buf = (voidp)((char *)buf + n);
        -: 1739:      }
    #####: 1740:    while_break: /* CIL Label */;
        -: 1741:    }
    #####: 1742:    return;
        -: 1743:  }
        -: 1744:}
    #####: 1745:char *strlwr(char *s) {
        -: 1746:  char *t;
        -: 1747:  unsigned short const **tmp___0;
        -: 1748:
        -: 1749:  {
    #####: 1750:    t = s;
        -: 1751:    {
        -: 1752:      while (1) {
    #####: 1753:      while_continue: /* CIL Label */;
    #####: 1754:        if (!*t) {
    #####: 1755:          goto while_break;
        -: 1756:        }
    #####: 1757:        { tmp___0 = __ctype_b_loc(); }
    #####: 1758:        if ((int const) * (*tmp___0 + (int)*t) & 256) {
    #####: 1759:          *t = (char)(((int)*t - 65) + 97);
        -: 1760:        } else {
    #####: 1761:          *t = *t;
        -: 1762:        }
    #####: 1763:        t++;
        -: 1764:      }
    #####: 1765:    while_break: /* CIL Label */;
        -: 1766:    }
    #####: 1767:    return (s);
        -: 1768:  }
        -: 1769:}
        -: 1771:  char *p;
        -: 1772:
        -: 1773:  {
        -: 1777:    }
        -: 1779:  }
        -: 1780:}
        -: 1782:  char *p;
        -: 1783:  char **oargv;
        -: 1784:  char **nargv;
        -: 1785:  int oargc;
        -: 1786:  int nargc;
        -: 1787:  char *tmp;
        -: 1788:  size_t tmp___0;
        -: 1789:  size_t tmp___2;
        -: 1790:  size_t tmp___3;
        -: 1791:  char *tmp___4;
        -: 1792:  int tmp___6;
        -: 1793:  char **tmp___7;
        -: 1794:  char **tmp___8;
        -: 1795:  size_t tmp___9;
        -: 1796:  char **tmp___10;
        -: 1797:  char *tmp___11;
        -: 1798:  char **tmp___12;
        -: 1799:  char **tmp___13;
        -: 1800:  int tmp___14;
        -: 1801:  char *__cil_tmp25;
        -: 1802:  char *__cil_tmp26;
        -: 1803:
        -: 1804:  {
        -: 1805:    {
        -: 1810:    }
        -: 1813:    }
        -: 1814:    {
    #####: 1815:      tmp___0 = strlen((char const *)env___0);
    #####: 1816:      p = (char *)xmalloc((unsigned int)(tmp___0 + 1UL));
    #####: 1817:      env___0 = strcpy((char * /* __restrict  */)p,
        -: 1818:                       (char const * /* __restrict  */)env___0);
    #####: 1819:      p = env___0;
        -: 1820:    }
        -: 1821:    {
        -: 1822:      while (1) {
    #####: 1823:      while_continue: /* CIL Label */;
    #####: 1824:        if (!*p) {
    #####: 1825:          goto while_break;
        -: 1826:        }
        -: 1827:        {
    #####: 1828:          tmp___2 = strspn((char const *)p, " \t");
    #####: 1829:          p += tmp___2;
        -: 1830:        }
    #####: 1831:        if ((int)*p == 0) {
    #####: 1832:          goto while_break;
        -: 1833:        }
        -: 1834:        {
    #####: 1835:          tmp___3 = strcspn((char const *)p, " \t");
    #####: 1836:          p += tmp___3;
        -: 1837:        }
    #####: 1838:        if (*p) {
    #####: 1839:          tmp___4 = p;
    #####: 1840:          p++;
    #####: 1841:          *tmp___4 = (char)'\000';
        -: 1842:        }
    #####: 1843:        nargc++;
        -: 1844:      }
    #####: 1845:    while_break: /* CIL Label */;
        -: 1846:    }
    #####: 1847:    if (nargc == 0) {
        -: 1848:      {
    #####: 1849:        free((void *)env___0);
        -: 1850:      }
    #####: 1851:      return ((char *)((void *)0));
        -: 1852:    }
        -: 1853:    {
    #####: 1854:      *argcp += nargc;
    #####: 1855:      nargv = (char **)calloc((size_t)(*argcp + 1), sizeof(char *));
        -: 1856:    }
    #####: 1857:    if ((unsigned long)nargv == (unsigned long)((void *)0)) {
        -: 1858:      {
    #####: 1859:        error((char *)"out of memory");
        -: 1860:      }
        -: 1861:    }
    #####: 1862:    oargv = *argvp;
    #####: 1863:    *argvp = nargv;
    #####: 1864:    tmp___6 = oargc;
    #####: 1865:    oargc--;
    #####: 1866:    if (tmp___6 < 0) {
        -: 1867:      {
    #####: 1868:        error((char *)"argc<=0");
        -: 1869:      }
        -: 1870:    }
    #####: 1871:    tmp___7 = nargv;
    #####: 1872:    nargv++;
    #####: 1873:    tmp___8 = oargv;
    #####: 1874:    oargv++;
    #####: 1875:    *tmp___7 = *tmp___8;
    #####: 1876:    p = env___0;
        -: 1877:    {
        -: 1878:      while (1) {
    #####: 1879:      while_continue___0: /* CIL Label */;
    #####: 1880:        if (!(nargc > 0)) {
    #####: 1881:          goto while_break___0;
        -: 1882:        }
        -: 1883:        {
    #####: 1884:          tmp___9 = strspn((char const *)p, " \t");
    #####: 1885:          p += tmp___9;
    #####: 1886:          tmp___10 = nargv;
    #####: 1887:          nargv++;
    #####: 1888:          *tmp___10 = p;
        -: 1889:        }
        -: 1890:        {
        -: 1891:          while (1) {
    #####: 1892:          while_continue___1: /* CIL Label */;
    #####: 1893:            tmp___11 = p;
    #####: 1894:            p++;
    #####: 1895:            if (!*tmp___11) {
    #####: 1896:              goto while_break___1;
        -: 1897:            }
        -: 1898:          }
    #####: 1899:        while_break___1: /* CIL Label */;
        -: 1900:        }
    #####: 1901:        nargc--;
        -: 1902:      }
    #####: 1903:    while_break___0: /* CIL Label */;
        -: 1904:    }
        -: 1905:    {
        -: 1906:      while (1) {
    #####: 1907:      while_continue___2: /* CIL Label */;
    #####: 1908:        tmp___14 = oargc;
    #####: 1909:        oargc--;
    #####: 1910:        if (!tmp___14) {
    #####: 1911:          goto while_break___2;
        -: 1912:        }
    #####: 1913:        tmp___12 = nargv;
    #####: 1914:        nargv++;
    #####: 1915:        tmp___13 = oargv;
    #####: 1916:        oargv++;
    #####: 1917:        *tmp___12 = *tmp___13;
        -: 1918:      }
    #####: 1919:    while_break___2: /* CIL Label */;
        -: 1920:    }
    #####: 1921:    *nargv = (char *)((void *)0);
    #####: 1922:    return (env___0);
        -: 1923:  }
        -: 1924:}
    #####: 1925:void error(char *m) {
        -: 1926:
        -: 1927:  {
        -: 1928:    {
    #####: 1929:      fprintf((FILE * /* __restrict  */) stderr,
        -: 1930:              (char const * /* __restrict  */) "\n%s: %s: %s\n", progname,
        -: 1931:              ifname, m);
    #####: 1932:      abort_gzip();
        -: 1933:    }
    #####: 1934:    return;
        -: 1935:  }
        -: 1936:}
    #####: 1937:void read_error(void) {
        -: 1938:  int *tmp;
        -: 1939:
        -: 1940:  {
        -: 1941:    {
    #####: 1942:      fprintf((FILE * /* __restrict  */) stderr,
        -: 1943:              (char const * /* __restrict  */) "\n%s: ", progname);
    #####: 1944:      tmp = __errno_location();
        -: 1945:    }
    #####: 1946:    if (*tmp != 0) {
        -: 1947:      {
    #####: 1948:        perror((char const *)(ifname));
        -: 1949:      }
        -: 1950:    } else {
        -: 1951:      {
    #####: 1952:        fprintf((FILE * /* __restrict  */) stderr,
        -: 1953:                (char const * /* __restrict  */) "%s: unexpected end of file\n",
        -: 1954:                ifname);
        -: 1955:      }
        -: 1956:    }
    #####: 1957:    { abort_gzip(); }
    #####: 1958:    return;
        -: 1959:  }
        -: 1960:}
    #####: 1961:void write_error(void) {
        -: 1962:
        -: 1963:  {
        -: 1964:    {
    #####: 1965:      fprintf((FILE * /* __restrict  */) stderr,
        -: 1966:              (char const * /* __restrict  */) "\n%s: ", progname);
    #####: 1967:      perror((char const *)(ofname));
    #####: 1968:      abort_gzip();
        -: 1969:    }
    #####: 1970:    return;
        -: 1971:  }
        -: 1972:}
    #####: 1973:void display_ratio(long num, long den, FILE *file) {
        -: 1974:  long ratio;
        -: 1975:
        -: 1976:  {
    #####: 1977:    if (den == 0L) {
    #####: 1978:      ratio = 0L;
        -: 1979:    } else {
    #####: 1980:      if (den < 2147483L) {
    #####: 1981:        ratio = (1000L * num) / den;
        -: 1982:      } else {
    #####: 1983:        ratio = num / (den / 1000L);
        -: 1984:      }
        -: 1985:    }
    #####: 1986:    if (ratio < 0L) {
        -: 1987:      {
    #####: 1988:        _IO_putc('-', file);
    #####: 1989:        ratio = -ratio;
        -: 1990:      }
        -: 1991:    } else {
    #####: 1992:      { _IO_putc(' ', file); }
        -: 1993:    }
        -: 1994:    {
    #####: 1995:      fprintf((FILE * /* __restrict  */) file,
        -: 1996:              (char const * /* __restrict  */) "%2ld.%1ld%%", ratio / 10L,
        -: 1997:              ratio % 10L);
        -: 1998:    }
    #####: 1999:    return;
        -: 2000:  }
        -: 2001:}
    #####: 2002:voidp xmalloc(unsigned int size) {
        -: 2003:  voidp cp;
        -: 2004:  voidp tmp;
        -: 2005:  char *__cil_tmp4;
        -: 2006:
        -: 2007:  {
        -: 2008:    {
    #####: 2009:      tmp = malloc((size_t)size);
    #####: 2010:      cp = tmp;
        -: 2011:    }
    #####: 2012:    if ((unsigned long)cp == (unsigned long)((void *)0)) {
        -: 2013:      {
    #####: 2014:        error((char *)"out of memory");
        -: 2015:      }
        -: 2016:    }
    #####: 2017:    return (cp);
        -: 2018:  }
        -: 2019:}
        -: 2020:ulg crc_32_tab[256] = {
        -: 2021:    (ulg)0L,          (ulg)1996959894L, (ulg)3993919788L, (ulg)2567524794L,
        -: 2022:    (ulg)124634137L,  (ulg)1886057615L, (ulg)3915621685L, (ulg)2657392035L,
        -: 2023:    (ulg)249268274L,  (ulg)2044508324L, (ulg)3772115230L, (ulg)2547177864L,
        -: 2024:    (ulg)162941995L,  (ulg)2125561021L, (ulg)3887607047L, (ulg)2428444049L,
        -: 2025:    (ulg)498536548L,  (ulg)1789927666L, (ulg)4089016648L, (ulg)2227061214L,
        -: 2026:    (ulg)450548861L,  (ulg)1843258603L, (ulg)4107580753L, (ulg)2211677639L,
        -: 2027:    (ulg)325883990L,  (ulg)1684777152L, (ulg)4251122042L, (ulg)2321926636L,
        -: 2028:    (ulg)335633487L,  (ulg)1661365465L, (ulg)4195302755L, (ulg)2366115317L,
        -: 2029:    (ulg)997073096L,  (ulg)1281953886L, (ulg)3579855332L, (ulg)2724688242L,
        -: 2030:    (ulg)1006888145L, (ulg)1258607687L, (ulg)3524101629L, (ulg)2768942443L,
        -: 2031:    (ulg)901097722L,  (ulg)1119000684L, (ulg)3686517206L, (ulg)2898065728L,
        -: 2032:    (ulg)853044451L,  (ulg)1172266101L, (ulg)3705015759L, (ulg)2882616665L,
        -: 2033:    (ulg)651767980L,  (ulg)1373503546L, (ulg)3369554304L, (ulg)3218104598L,
        -: 2034:    (ulg)565507253L,  (ulg)1454621731L, (ulg)3485111705L, (ulg)3099436303L,
        -: 2035:    (ulg)671266974L,  (ulg)1594198024L, (ulg)3322730930L, (ulg)2970347812L,
        -: 2036:    (ulg)795835527L,  (ulg)1483230225L, (ulg)3244367275L, (ulg)3060149565L,
        -: 2037:    (ulg)1994146192L, (ulg)31158534L,   (ulg)2563907772L, (ulg)4023717930L,
        -: 2038:    (ulg)1907459465L, (ulg)112637215L,  (ulg)2680153253L, (ulg)3904427059L,
        -: 2039:    (ulg)2013776290L, (ulg)251722036L,  (ulg)2517215374L, (ulg)3775830040L,
        -: 2040:    (ulg)2137656763L, (ulg)141376813L,  (ulg)2439277719L, (ulg)3865271297L,
        -: 2041:    (ulg)1802195444L, (ulg)476864866L,  (ulg)2238001368L, (ulg)4066508878L,
        -: 2042:    (ulg)1812370925L, (ulg)453092731L,  (ulg)2181625025L, (ulg)4111451223L,
        -: 2043:    (ulg)1706088902L, (ulg)314042704L,  (ulg)2344532202L, (ulg)4240017532L,
        -: 2044:    (ulg)1658658271L, (ulg)366619977L,  (ulg)2362670323L, (ulg)4224994405L,
        -: 2045:    (ulg)1303535960L, (ulg)984961486L,  (ulg)2747007092L, (ulg)3569037538L,
        -: 2046:    (ulg)1256170817L, (ulg)1037604311L, (ulg)2765210733L, (ulg)3554079995L,
        -: 2047:    (ulg)1131014506L, (ulg)879679996L,  (ulg)2909243462L, (ulg)3663771856L,
        -: 2048:    (ulg)1141124467L, (ulg)855842277L,  (ulg)2852801631L, (ulg)3708648649L,
        -: 2049:    (ulg)1342533948L, (ulg)654459306L,  (ulg)3188396048L, (ulg)3373015174L,
        -: 2050:    (ulg)1466479909L, (ulg)544179635L,  (ulg)3110523913L, (ulg)3462522015L,
        -: 2051:    (ulg)1591671054L, (ulg)702138776L,  (ulg)2966460450L, (ulg)3352799412L,
        -: 2052:    (ulg)1504918807L, (ulg)783551873L,  (ulg)3082640443L, (ulg)3233442989L,
        -: 2053:    (ulg)3988292384L, (ulg)2596254646L, (ulg)62317068L,   (ulg)1957810842L,
        -: 2054:    (ulg)3939845945L, (ulg)2647816111L, (ulg)81470997L,   (ulg)1943803523L,
        -: 2055:    (ulg)3814918930L, (ulg)2489596804L, (ulg)225274430L,  (ulg)2053790376L,
        -: 2056:    (ulg)3826175755L, (ulg)2466906013L, (ulg)167816743L,  (ulg)2097651377L,
        -: 2057:    (ulg)4027552580L, (ulg)2265490386L, (ulg)503444072L,  (ulg)1762050814L,
        -: 2058:    (ulg)4150417245L, (ulg)2154129355L, (ulg)426522225L,  (ulg)1852507879L,
        -: 2059:    (ulg)4275313526L, (ulg)2312317920L, (ulg)282753626L,  (ulg)1742555852L,
        -: 2060:    (ulg)4189708143L, (ulg)2394877945L, (ulg)397917763L,  (ulg)1622183637L,
        -: 2061:    (ulg)3604390888L, (ulg)2714866558L, (ulg)953729732L,  (ulg)1340076626L,
        -: 2062:    (ulg)3518719985L, (ulg)2797360999L, (ulg)1068828381L, (ulg)1219638859L,
        -: 2063:    (ulg)3624741850L, (ulg)2936675148L, (ulg)906185462L,  (ulg)1090812512L,
        -: 2064:    (ulg)3747672003L, (ulg)2825379669L, (ulg)829329135L,  (ulg)1181335161L,
        -: 2065:    (ulg)3412177804L, (ulg)3160834842L, (ulg)628085408L,  (ulg)1382605366L,
        -: 2066:    (ulg)3423369109L, (ulg)3138078467L, (ulg)570562233L,  (ulg)1426400815L,
        -: 2067:    (ulg)3317316542L, (ulg)2998733608L, (ulg)733239954L,  (ulg)1555261956L,
        -: 2068:    (ulg)3268935591L, (ulg)3050360625L, (ulg)752459403L,  (ulg)1541320221L,
        -: 2069:    (ulg)2607071920L, (ulg)3965973030L, (ulg)1969922972L, (ulg)40735498L,
        -: 2070:    (ulg)2617837225L, (ulg)3943577151L, (ulg)1913087877L, (ulg)83908371L,
        -: 2071:    (ulg)2512341634L, (ulg)3803740692L, (ulg)2075208622L, (ulg)213261112L,
        -: 2072:    (ulg)2463272603L, (ulg)3855990285L, (ulg)2094854071L, (ulg)198958881L,
        -: 2073:    (ulg)2262029012L, (ulg)4057260610L, (ulg)1759359992L, (ulg)534414190L,
        -: 2074:    (ulg)2176718541L, (ulg)4139329115L, (ulg)1873836001L, (ulg)414664567L,
        -: 2075:    (ulg)2282248934L, (ulg)4279200368L, (ulg)1711684554L, (ulg)285281116L,
        -: 2076:    (ulg)2405801727L, (ulg)4167216745L, (ulg)1634467795L, (ulg)376229701L,
        -: 2077:    (ulg)2685067896L, (ulg)3608007406L, (ulg)1308918612L, (ulg)956543938L,
        -: 2078:    (ulg)2808555105L, (ulg)3495958263L, (ulg)1231636301L, (ulg)1047427035L,
        -: 2079:    (ulg)2932959818L, (ulg)3654703836L, (ulg)1088359270L, (ulg)936918000L,
        -: 2080:    (ulg)2847714899L, (ulg)3736837829L, (ulg)1202900863L, (ulg)817233897L,
        -: 2081:    (ulg)3183342108L, (ulg)3401237130L, (ulg)1404277552L, (ulg)615818150L,
        -: 2082:    (ulg)3134207493L, (ulg)3453421203L, (ulg)1423857449L, (ulg)601450431L,
        -: 2083:    (ulg)3009837614L, (ulg)3294710456L, (ulg)1567103746L, (ulg)711928724L,
        -: 2084:    (ulg)3020668471L, (ulg)3272380065L, (ulg)1510334235L, (ulg)755167117L};
        -: 2085:int inflate(void);
        -: 2086:int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e,
        -: 2087:               struct huft **t, int *m);
        -: 2088:int huft_free(struct huft *t);
        -: 2089:int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd);
        -: 2090:int inflate_stored(void);
        -: 2091:int inflate_fixed(void);
        -: 2092:int inflate_dynamic(void);
        -: 2093:int inflate_block(int *e);
        -: 2094:static unsigned int border[19] = {16U, 17U, 18U, 0U, 8U,  7U, 9U,  6U, 10U, 5U,
        -: 2095:                                  11U, 4U,  12U, 3U, 13U, 2U, 14U, 1U, 15U};
        -: 2096:static ush cplens[31] = {
        -: 2097:    (ush)3,   (ush)4,  (ush)5,   (ush)6,   (ush)7,   (ush)8,   (ush)9,
        -: 2098:    (ush)10,  (ush)11, (ush)13,  (ush)15,  (ush)17,  (ush)19,  (ush)23,
        -: 2099:    (ush)27,  (ush)31, (ush)35,  (ush)43,  (ush)51,  (ush)59,  (ush)67,
        -: 2100:    (ush)83,  (ush)99, (ush)115, (ush)131, (ush)163, (ush)195, (ush)227,
        -: 2101:    (ush)258, (ush)0,  (ush)0};
        -: 2102:static ush cplext[31] = {
        -: 2103:    (ush)0, (ush)0, (ush)0, (ush)0, (ush)0, (ush)0,  (ush)0, (ush)0,
        -: 2104:    (ush)1, (ush)1, (ush)1, (ush)1, (ush)2, (ush)2,  (ush)2, (ush)2,
        -: 2105:    (ush)3, (ush)3, (ush)3, (ush)3, (ush)4, (ush)4,  (ush)4, (ush)4,
        -: 2106:    (ush)5, (ush)5, (ush)5, (ush)5, (ush)0, (ush)99, (ush)99};
        -: 2107:static ush cpdist[30] = {
        -: 2108:    (ush)1,    (ush)2,    (ush)3,    (ush)4,     (ush)5,     (ush)7,
        -: 2109:    (ush)9,    (ush)13,   (ush)17,   (ush)25,    (ush)33,    (ush)49,
        -: 2110:    (ush)65,   (ush)97,   (ush)129,  (ush)193,   (ush)257,   (ush)385,
        -: 2111:    (ush)513,  (ush)769,  (ush)1025, (ush)1537,  (ush)2049,  (ush)3073,
        -: 2112:    (ush)4097, (ush)6145, (ush)8193, (ush)12289, (ush)16385, (ush)24577};
        -: 2113:static ush cpdext[30] = {(ush)0,  (ush)0,  (ush)0,  (ush)0,  (ush)1,  (ush)1,
        -: 2114:                         (ush)2,  (ush)2,  (ush)3,  (ush)3,  (ush)4,  (ush)4,
        -: 2115:                         (ush)5,  (ush)5,  (ush)6,  (ush)6,  (ush)7,  (ush)7,
        -: 2116:                         (ush)8,  (ush)8,  (ush)9,  (ush)9,  (ush)10, (ush)10,
        -: 2117:                         (ush)11, (ush)11, (ush)12, (ush)12, (ush)13, (ush)13};
        -: 2118:ulg bb;
        -: 2119:unsigned int bk;
        -: 2120:ush mask_bits[17] = {(ush)0,     (ush)1,    (ush)3,    (ush)7,    (ush)15,
        -: 2121:                     (ush)31,    (ush)63,   (ush)127,  (ush)255,  (ush)511,
        -: 2122:                     (ush)1023,  (ush)2047, (ush)4095, (ush)8191, (ush)16383,
        -: 2123:                     (ush)32767, (ush)65535};
        -: 2124:int lbits = 9;
        -: 2125:int dbits = 6;
        -: 2126:unsigned int hufts;
    #####: 2127:int huft_build(unsigned int *b, unsigned int n, unsigned int s, ush *d, ush *e,
        -: 2128:               struct huft **t, int *m) {
        -: 2129:  unsigned int a;
        -: 2130:  unsigned int c[17];
        -: 2131:  unsigned int f;
        -: 2132:  int g;
        -: 2133:  int h;
        -: 2134:  register unsigned int i___0;
        -: 2135:  register unsigned int j___0;
        -: 2136:  register int k;
        -: 2137:  int l;
        -: 2138:  register unsigned int *p;
        -: 2139:  register struct huft *q;
        -: 2140:  struct huft r;
        -: 2141:  struct huft *u[16];
        -: 2142:  unsigned int v[288];
        -: 2143:  register int w;
        -: 2144:  unsigned int x[17];
        -: 2145:  unsigned int *xp;
        -: 2146:  int y;
        -: 2147:  unsigned int z;
        -: 2148:  unsigned int *tmp;
        -: 2149:  unsigned int *tmp___0;
        -: 2150:  unsigned int tmp___1;
        -: 2151:  unsigned int *tmp___2;
        -: 2152:  int tmp___4;
        -: 2153:  unsigned int *tmp___5;
        -: 2154:  unsigned int tmp___6;
        -: 2155:  int tmp___7;
        -: 2156:  void *__cil_tmp36;
        -: 2157:  void *__cil_tmp37;
        -: 2158:  void *__cil_tmp38;
        -: 2159:  void *__cil_tmp39;
        -: 2160:  int __cil_tmp40;
        -: 2161:
        -: 2162:  {
        -: 2163:    {
    #####: 2164:      memset((voidp)(c), 0, sizeof(c));
    #####: 2165:      p = b;
    #####: 2166:      i___0 = n;
        -: 2167:    }
        -: 2168:    {
        -: 2169:      while (1) {
    #####: 2170:      while_continue: /* CIL Label */;
    #####: 2171:        (c[*p])++;
    #####: 2172:        p++;
    #####: 2173:        i___0--;
    #####: 2174:        if (!i___0) {
    #####: 2175:          goto while_break;
        -: 2176:        }
        -: 2177:      }
    #####: 2178:    while_break: /* CIL Label */;
        -: 2179:    }
    #####: 2180:    if (c[0] == n) {
    #####: 2181:      *t = (struct huft *)((void *)0);
    #####: 2182:      *m = 0;
    #####: 2183:      return (0);
        -: 2184:    }
    #####: 2185:    l = *m;
    #####: 2186:    j___0 = 1U;
        -: 2187:    {
        -: 2188:      while (1) {
    #####: 2189:      while_continue___0: /* CIL Label */;
    #####: 2190:        if (!(j___0 <= 16U)) {
    #####: 2191:          goto while_break___0;
        -: 2192:        }
    #####: 2193:        if (c[j___0]) {
    #####: 2194:          goto while_break___0;
        -: 2195:        }
    #####: 2196:        j___0++;
        -: 2197:      }
    #####: 2198:    while_break___0: /* CIL Label */;
        -: 2199:    }
    #####: 2200:    k = (int)j___0;
    #####: 2201:    if ((unsigned int)l < j___0) {
    #####: 2202:      l = (int)j___0;
        -: 2203:    }
    #####: 2204:    i___0 = 16U;
        -: 2205:    {
        -: 2206:      while (1) {
    #####: 2207:      while_continue___1: /* CIL Label */;
    #####: 2208:        if (!i___0) {
    #####: 2209:          goto while_break___1;
        -: 2210:        }
    #####: 2211:        if (c[i___0]) {
    #####: 2212:          goto while_break___1;
        -: 2213:        }
    #####: 2214:        i___0--;
        -: 2215:      }
    #####: 2216:    while_break___1: /* CIL Label */;
        -: 2217:    }
    #####: 2218:    g = (int)i___0;
    #####: 2219:    if ((unsigned int)l > i___0) {
    #####: 2220:      l = (int)i___0;
        -: 2221:    }
    #####: 2222:    *m = l;
    #####: 2223:    y = 1 << j___0;
        -: 2224:    {
        -: 2225:      while (1) {
    #####: 2226:      while_continue___2: /* CIL Label */;
    #####: 2227:        if (!(j___0 < i___0)) {
    #####: 2228:          goto while_break___2;
        -: 2229:        }
    #####: 2230:        y = (int)((unsigned int)y - c[j___0]);
    #####: 2231:        if (y < 0) {
    #####: 2232:          return (2);
        -: 2233:        }
    #####: 2234:        j___0++;
    #####: 2235:        y <<= 1;
        -: 2236:      }
    #####: 2237:    while_break___2: /* CIL Label */;
        -: 2238:    }
    #####: 2239:    y = (int)((unsigned int)y - c[i___0]);
    #####: 2240:    if (y < 0) {
    #####: 2241:      return (2);
        -: 2242:    }
    #####: 2243:    c[i___0] += (unsigned int)y;
    #####: 2244:    j___0 = 0U;
    #####: 2245:    x[1] = j___0;
    #####: 2246:    p = c + 1;
    #####: 2247:    xp = x + 2;
        -: 2248:    {
        -: 2249:      while (1) {
    #####: 2250:      while_continue___3: /* CIL Label */;
    #####: 2251:        i___0--;
    #####: 2252:        if (!i___0) {
    #####: 2253:          goto while_break___3;
        -: 2254:        }
    #####: 2255:        tmp = xp;
    #####: 2256:        xp++;
    #####: 2257:        tmp___0 = p;
    #####: 2258:        p++;
    #####: 2259:        j___0 += *tmp___0;
    #####: 2260:        *tmp = j___0;
        -: 2261:      }
    #####: 2262:    while_break___3: /* CIL Label */;
        -: 2263:    }
    #####: 2264:    p = b;
    #####: 2265:    i___0 = 0U;
        -: 2266:    {
        -: 2267:      while (1) {
    #####: 2268:      while_continue___4: /* CIL Label */;
    #####: 2269:        tmp___2 = p;
    #####: 2270:        p++;
    #####: 2271:        j___0 = *tmp___2;
    #####: 2272:        if (j___0 != 0U) {
    #####: 2273:          tmp___1 = x[j___0];
    #####: 2274:          (x[j___0])++;
    #####: 2275:          v[tmp___1] = i___0;
        -: 2276:        }
    #####: 2277:        i___0++;
    #####: 2278:        if (!(i___0 < n)) {
    #####: 2279:          goto while_break___4;
        -: 2280:        }
        -: 2281:      }
    #####: 2282:    while_break___4: /* CIL Label */;
        -: 2283:    }
    #####: 2284:    i___0 = 0U;
    #####: 2285:    x[0] = i___0;
    #####: 2286:    p = v;
    #####: 2287:    h = -1;
    #####: 2288:    w = -l;
    #####: 2289:    u[0] = (struct huft *)((void *)0);
    #####: 2290:    q = (struct huft *)((void *)0);
    #####: 2291:    z = 0U;
        -: 2292:    {
        -: 2293:      while (1) {
    #####: 2294:      while_continue___5: /* CIL Label */;
    #####: 2295:        if (!(k <= g)) {
    #####: 2296:          goto while_break___5;
        -: 2297:        }
    #####: 2298:        a = c[k];
        -: 2299:        {
        -: 2300:          while (1) {
    #####: 2301:          while_continue___6: /* CIL Label */;
    #####: 2302:            tmp___6 = a;
    #####: 2303:            a--;
    #####: 2304:            if (!tmp___6) {
    #####: 2305:              goto while_break___6;
        -: 2306:            }
        -: 2307:            {
        -: 2308:              while (1) {
    #####: 2309:              while_continue___7: /* CIL Label */;
    #####: 2310:                if (!(k > w + l)) {
    #####: 2311:                  goto while_break___7;
        -: 2312:                }
    #####: 2313:                h++;
    #####: 2314:                w += l;
    #####: 2315:                z = (unsigned int)(g - w);
    #####: 2316:                if (z > (unsigned int)l) {
    #####: 2317:                  z = (unsigned int)l;
        -: 2318:                } else {
    #####: 2319:                  z = z;
        -: 2320:                }
    #####: 2321:                j___0 = (unsigned int)(k - w);
    #####: 2322:                f = (unsigned int)(1 << j___0);
    #####: 2323:                if (f > a + 1U) {
    #####: 2324:                  f -= a + 1U;
    #####: 2325:                  xp = c + k;
        -: 2326:                  {
        -: 2327:                    while (1) {
    #####: 2328:                    while_continue___8: /* CIL Label */;
    #####: 2329:                      j___0++;
    #####: 2330:                      if (!(j___0 < z)) {
    #####: 2331:                        goto while_break___8;
        -: 2332:                      }
    #####: 2333:                      f <<= 1;
    #####: 2334:                      xp++;
    #####: 2335:                      if (f <= *xp) {
    #####: 2336:                        goto while_break___8;
        -: 2337:                      }
    #####: 2338:                      f -= *xp;
        -: 2339:                    }
    #####: 2340:                  while_break___8: /* CIL Label */;
        -: 2341:                  }
        -: 2342:                }
        -: 2343:                {
    #####: 2344:                  z = (unsigned int)(1 << j___0);
    #####: 2345:                  q = (struct huft *)malloc((unsigned long)(z + 1U) *
        -: 2346:                                            sizeof(struct huft));
        -: 2347:                }
    #####: 2348:                if ((unsigned long)q ==
        -: 2349:                    (unsigned long)((struct huft *)((void *)0))) {
    #####: 2350:                  if (h) {
        -: 2351:                    {
    #####: 2352:                      huft_free(u[0]);
        -: 2353:                    }
        -: 2354:                  }
    #####: 2355:                  return (3);
        -: 2356:                }
    #####: 2357:                hufts += z + 1U;
    #####: 2358:                *t = q + 1;
    #####: 2359:                t = &q->v.t;
    #####: 2360:                *t = (struct huft *)((void *)0);
    #####: 2361:                q++;
    #####: 2362:                u[h] = q;
    #####: 2363:                if (h) {
    #####: 2364:                  x[h] = i___0;
    #####: 2365:                  r.b = (uch)l;
    #####: 2366:                  r.e = (uch)(16U + j___0);
    #####: 2367:                  r.v.t = q;
    #####: 2368:                  j___0 = i___0 >> (w - l);
    #####: 2369:                  *(u[h - 1] + j___0) = r;
        -: 2370:                }
        -: 2371:              }
    #####: 2372:            while_break___7: /* CIL Label */;
        -: 2373:            }
    #####: 2374:            r.b = (uch)(k - w);
    #####: 2375:            if ((unsigned long)p >= (unsigned long)(v + n)) {
    #####: 2376:              r.e = (uch)99;
        -: 2377:            } else {
    #####: 2378:              if (*p < s) {
    #####: 2379:                if (*p < 256U) {
    #####: 2380:                  tmp___4 = 16;
        -: 2381:                } else {
    #####: 2382:                  tmp___4 = 15;
        -: 2383:                }
    #####: 2384:                r.e = (uch)tmp___4;
    #####: 2385:                r.v.n = (ush)*p;
    #####: 2386:                p++;
        -: 2387:              } else {
    #####: 2388:                r.e = (uch) * (e + (*p - s));
    #####: 2389:                tmp___5 = p;
    #####: 2390:                p++;
    #####: 2391:                r.v.n = *(d + (*tmp___5 - s));
        -: 2392:              }
        -: 2393:            }
    #####: 2394:            f = (unsigned int)(1 << (k - w));
    #####: 2395:            j___0 = i___0 >> w;
        -: 2396:            {
        -: 2397:              while (1) {
    #####: 2398:              while_continue___9: /* CIL Label */;
    #####: 2399:                if (!(j___0 < z)) {
    #####: 2400:                  goto while_break___9;
        -: 2401:                }
    #####: 2402:                *(q + j___0) = r;
    #####: 2403:                j___0 += f;
        -: 2404:              }
    #####: 2405:            while_break___9: /* CIL Label */;
        -: 2406:            }
    #####: 2407:            j___0 = (unsigned int)(1 << (k - 1));
        -: 2408:            {
        -: 2409:              while (1) {
    #####: 2410:              while_continue___10: /* CIL Label */;
    #####: 2411:                if (!(i___0 & j___0)) {
    #####: 2412:                  goto while_break___10;
        -: 2413:                }
    #####: 2414:                i___0 ^= j___0;
    #####: 2415:                j___0 >>= 1;
        -: 2416:              }
    #####: 2417:            while_break___10: /* CIL Label */;
        -: 2418:            }
    #####: 2419:            i___0 ^= j___0;
        -: 2420:            {
        -: 2421:              while (1) {
    #####: 2422:              while_continue___11: /* CIL Label */;
    #####: 2423:                if (!((i___0 & (unsigned int)((1 << w) - 1)) != x[h])) {
    #####: 2424:                  goto while_break___11;
        -: 2425:                }
    #####: 2426:                h--;
    #####: 2427:                w -= l;
        -: 2428:              }
    #####: 2429:            while_break___11: /* CIL Label */;
        -: 2430:            }
        -: 2431:          }
    #####: 2432:        while_break___6: /* CIL Label */;
        -: 2433:        }
    #####: 2434:        k++;
        -: 2435:      }
    #####: 2436:    while_break___5: /* CIL Label */;
        -: 2437:    }
    #####: 2438:    if (y != 0) {
    #####: 2439:      if (g != 1) {
    #####: 2440:        tmp___7 = 1;
        -: 2441:      } else {
    #####: 2442:        tmp___7 = 0;
        -: 2443:      }
        -: 2444:    } else {
    #####: 2445:      tmp___7 = 0;
        -: 2446:    }
    #####: 2447:    return (tmp___7);
        -: 2448:  }
        -: 2449:}
    #####: 2450:int huft_free(struct huft *t) {
        -: 2451:  register struct huft *p;
        -: 2452:  register struct huft *q;
        -: 2453:
        -: 2454:  {
    #####: 2455:    p = t;
        -: 2456:    {
        -: 2457:      while (1) {
    #####: 2458:      while_continue: /* CIL Label */;
    #####: 2459:        if (!((unsigned long)p !=
        -: 2460:              (unsigned long)((struct huft *)((void *)0)))) {
    #####: 2461:          goto while_break;
        -: 2462:        }
        -: 2463:        {
    #####: 2464:          p--;
    #####: 2465:          q = p->v.t;
    #####: 2466:          free((void *)((char *)p));
    #####: 2467:          p = q;
        -: 2468:        }
        -: 2469:      }
    #####: 2470:    while_break: /* CIL Label */;
        -: 2471:    }
    #####: 2472:    return (0);
        -: 2473:  }
        -: 2474:}
    #####: 2475:int inflate_codes(struct huft *tl, struct huft *td, int bl, int bd) {
        -: 2476:  register unsigned int e;
        -: 2477:  unsigned int n;
        -: 2478:  unsigned int d;
        -: 2479:  unsigned int w;
        -: 2480:  struct huft *t;
        -: 2481:  unsigned int ml;
        -: 2482:  unsigned int md;
        -: 2483:  register ulg b;
        -: 2484:  register unsigned int k;
        -: 2485:  unsigned int tmp;
        -: 2486:  int tmp___0;
        -: 2487:  int tmp___1;
        -: 2488:  unsigned int tmp___2;
        -: 2489:  int tmp___3;
        -: 2490:  int tmp___4;
        -: 2491:  unsigned int tmp___5;
        -: 2492:  unsigned int tmp___6;
        -: 2493:  int tmp___7;
        -: 2494:  int tmp___8;
        -: 2495:  unsigned int tmp___9;
        -: 2496:  int tmp___10;
        -: 2497:  int tmp___11;
        -: 2498:  unsigned int tmp___12;
        -: 2499:  int tmp___13;
        -: 2500:  int tmp___14;
        -: 2501:  unsigned int tmp___15;
        -: 2502:  int tmp___16;
        -: 2503:  int tmp___17;
        -: 2504:  unsigned int tmp___19;
        -: 2505:  unsigned int tmp___20;
        -: 2506:  unsigned int tmp___21;
        -: 2507:
        -: 2508:  {
    #####: 2509:    b = bb;
    #####: 2510:    k = bk;
    #####: 2511:    w = outcnt;
    #####: 2512:    ml = (unsigned int)mask_bits[bl];
    #####: 2513:    md = (unsigned int)mask_bits[bd];
        -: 2514:    {
        -: 2515:      while (1) {
    #####: 2516:      while_continue: /* CIL Label */;
        -: 2517:        {
        -: 2518:          while (1) {
    #####: 2519:          while_continue___0: /* CIL Label */;
    #####: 2520:            if (!(k < (unsigned int)bl)) {
    #####: 2521:              goto while_break___0;
        -: 2522:            }
    #####: 2523:            if (inptr < insize) {
    #####: 2524:              tmp = inptr;
    #####: 2525:              inptr++;
    #####: 2526:              tmp___1 = (int)inbuf[tmp];
        -: 2527:            } else {
        -: 2528:              {
    #####: 2529:                tmp___0 = fill_inbuf(0);
    #####: 2530:                tmp___1 = tmp___0;
        -: 2531:              }
        -: 2532:            }
    #####: 2533:            b |= (ulg)((uch)tmp___1) << k;
    #####: 2534:            k += 8U;
        -: 2535:          }
    #####: 2536:        while_break___0: /* CIL Label */;
        -: 2537:        }
    #####: 2538:        t = tl + ((unsigned int)b & ml);
    #####: 2539:        e = (unsigned int)t->e;
    #####: 2540:        if (e > 16U) {
        -: 2541:          {
        -: 2542:            while (1) {
    #####: 2543:            while_continue___1: /* CIL Label */;
    #####: 2544:              if (e == 99U) {
    #####: 2545:                return (1);
        -: 2546:              }
    #####: 2547:              b >>= (int)t->b;
    #####: 2548:              k -= (unsigned int)t->b;
    #####: 2549:              e -= 16U;
        -: 2550:              {
        -: 2551:                while (1) {
    #####: 2552:                while_continue___2: /* CIL Label */;
    #####: 2553:                  if (!(k < e)) {
    #####: 2554:                    goto while_break___2;
        -: 2555:                  }
    #####: 2556:                  if (inptr < insize) {
    #####: 2557:                    tmp___2 = inptr;
    #####: 2558:                    inptr++;
    #####: 2559:                    tmp___4 = (int)inbuf[tmp___2];
        -: 2560:                  } else {
        -: 2561:                    {
    #####: 2562:                      tmp___3 = fill_inbuf(0);
    #####: 2563:                      tmp___4 = tmp___3;
        -: 2564:                    }
        -: 2565:                  }
    #####: 2566:                  b |= (ulg)((uch)tmp___4) << k;
    #####: 2567:                  k += 8U;
        -: 2568:                }
    #####: 2569:              while_break___2: /* CIL Label */;
        -: 2570:              }
    #####: 2571:              t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####: 2572:              e = (unsigned int)t->e;
    #####: 2573:              if (!(e > 16U)) {
    #####: 2574:                goto while_break___1;
        -: 2575:              }
        -: 2576:            }
    #####: 2577:          while_break___1: /* CIL Label */;
        -: 2578:          }
        -: 2579:        }
    #####: 2580:        b >>= (int)t->b;
    #####: 2581:        k -= (unsigned int)t->b;
    #####: 2582:        if (e == 16U) {
    #####: 2583:          tmp___5 = w;
    #####: 2584:          w++;
    #####: 2585:          window[tmp___5] = (uch)t->v.n;
    #####: 2586:          if (w == 32768U) {
        -: 2587:            {
    #####: 2588:              outcnt = w;
    #####: 2589:              flush_window();
    #####: 2590:              w = 0U;
        -: 2591:            }
        -: 2592:          }
        -: 2593:        } else {
    #####: 2594:          if (e == 15U) {
    #####: 2595:            goto while_break;
        -: 2596:          }
        -: 2597:          {
        -: 2598:            while (1) {
    #####: 2599:            while_continue___3: /* CIL Label */;
    #####: 2600:              if (!(k < e)) {
    #####: 2601:                goto while_break___3;
        -: 2602:              }
    #####: 2603:              if (inptr < insize) {
    #####: 2604:                tmp___6 = inptr;
    #####: 2605:                inptr++;
    #####: 2606:                tmp___8 = (int)inbuf[tmp___6];
        -: 2607:              } else {
        -: 2608:                {
    #####: 2609:                  tmp___7 = fill_inbuf(0);
    #####: 2610:                  tmp___8 = tmp___7;
        -: 2611:                }
        -: 2612:              }
    #####: 2613:              b |= (ulg)((uch)tmp___8) << k;
    #####: 2614:              k += 8U;
        -: 2615:            }
    #####: 2616:          while_break___3: /* CIL Label */;
        -: 2617:          }
    #####: 2618:          n = (unsigned int)t->v.n +
    #####: 2619:              ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####: 2620:          b >>= e;
    #####: 2621:          k -= e;
        -: 2622:          {
        -: 2623:            while (1) {
    #####: 2624:            while_continue___4: /* CIL Label */;
    #####: 2625:              if (!(k < (unsigned int)bd)) {
    #####: 2626:                goto while_break___4;
        -: 2627:              }
    #####: 2628:              if (inptr < insize) {
    #####: 2629:                tmp___9 = inptr;
    #####: 2630:                inptr++;
    #####: 2631:                tmp___11 = (int)inbuf[tmp___9];
        -: 2632:              } else {
        -: 2633:                {
    #####: 2634:                  tmp___10 = fill_inbuf(0);
    #####: 2635:                  tmp___11 = tmp___10;
        -: 2636:                }
        -: 2637:              }
    #####: 2638:              b |= (ulg)((uch)tmp___11) << k;
    #####: 2639:              k += 8U;
        -: 2640:            }
    #####: 2641:          while_break___4: /* CIL Label */;
        -: 2642:          }
    #####: 2643:          t = td + ((unsigned int)b & md);
    #####: 2644:          e = (unsigned int)t->e;
    #####: 2645:          if (e > 16U) {
        -: 2646:            {
        -: 2647:              while (1) {
    #####: 2648:              while_continue___5: /* CIL Label */;
    #####: 2649:                if (e == 99U) {
    #####: 2650:                  return (1);
        -: 2651:                }
    #####: 2652:                b >>= (int)t->b;
    #####: 2653:                k -= (unsigned int)t->b;
    #####: 2654:                e -= 16U;
        -: 2655:                {
        -: 2656:                  while (1) {
    #####: 2657:                  while_continue___6: /* CIL Label */;
    #####: 2658:                    if (!(k < e)) {
    #####: 2659:                      goto while_break___6;
        -: 2660:                    }
    #####: 2661:                    if (inptr < insize) {
    #####: 2662:                      tmp___12 = inptr;
    #####: 2663:                      inptr++;
    #####: 2664:                      tmp___14 = (int)inbuf[tmp___12];
        -: 2665:                    } else {
        -: 2666:                      {
    #####: 2667:                        tmp___13 = fill_inbuf(0);
    #####: 2668:                        tmp___14 = tmp___13;
        -: 2669:                      }
        -: 2670:                    }
    #####: 2671:                    b |= (ulg)((uch)tmp___14) << k;
    #####: 2672:                    k += 8U;
        -: 2673:                  }
    #####: 2674:                while_break___6: /* CIL Label */;
        -: 2675:                }
    #####: 2676:                t = t->v.t + ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####: 2677:                e = (unsigned int)t->e;
    #####: 2678:                if (!(e > 16U)) {
    #####: 2679:                  goto while_break___5;
        -: 2680:                }
        -: 2681:              }
    #####: 2682:            while_break___5: /* CIL Label */;
        -: 2683:            }
        -: 2684:          }
    #####: 2685:          b >>= (int)t->b;
    #####: 2686:          k -= (unsigned int)t->b;
        -: 2687:          {
        -: 2688:            while (1) {
    #####: 2689:            while_continue___7: /* CIL Label */;
    #####: 2690:              if (!(k < e)) {
    #####: 2691:                goto while_break___7;
        -: 2692:              }
    #####: 2693:              if (inptr < insize) {
    #####: 2694:                tmp___15 = inptr;
    #####: 2695:                inptr++;
    #####: 2696:                tmp___17 = (int)inbuf[tmp___15];
        -: 2697:              } else {
        -: 2698:                {
    #####: 2699:                  tmp___16 = fill_inbuf(0);
    #####: 2700:                  tmp___17 = tmp___16;
        -: 2701:                }
        -: 2702:              }
    #####: 2703:              b |= (ulg)((uch)tmp___17) << k;
    #####: 2704:              k += 8U;
        -: 2705:            }
    #####: 2706:          while_break___7: /* CIL Label */;
        -: 2707:          }
    #####: 2708:          d = (w - (unsigned int)t->v.n) -
    #####: 2709:              ((unsigned int)b & (unsigned int)mask_bits[e]);
    #####: 2710:          b >>= e;
    #####: 2711:          k -= e;
        -: 2712:          {
        -: 2713:            while (1) {
    #####: 2714:            while_continue___8: /* CIL Label */;
    #####: 2715:              d &= 32767U;
    #####: 2716:              if (d > w) {
    #####: 2717:                tmp___19 = d;
        -: 2718:              } else {
    #####: 2719:                tmp___19 = w;
        -: 2720:              }
    #####: 2721:              e = 32768U - tmp___19;
    #####: 2722:              if (e > n) {
    #####: 2723:                e = n;
        -: 2724:              } else {
    #####: 2725:                e = e;
        -: 2726:              }
    #####: 2727:              n -= e;
    #####: 2728:              if (w - d >= e) {
        -: 2729:                {
    #####: 2730:                  memcpy((void * /* __restrict  */)(window + w),
        -: 2731:                         (void const * /* __restrict  */)(window + d),
        -: 2732:                         (size_t)e);
    #####: 2733:                  w += e;
    #####: 2734:                  d += e;
        -: 2735:                }
        -: 2736:              } else {
        -: 2737:                {
        -: 2738:                  while (1) {
    #####: 2739:                  while_continue___9: /* CIL Label */;
    #####: 2740:                    tmp___20 = w;
    #####: 2741:                    w++;
    #####: 2742:                    tmp___21 = d;
    #####: 2743:                    d++;
    #####: 2744:                    window[tmp___20] = window[tmp___21];
    #####: 2745:                    e--;
    #####: 2746:                    if (!e) {
    #####: 2747:                      goto while_break___9;
        -: 2748:                    }
        -: 2749:                  }
    #####: 2750:                while_break___9: /* CIL Label */;
        -: 2751:                }
        -: 2752:              }
    #####: 2753:              if (w == 32768U) {
        -: 2754:                {
    #####: 2755:                  outcnt = w;
    #####: 2756:                  flush_window();
    #####: 2757:                  w = 0U;
        -: 2758:                }
        -: 2759:              }
    #####: 2760:              if (!n) {
    #####: 2761:                goto while_break___8;
        -: 2762:              }
        -: 2763:            }
    #####: 2764:          while_break___8: /* CIL Label */;
        -: 2765:          }
        -: 2766:        }
        -: 2767:      }
    #####: 2768:    while_break: /* CIL Label */;
        -: 2769:    }
    #####: 2770:    outcnt = w;
    #####: 2771:    bb = b;
    #####: 2772:    bk = k;
    #####: 2773:    return (0);
        -: 2774:  }
        -: 2775:}
    #####: 2776:int inflate_stored(void) {
        -: 2777:  unsigned int n;
        -: 2778:  unsigned int w;
        -: 2779:  register ulg b;
        -: 2780:  register unsigned int k;
        -: 2781:  unsigned int tmp;
        -: 2782:  int tmp___0;
        -: 2783:  int tmp___1;
        -: 2784:  unsigned int tmp___2;
        -: 2785:  int tmp___3;
        -: 2786:  int tmp___4;
        -: 2787:  unsigned int tmp___5;
        -: 2788:  int tmp___6;
        -: 2789:  int tmp___7;
        -: 2790:  unsigned int tmp___8;
        -: 2791:  unsigned int tmp___9;
        -: 2792:
        -: 2793:  {
    #####: 2794:    b = bb;
    #####: 2795:    k = bk;
    #####: 2796:    w = outcnt;
    #####: 2797:    n = k & 7U;
    #####: 2798:    b >>= n;
    #####: 2799:    k -= n;
        -: 2800:    {
        -: 2801:      while (1) {
    #####: 2802:      while_continue: /* CIL Label */;
    #####: 2803:        if (!(k < 16U)) {
    #####: 2804:          goto while_break;
        -: 2805:        }
    #####: 2806:        if (inptr < insize) {
    #####: 2807:          tmp = inptr;
    #####: 2808:          inptr++;
    #####: 2809:          tmp___1 = (int)inbuf[tmp];
        -: 2810:        } else {
        -: 2811:          {
    #####: 2812:            tmp___0 = fill_inbuf(0);
    #####: 2813:            tmp___1 = tmp___0;
        -: 2814:          }
        -: 2815:        }
    #####: 2816:        b |= (ulg)((uch)tmp___1) << k;
    #####: 2817:        k += 8U;
        -: 2818:      }
    #####: 2819:    while_break: /* CIL Label */;
        -: 2820:    }
    #####: 2821:    n = (unsigned int)b & 65535U;
    #####: 2822:    b >>= 16;
    #####: 2823:    k -= 16U;
        -: 2824:    {
        -: 2825:      while (1) {
    #####: 2826:      while_continue___0: /* CIL Label */;
    #####: 2827:        if (!(k < 16U)) {
    #####: 2828:          goto while_break___0;
        -: 2829:        }
    #####: 2830:        if (inptr < insize) {
    #####: 2831:          tmp___2 = inptr;
    #####: 2832:          inptr++;
    #####: 2833:          tmp___4 = (int)inbuf[tmp___2];
        -: 2834:        } else {
        -: 2835:          {
    #####: 2836:            tmp___3 = fill_inbuf(0);
    #####: 2837:            tmp___4 = tmp___3;
        -: 2838:          }
        -: 2839:        }
    #####: 2840:        b |= (ulg)((uch)tmp___4) << k;
    #####: 2841:        k += 8U;
        -: 2842:      }
    #####: 2843:    while_break___0: /* CIL Label */;
        -: 2844:    }
    #####: 2845:    if (n != (unsigned int)(~b & 65535UL)) {
    #####: 2846:      return (1);
        -: 2847:    }
    #####: 2848:    b >>= 16;
    #####: 2849:    k -= 16U;
        -: 2850:    {
        -: 2851:      while (1) {
    #####: 2852:      while_continue___1: /* CIL Label */;
    #####: 2853:        tmp___9 = n;
    #####: 2854:        n--;
    #####: 2855:        if (!tmp___9) {
    #####: 2856:          goto while_break___1;
        -: 2857:        }
        -: 2858:        {
        -: 2859:          while (1) {
    #####: 2860:          while_continue___2: /* CIL Label */;
    #####: 2861:            if (!(k < 8U)) {
    #####: 2862:              goto while_break___2;
        -: 2863:            }
    #####: 2864:            if (inptr < insize) {
    #####: 2865:              tmp___5 = inptr;
    #####: 2866:              inptr++;
    #####: 2867:              tmp___7 = (int)inbuf[tmp___5];
        -: 2868:            } else {
        -: 2869:              {
    #####: 2870:                tmp___6 = fill_inbuf(0);
    #####: 2871:                tmp___7 = tmp___6;
        -: 2872:              }
        -: 2873:            }
    #####: 2874:            b |= (ulg)((uch)tmp___7) << k;
    #####: 2875:            k += 8U;
        -: 2876:          }
    #####: 2877:        while_break___2: /* CIL Label */;
        -: 2878:        }
    #####: 2879:        tmp___8 = w;
    #####: 2880:        w++;
    #####: 2881:        window[tmp___8] = (uch)b;
    #####: 2882:        if (w == 32768U) {
        -: 2883:          {
    #####: 2884:            outcnt = w;
    #####: 2885:            flush_window();
    #####: 2886:            w = 0U;
        -: 2887:          }
        -: 2888:        }
    #####: 2889:        b >>= 8;
    #####: 2890:        k -= 8U;
        -: 2891:      }
    #####: 2892:    while_break___1: /* CIL Label */;
        -: 2893:    }
    #####: 2894:    outcnt = w;
    #####: 2895:    bb = b;
    #####: 2896:    bk = k;
    #####: 2897:    return (0);
        -: 2898:  }
        -: 2899:}
    #####: 2900:int inflate_fixed(void) {
        -: 2901:  int i___0;
        -: 2902:  struct huft *tl;
        -: 2903:  struct huft *td;
        -: 2904:  int bl;
        -: 2905:  int bd;
        -: 2906:  unsigned int l[288];
        -: 2907:  int tmp;
        -: 2908:  void *__cil_tmp8;
        -: 2909:
        -: 2910:  {
    #####: 2911:    i___0 = 0;
        -: 2912:    {
        -: 2913:      while (1) {
    #####: 2914:      while_continue: /* CIL Label */;
    #####: 2915:        if (!(i___0 < 144)) {
    #####: 2916:          goto while_break;
        -: 2917:        }
    #####: 2918:        l[i___0] = 8U;
    #####: 2919:        i___0++;
        -: 2920:      }
    #####: 2921:    while_break: /* CIL Label */;
        -: 2922:    }
        -: 2923:    {
        -: 2924:      while (1) {
    #####: 2925:      while_continue___0: /* CIL Label */;
    #####: 2926:        if (!(i___0 < 256)) {
    #####: 2927:          goto while_break___0;
        -: 2928:        }
    #####: 2929:        l[i___0] = 9U;
    #####: 2930:        i___0++;
        -: 2931:      }
    #####: 2932:    while_break___0: /* CIL Label */;
        -: 2933:    }
        -: 2934:    {
        -: 2935:      while (1) {
    #####: 2936:      while_continue___1: /* CIL Label */;
    #####: 2937:        if (!(i___0 < 280)) {
    #####: 2938:          goto while_break___1;
        -: 2939:        }
    #####: 2940:        l[i___0] = 7U;
    #####: 2941:        i___0++;
        -: 2942:      }
    #####: 2943:    while_break___1: /* CIL Label */;
        -: 2944:    }
        -: 2945:    {
        -: 2946:      while (1) {
    #####: 2947:      while_continue___2: /* CIL Label */;
    #####: 2948:        if (!(i___0 < 288)) {
    #####: 2949:          goto while_break___2;
        -: 2950:        }
    #####: 2951:        l[i___0] = 8U;
    #####: 2952:        i___0++;
        -: 2953:      }
    #####: 2954:    while_break___2: /* CIL Label */;
        -: 2955:    }
        -: 2956:    {
    #####: 2957:      bl = 7;
    #####: 2958:      i___0 = huft_build(l, 288U, 257U, cplens, cplext, &tl, &bl);
        -: 2959:    }
    #####: 2960:    if (i___0 != 0) {
    #####: 2961:      return (i___0);
        -: 2962:    }
    #####: 2963:    i___0 = 0;
        -: 2964:    {
        -: 2965:      while (1) {
    #####: 2966:      while_continue___3: /* CIL Label */;
    #####: 2967:        if (!(i___0 < 30)) {
    #####: 2968:          goto while_break___3;
        -: 2969:        }
    #####: 2970:        l[i___0] = 5U;
    #####: 2971:        i___0++;
        -: 2972:      }
    #####: 2973:    while_break___3: /* CIL Label */;
        -: 2974:    }
        -: 2975:    {
    #####: 2976:      bd = 5;
    #####: 2977:      i___0 = huft_build(l, 30U, 0U, cpdist, cpdext, &td, &bd);
        -: 2978:    }
    #####: 2979:    if (i___0 > 1) {
        -: 2980:      {
    #####: 2981:        huft_free(tl);
        -: 2982:      }
    #####: 2983:      return (i___0);
        -: 2984:    }
    #####: 2985:    { tmp = inflate_codes(tl, td, bl, bd); }
    #####: 2986:    if (tmp) {
    #####: 2987:      return (1);
        -: 2988:    }
        -: 2989:    {
    #####: 2990:      huft_free(tl);
    #####: 2991:      huft_free(td);
        -: 2992:    }
    #####: 2993:    return (0);
        -: 2994:  }
        -: 2995:}
    #####: 2996:int inflate_dynamic(void) {
        -: 2997:  int i___0;
        -: 2998:  unsigned int j___0;
        -: 2999:  unsigned int l;
        -: 3000:  unsigned int m;
        -: 3001:  unsigned int n;
        -: 3002:  struct huft *tl;
        -: 3003:  struct huft *td;
        -: 3004:  int bl;
        -: 3005:  int bd;
        -: 3006:  unsigned int nb;
        -: 3007:  unsigned int nl;
        -: 3008:  unsigned int nd;
        -: 3009:  unsigned int ll[316];
        -: 3010:  register ulg b;
        -: 3011:  register unsigned int k;
        -: 3012:  unsigned int tmp;
        -: 3013:  int tmp___0;
        -: 3014:  int tmp___1;
        -: 3015:  unsigned int tmp___2;
        -: 3016:  int tmp___3;
        -: 3017:  int tmp___4;
        -: 3018:  unsigned int tmp___5;
        -: 3019:  int tmp___6;
        -: 3020:  int tmp___7;
        -: 3021:  unsigned int tmp___8;
        -: 3022:  int tmp___9;
        -: 3023:  int tmp___10;
        -: 3024:  unsigned int tmp___11;
        -: 3025:  int tmp___12;
        -: 3026:  int tmp___13;
        -: 3027:  int tmp___14;
        -: 3028:  unsigned int tmp___15;
        -: 3029:  int tmp___16;
        -: 3030:  int tmp___17;
        -: 3031:  int tmp___18;
        -: 3032:  unsigned int tmp___19;
        -: 3033:  unsigned int tmp___20;
        -: 3034:  int tmp___21;
        -: 3035:  int tmp___22;
        -: 3036:  int tmp___23;
        -: 3037:  unsigned int tmp___24;
        -: 3038:  unsigned int tmp___25;
        -: 3039:  int tmp___26;
        -: 3040:  int tmp___27;
        -: 3041:  int tmp___28;
        -: 3042:  unsigned int tmp___29;
        -: 3043:  int tmp___30;
        -: 3044:  void *__cil_tmp48;
        -: 3045:
        -: 3046:  {
    #####: 3047:    b = bb;
    #####: 3048:    k = bk;
        -: 3049:    {
        -: 3050:      while (1) {
    #####: 3051:      while_continue: /* CIL Label */;
    #####: 3052:        if (!(k < 5U)) {
    #####: 3053:          goto while_break;
        -: 3054:        }
    #####: 3055:        if (inptr < insize) {
    #####: 3056:          tmp = inptr;
    #####: 3057:          inptr++;
    #####: 3058:          tmp___1 = (int)inbuf[tmp];
        -: 3059:        } else {
        -: 3060:          {
    #####: 3061:            tmp___0 = fill_inbuf(0);
    #####: 3062:            tmp___1 = tmp___0;
        -: 3063:          }
        -: 3064:        }
    #####: 3065:        b |= (ulg)((uch)tmp___1) << k;
    #####: 3066:        k += 8U;
        -: 3067:      }
    #####: 3068:    while_break: /* CIL Label */;
        -: 3069:    }
    #####: 3070:    nl = 257U + ((unsigned int)b & 31U);
    #####: 3071:    b >>= 5;
    #####: 3072:    k -= 5U;
        -: 3073:    {
        -: 3074:      while (1) {
    #####: 3075:      while_continue___0: /* CIL Label */;
    #####: 3076:        if (!(k < 5U)) {
    #####: 3077:          goto while_break___0;
        -: 3078:        }
    #####: 3079:        if (inptr < insize) {
    #####: 3080:          tmp___2 = inptr;
    #####: 3081:          inptr++;
    #####: 3082:          tmp___4 = (int)inbuf[tmp___2];
        -: 3083:        } else {
        -: 3084:          {
    #####: 3085:            tmp___3 = fill_inbuf(0);
    #####: 3086:            tmp___4 = tmp___3;
        -: 3087:          }
        -: 3088:        }
    #####: 3089:        b |= (ulg)((uch)tmp___4) << k;
    #####: 3090:        k += 8U;
        -: 3091:      }
    #####: 3092:    while_break___0: /* CIL Label */;
        -: 3093:    }
    #####: 3094:    nd = 1U + ((unsigned int)b & 31U);
    #####: 3095:    b >>= 5;
    #####: 3096:    k -= 5U;
        -: 3097:    {
        -: 3098:      while (1) {
    #####: 3099:      while_continue___1: /* CIL Label */;
    #####: 3100:        if (!(k < 4U)) {
    #####: 3101:          goto while_break___1;
        -: 3102:        }
    #####: 3103:        if (inptr < insize) {
    #####: 3104:          tmp___5 = inptr;
    #####: 3105:          inptr++;
    #####: 3106:          tmp___7 = (int)inbuf[tmp___5];
        -: 3107:        } else {
        -: 3108:          {
    #####: 3109:            tmp___6 = fill_inbuf(0);
    #####: 3110:            tmp___7 = tmp___6;
        -: 3111:          }
        -: 3112:        }
    #####: 3113:        b |= (ulg)((uch)tmp___7) << k;
    #####: 3114:        k += 8U;
        -: 3115:      }
    #####: 3116:    while_break___1: /* CIL Label */;
        -: 3117:    }
    #####: 3118:    nb = 4U + ((unsigned int)b & 15U);
    #####: 3119:    b >>= 4;
    #####: 3120:    k -= 4U;
    #####: 3121:    if (nl > 286U) {
    #####: 3122:      return (1);
        -: 3123:    } else {
    #####: 3124:      if (nd > 30U) {
    #####: 3125:        return (1);
        -: 3126:      }
        -: 3127:    }
    #####: 3128:    j___0 = 0U;
        -: 3129:    {
        -: 3130:      while (1) {
    #####: 3131:      while_continue___2: /* CIL Label */;
    #####: 3132:        if (!(j___0 < nb)) {
    #####: 3133:          goto while_break___2;
        -: 3134:        }
        -: 3135:        {
        -: 3136:          while (1) {
    #####: 3137:          while_continue___3: /* CIL Label */;
    #####: 3138:            if (!(k < 3U)) {
    #####: 3139:              goto while_break___3;
        -: 3140:            }
    #####: 3141:            if (inptr < insize) {
    #####: 3142:              tmp___8 = inptr;
    #####: 3143:              inptr++;
    #####: 3144:              tmp___10 = (int)inbuf[tmp___8];
        -: 3145:            } else {
        -: 3146:              {
    #####: 3147:                tmp___9 = fill_inbuf(0);
    #####: 3148:                tmp___10 = tmp___9;
        -: 3149:              }
        -: 3150:            }
    #####: 3151:            b |= (ulg)((uch)tmp___10) << k;
    #####: 3152:            k += 8U;
        -: 3153:          }
    #####: 3154:        while_break___3: /* CIL Label */;
        -: 3155:        }
    #####: 3156:        ll[border[j___0]] = (unsigned int)b & 7U;
    #####: 3157:        b >>= 3;
    #####: 3158:        k -= 3U;
    #####: 3159:        j___0++;
        -: 3160:      }
    #####: 3161:    while_break___2: /* CIL Label */;
        -: 3162:    }
        -: 3163:    {
        -: 3164:      while (1) {
    #####: 3165:      while_continue___4: /* CIL Label */;
    #####: 3166:        if (!(j___0 < 19U)) {
    #####: 3167:          goto while_break___4;
        -: 3168:        }
    #####: 3169:        ll[border[j___0]] = 0U;
    #####: 3170:        j___0++;
        -: 3171:      }
    #####: 3172:    while_break___4: /* CIL Label */;
        -: 3173:    }
        -: 3174:    {
    #####: 3175:      bl = 7;
    #####: 3176:      i___0 = huft_build(ll, 19U, 19U, (ush *)((void *)0), (ush *)((void *)0),
        -: 3177:                         &tl, &bl);
        -: 3178:    }
    #####: 3179:    if (i___0 != 0) {
    #####: 3180:      if (i___0 == 1) {
        -: 3181:        {
    #####: 3182:          huft_free(tl);
        -: 3183:        }
        -: 3184:      }
    #####: 3185:      return (i___0);
        -: 3186:    }
    #####: 3187:    n = nl + nd;
    #####: 3188:    m = (unsigned int)mask_bits[bl];
    #####: 3189:    l = 0U;
    #####: 3190:    i___0 = (int)l;
        -: 3191:    {
        -: 3192:      while (1) {
    #####: 3193:      while_continue___5: /* CIL Label */;
    #####: 3194:        if (!((unsigned int)i___0 < n)) {
    #####: 3195:          goto while_break___5;
        -: 3196:        }
        -: 3197:        {
        -: 3198:          while (1) {
    #####: 3199:          while_continue___6: /* CIL Label */;
    #####: 3200:            if (!(k < (unsigned int)bl)) {
    #####: 3201:              goto while_break___6;
        -: 3202:            }
    #####: 3203:            if (inptr < insize) {
    #####: 3204:              tmp___11 = inptr;
    #####: 3205:              inptr++;
    #####: 3206:              tmp___13 = (int)inbuf[tmp___11];
        -: 3207:            } else {
        -: 3208:              {
    #####: 3209:                tmp___12 = fill_inbuf(0);
    #####: 3210:                tmp___13 = tmp___12;
        -: 3211:              }
        -: 3212:            }
    #####: 3213:            b |= (ulg)((uch)tmp___13) << k;
    #####: 3214:            k += 8U;
        -: 3215:          }
    #####: 3216:        while_break___6: /* CIL Label */;
        -: 3217:        }
    #####: 3218:        td = tl + ((unsigned int)b & m);
    #####: 3219:        j___0 = (unsigned int)td->b;
    #####: 3220:        b >>= j___0;
    #####: 3221:        k -= j___0;
    #####: 3222:        j___0 = (unsigned int)td->v.n;
    #####: 3223:        if (j___0 < 16U) {
    #####: 3224:          tmp___14 = i___0;
    #####: 3225:          i___0++;
    #####: 3226:          l = j___0;
    #####: 3227:          ll[tmp___14] = l;
        -: 3228:        } else {
    #####: 3229:          if (j___0 == 16U) {
        -: 3230:            {
        -: 3231:              while (1) {
    #####: 3232:              while_continue___7: /* CIL Label */;
    #####: 3233:                if (!(k < 2U)) {
    #####: 3234:                  goto while_break___7;
        -: 3235:                }
    #####: 3236:                if (inptr < insize) {
    #####: 3237:                  tmp___15 = inptr;
    #####: 3238:                  inptr++;
    #####: 3239:                  tmp___17 = (int)inbuf[tmp___15];
        -: 3240:                } else {
        -: 3241:                  {
    #####: 3242:                    tmp___16 = fill_inbuf(0);
    #####: 3243:                    tmp___17 = tmp___16;
        -: 3244:                  }
        -: 3245:                }
    #####: 3246:                b |= (ulg)((uch)tmp___17) << k;
    #####: 3247:                k += 8U;
        -: 3248:              }
    #####: 3249:            while_break___7: /* CIL Label */;
        -: 3250:            }
    #####: 3251:            j___0 = 3U + ((unsigned int)b & 3U);
    #####: 3252:            b >>= 2;
    #####: 3253:            k -= 2U;
    #####: 3254:            if ((unsigned int)i___0 + j___0 > n) {
    #####: 3255:              return (1);
        -: 3256:            }
        -: 3257:            {
        -: 3258:              while (1) {
    #####: 3259:              while_continue___8: /* CIL Label */;
    #####: 3260:                tmp___19 = j___0;
    #####: 3261:                j___0--;
    #####: 3262:                if (!tmp___19) {
    #####: 3263:                  goto while_break___8;
        -: 3264:                }
    #####: 3265:                tmp___18 = i___0;
    #####: 3266:                i___0++;
    #####: 3267:                ll[tmp___18] = l;
        -: 3268:              }
    #####: 3269:            while_break___8: /* CIL Label */;
        -: 3270:            }
        -: 3271:          } else {
    #####: 3272:            if (j___0 == 17U) {
        -: 3273:              {
        -: 3274:                while (1) {
    #####: 3275:                while_continue___9: /* CIL Label */;
    #####: 3276:                  if (!(k < 3U)) {
    #####: 3277:                    goto while_break___9;
        -: 3278:                  }
    #####: 3279:                  if (inptr < insize) {
    #####: 3280:                    tmp___20 = inptr;
    #####: 3281:                    inptr++;
    #####: 3282:                    tmp___22 = (int)inbuf[tmp___20];
        -: 3283:                  } else {
        -: 3284:                    {
    #####: 3285:                      tmp___21 = fill_inbuf(0);
    #####: 3286:                      tmp___22 = tmp___21;
        -: 3287:                    }
        -: 3288:                  }
    #####: 3289:                  b |= (ulg)((uch)tmp___22) << k;
    #####: 3290:                  k += 8U;
        -: 3291:                }
    #####: 3292:              while_break___9: /* CIL Label */;
        -: 3293:              }
    #####: 3294:              j___0 = 3U + ((unsigned int)b & 7U);
    #####: 3295:              b >>= 3;
    #####: 3296:              k -= 3U;
    #####: 3297:              if ((unsigned int)i___0 + j___0 > n) {
    #####: 3298:                return (1);
        -: 3299:              }
        -: 3300:              {
        -: 3301:                while (1) {
    #####: 3302:                while_continue___10: /* CIL Label */;
    #####: 3303:                  tmp___24 = j___0;
    #####: 3304:                  j___0--;
    #####: 3305:                  if (!tmp___24) {
    #####: 3306:                    goto while_break___10;
        -: 3307:                  }
    #####: 3308:                  tmp___23 = i___0;
    #####: 3309:                  i___0++;
    #####: 3310:                  ll[tmp___23] = 0U;
        -: 3311:                }
    #####: 3312:              while_break___10: /* CIL Label */;
        -: 3313:              }
    #####: 3314:              l = 0U;
        -: 3315:            } else {
        -: 3316:              {
        -: 3317:                while (1) {
    #####: 3318:                while_continue___11: /* CIL Label */;
    #####: 3319:                  if (!(k < 7U)) {
    #####: 3320:                    goto while_break___11;
        -: 3321:                  }
    #####: 3322:                  if (inptr < insize) {
    #####: 3323:                    tmp___25 = inptr;
    #####: 3324:                    inptr++;
    #####: 3325:                    tmp___27 = (int)inbuf[tmp___25];
        -: 3326:                  } else {
        -: 3327:                    {
    #####: 3328:                      tmp___26 = fill_inbuf(0);
    #####: 3329:                      tmp___27 = tmp___26;
        -: 3330:                    }
        -: 3331:                  }
    #####: 3332:                  b |= (ulg)((uch)tmp___27) << k;
    #####: 3333:                  k += 8U;
        -: 3334:                }
    #####: 3335:              while_break___11: /* CIL Label */;
        -: 3336:              }
    #####: 3337:              j___0 = 11U + ((unsigned int)b & 127U);
    #####: 3338:              b >>= 7;
    #####: 3339:              k -= 7U;
    #####: 3340:              if ((unsigned int)i___0 + j___0 > n) {
    #####: 3341:                return (1);
        -: 3342:              }
        -: 3343:              {
        -: 3344:                while (1) {
    #####: 3345:                while_continue___12: /* CIL Label */;
    #####: 3346:                  tmp___29 = j___0;
    #####: 3347:                  j___0--;
    #####: 3348:                  if (!tmp___29) {
    #####: 3349:                    goto while_break___12;
        -: 3350:                  }
    #####: 3351:                  tmp___28 = i___0;
    #####: 3352:                  i___0++;
    #####: 3353:                  ll[tmp___28] = 0U;
        -: 3354:                }
    #####: 3355:              while_break___12: /* CIL Label */;
        -: 3356:              }
    #####: 3357:              l = 0U;
        -: 3358:            }
        -: 3359:          }
        -: 3360:        }
        -: 3361:      }
    #####: 3362:    while_break___5: /* CIL Label */;
        -: 3363:    }
        -: 3364:    {
    #####: 3365:      huft_free(tl);
    #####: 3366:      bb = b;
    #####: 3367:      bk = k;
    #####: 3368:      bl = lbits;
    #####: 3369:      i___0 = huft_build(ll, nl, 257U, cplens, cplext, &tl, &bl);
        -: 3370:    }
    #####: 3371:    if (i___0 != 0) {
    #####: 3372:      if (i___0 == 1) {
        -: 3373:        {
    #####: 3374:          fprintf(
        -: 3375:              (FILE * /* __restrict  */) stderr,
        -: 3376:              (char const * /* __restrict  */) " incomplete literal tree\n");
    #####: 3377:          huft_free(tl);
        -: 3378:        }
        -: 3379:      }
    #####: 3380:      return (i___0);
        -: 3381:    }
        -: 3382:    {
    #####: 3383:      bd = dbits;
    #####: 3384:      i___0 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, &td, &bd);
        -: 3385:    }
    #####: 3386:    if (i___0 != 0) {
    #####: 3387:      if (i___0 == 1) {
        -: 3388:        {
    #####: 3389:          fprintf(
        -: 3390:              (FILE * /* __restrict  */) stderr,
        -: 3391:              (char const * /* __restrict  */) " incomplete distance tree\n");
    #####: 3392:          huft_free(td);
        -: 3393:        }
        -: 3394:      }
    #####: 3395:      { huft_free(tl); }
    #####: 3396:      return (i___0);
        -: 3397:    }
    #####: 3398:    { tmp___30 = inflate_codes(tl, td, bl, bd); }
    #####: 3399:    if (tmp___30) {
    #####: 3400:      return (1);
        -: 3401:    }
        -: 3402:    {
    #####: 3403:      huft_free(tl);
    #####: 3404:      huft_free(td);
        -: 3405:    }
    #####: 3406:    return (0);
        -: 3407:  }
        -: 3408:}
    #####: 3409:int inflate_block(int *e) {
        -: 3410:  unsigned int t;
        -: 3411:  register ulg b;
        -: 3412:  register unsigned int k;
        -: 3413:  unsigned int tmp;
        -: 3414:  int tmp___0;
        -: 3415:  int tmp___1;
        -: 3416:  unsigned int tmp___2;
        -: 3417:  int tmp___3;
        -: 3418:  int tmp___4;
        -: 3419:  int tmp___5;
        -: 3420:  int tmp___6;
        -: 3421:  int tmp___7;
        -: 3422:
        -: 3423:  {
    #####: 3424:    b = bb;
    #####: 3425:    k = bk;
        -: 3426:    {
        -: 3427:      while (1) {
    #####: 3428:      while_continue: /* CIL Label */;
    #####: 3429:        if (!(k < 1U)) {
    #####: 3430:          goto while_break;
        -: 3431:        }
    #####: 3432:        if (inptr < insize) {
    #####: 3433:          tmp = inptr;
    #####: 3434:          inptr++;
    #####: 3435:          tmp___1 = (int)inbuf[tmp];
        -: 3436:        } else {
        -: 3437:          {
    #####: 3438:            tmp___0 = fill_inbuf(0);
    #####: 3439:            tmp___1 = tmp___0;
        -: 3440:          }
        -: 3441:        }
    #####: 3442:        b |= (ulg)((uch)tmp___1) << k;
    #####: 3443:        k += 8U;
        -: 3444:      }
    #####: 3445:    while_break: /* CIL Label */;
        -: 3446:    }
    #####: 3447:    *e = (int)b & 1;
    #####: 3448:    b >>= 1;
    #####: 3449:    k--;
        -: 3450:    {
        -: 3451:      while (1) {
    #####: 3452:      while_continue___0: /* CIL Label */;
    #####: 3453:        if (!(k < 2U)) {
    #####: 3454:          goto while_break___0;
        -: 3455:        }
    #####: 3456:        if (inptr < insize) {
    #####: 3457:          tmp___2 = inptr;
    #####: 3458:          inptr++;
    #####: 3459:          tmp___4 = (int)inbuf[tmp___2];
        -: 3460:        } else {
        -: 3461:          {
    #####: 3462:            tmp___3 = fill_inbuf(0);
    #####: 3463:            tmp___4 = tmp___3;
        -: 3464:          }
        -: 3465:        }
    #####: 3466:        b |= (ulg)((uch)tmp___4) << k;
    #####: 3467:        k += 8U;
        -: 3468:      }
    #####: 3469:    while_break___0: /* CIL Label */;
        -: 3470:    }
    #####: 3471:    t = (unsigned int)b & 3U;
    #####: 3472:    b >>= 2;
    #####: 3473:    k -= 2U;
    #####: 3474:    bb = b;
    #####: 3475:    bk = k;
    #####: 3476:    if (t == 2U) {
        -: 3477:      {
    #####: 3478:        tmp___5 = inflate_dynamic();
        -: 3479:      }
    #####: 3480:      return (tmp___5);
        -: 3481:    }
    #####: 3482:    if (t == 0U) {
        -: 3483:      {
    #####: 3484:        tmp___6 = inflate_stored();
        -: 3485:      }
    #####: 3486:      return (tmp___6);
        -: 3487:    }
    #####: 3488:    if (t == 1U) {
        -: 3489:      {
    #####: 3490:        tmp___7 = inflate_fixed();
        -: 3491:      }
    #####: 3492:      return (tmp___7);
        -: 3493:    }
    #####: 3494:    return (2);
        -: 3495:  }
        -: 3496:}
    #####: 3497:int inflate(void) {
        -: 3498:  int e;
        -: 3499:  int r;
        -: 3500:  unsigned int h;
        -: 3501:
        -: 3502:  {
    #####: 3503:    outcnt = 0U;
    #####: 3504:    bk = 0U;
    #####: 3505:    bb = (ulg)0;
    #####: 3506:    h = 0U;
        -: 3507:    {
        -: 3508:      while (1) {
    #####: 3509:      while_continue: /* CIL Label */;
        -: 3510:        {
    #####: 3511:          hufts = 0U;
    #####: 3512:          r = inflate_block(&e);
        -: 3513:        }
    #####: 3514:        if (r != 0) {
    #####: 3515:          return (r);
        -: 3516:        }
    #####: 3517:        if (hufts > h) {
    #####: 3518:          h = hufts;
        -: 3519:        }
    #####: 3520:        if (!(!e)) {
    #####: 3521:          goto while_break;
        -: 3522:        }
        -: 3523:      }
    #####: 3524:    while_break: /* CIL Label */;
        -: 3525:    }
        -: 3526:    {
        -: 3527:      while (1) {
    #####: 3528:      while_continue___0: /* CIL Label */;
    #####: 3529:        if (!(bk >= 8U)) {
    #####: 3530:          goto while_break___0;
        -: 3531:        }
    #####: 3532:        bk -= 8U;
    #####: 3533:        inptr--;
        -: 3534:      }
    #####: 3535:    while_break___0: /* CIL Label */;
        -: 3536:    }
        -: 3537:    {
    #####: 3538:      outcnt = outcnt;
    #####: 3539:      flush_window();
        -: 3540:    }
    #####: 3541:    return (0);
        -: 3542:  }
        -: 3543:}
        -: 3544:int method;
        -: 3545:int decrypt;
        -: 3546:int unzip(int in, int out);
        -: 3547:int check_zipfile(int in);
        -: 3548:char *key;
        -: 3549:int pkzip = 0;
        -: 3550:int ext_header = 0;
    #####: 3551:int check_zipfile(int in) {
        -: 3552:  uch *h;
        -: 3553:
        -: 3554:  {
    #####: 3555:    h = inbuf + inptr;
    #####: 3556:    ifd = in;
    #####: 3557:    inptr += (unsigned int)((30 + ((int)((ush) * ((h + 26) + 0)) |
    #####: 3558:                                   ((int)((ush) * ((h + 26) + 1)) << 8))) +
    #####: 3559:                            ((int)((ush) * ((h + 28) + 0)) |
    #####: 3560:                             ((int)((ush) * ((h + 28) + 1)) << 8)));
    #####: 3561:    if (inptr > insize) {
        -: 3562:      {
    #####: 3563:        fprintf(
        -: 3564:            (FILE * /* __restrict  */) stderr,
        -: 3565:            (char const * /* __restrict  */) "\n%s: %s: not a valid zip file\n",
        -: 3566:            progname, ifname);
    #####: 3567:        exit_code = 1;
        -: 3568:      }
    #####: 3569:      return (1);
        -: 3570:    } else {
    #####: 3571:      if (((ulg)((int)((ush) * (h + 0)) | ((int)((ush) * (h + 1)) << 8)) |
    #####: 3572:           ((ulg)((int)((ush) * ((h + 2) + 0)) |
    #####: 3573:                  ((int)((ush) * ((h + 2) + 1)) << 8))
    #####: 3574:            << 16)) != 67324752UL) {
        -: 3575:        {
    #####: 3576:          fprintf((FILE * /* __restrict  */) stderr,
        -: 3577:                  (char const
        -: 3578:                       * /* __restrict  */) "\n%s: %s: not a valid zip file\n",
        -: 3579:                  progname, ifname);
    #####: 3580:          exit_code = 1;
        -: 3581:        }
    #####: 3582:        return (1);
        -: 3583:      }
        -: 3584:    }
    #####: 3585:    method = (int)*(h + 8);
    #####: 3586:    if (method != 0) {
    #####: 3587:      if (method != 8) {
        -: 3588:        {
    #####: 3589:          fprintf((FILE * /* __restrict  */) stderr,
        -: 3590:                  (char const
        -: 3591:                       * /* __restrict  */) "\n%s: %s: first entry not "
        -: 3592:                                            "deflated or stored -- use unzip\n",
        -: 3593:                  progname, ifname);
    #####: 3594:          exit_code = 1;
        -: 3595:        }
    #####: 3596:        return (1);
        -: 3597:      }
        -: 3598:    }
    #####: 3599:    decrypt = (int)*(h + 6) & 1;
    #####: 3600:    if (decrypt != 0) {
        -: 3601:      {
    #####: 3602:        fprintf(
        -: 3603:            (FILE * /* __restrict  */) stderr,
        -: 3604:            (char const
        -: 3605:                 * /* __restrict  */) "\n%s: %s: encrypted file -- use unzip\n",
        -: 3606:            progname, ifname);
    #####: 3607:        exit_code = 1;
        -: 3608:      }
    #####: 3609:      return (1);
        -: 3610:    }
    #####: 3611:    ext_header = ((int)*(h + 6) & 8) != 0;
    #####: 3612:    pkzip = 1;
    #####: 3613:    return (0);
        -: 3614:  }
        -: 3615:}
    #####: 3616:int unzip(int in, int out) {
        -: 3617:  ulg orig_crc;
        -: 3618:  ulg orig_len___0;
        -: 3619:  int n;
        -: 3620:  uch buf[16];
        -: 3621:  int res;
        -: 3622:  int tmp;
        -: 3623:  register ulg n___0;
        -: 3624:  int tmp___0;
        -: 3625:  uch c;
        -: 3626:  unsigned int tmp___1;
        -: 3627:  int tmp___2;
        -: 3628:  int tmp___3;
        -: 3629:  unsigned int tmp___4;
        -: 3630:  ulg tmp___5;
        -: 3631:  unsigned int tmp___6;
        -: 3632:  int tmp___7;
        -: 3633:  int tmp___8;
        -: 3634:  unsigned int tmp___9;
        -: 3635:  int tmp___10;
        -: 3636:  int tmp___11;
        -: 3637:  ulg tmp___12;
        -: 3638:  void *__cil_tmp24;
        -: 3639:  char *__cil_tmp25;
        -: 3640:  char *__cil_tmp26;
        -: 3641:  char *__cil_tmp27;
        -: 3642:  char *__cil_tmp28;
        -: 3643:  char *__cil_tmp29;
        -: 3644:  char *__cil_tmp30;
        -: 3645:  char *__cil_tmp31;
        -: 3646:
        -: 3647:  {
        -: 3648:    {
    #####: 3649:      orig_crc = (ulg)0;
    #####: 3650:      orig_len___0 = (ulg)0;
    #####: 3651:      ifd = in;
    #####: 3652:      ofd = out;
    #####: 3653:      updcrc((uch *)((void *)0), 0U);
        -: 3654:    }
    #####: 3655:    if (pkzip) {
    #####: 3656:      if (!ext_header) {
    #####: 3657:        orig_crc = (ulg)((int)((ush) * ((inbuf + 14) + 0)) |
    #####: 3658:                         ((int)((ush) * ((inbuf + 14) + 1)) << 8)) |
    #####: 3659:                   ((ulg)((int)((ush) * (((inbuf + 14) + 2) + 0)) |
    #####: 3660:                          ((int)((ush) * (((inbuf + 14) + 2) + 1)) << 8))
    #####: 3661:                    << 16);
    #####: 3662:        orig_len___0 = (ulg)((int)((ush) * ((inbuf + 22) + 0)) |
    #####: 3663:                             ((int)((ush) * ((inbuf + 22) + 1)) << 8)) |
    #####: 3664:                       ((ulg)((int)((ush) * (((inbuf + 22) + 2) + 0)) |
    #####: 3665:                              ((int)((ush) * (((inbuf + 22) + 2) + 1)) << 8))
    #####: 3666:                        << 16);
        -: 3667:      }
        -: 3668:    }
    #####: 3669:    if (method == 8) {
        -: 3670:      {
    #####: 3671:        tmp = inflate();
    #####: 3672:        res = tmp;
        -: 3673:      }
    #####: 3674:      if (res == 3) {
        -: 3675:        {
    #####: 3676:          error((char *)"out of memory");
        -: 3677:        }
        -: 3678:      } else {
    #####: 3679:        if (res != 0) {
        -: 3680:          {
    #####: 3681:            error((char *)"invalid compressed data--format violated");
        -: 3682:          }
        -: 3683:        }
        -: 3684:      }
        -: 3685:    } else {
    #####: 3686:      if (pkzip) {
    #####: 3687:        if (method == 0) {
    #####: 3688:          n___0 = (ulg)((int)((ush) * ((inbuf + 22) + 0)) |
    #####: 3689:                        ((int)((ush) * ((inbuf + 22) + 1)) << 8)) |
    #####: 3690:                  ((ulg)((int)((ush) * (((inbuf + 22) + 2) + 0)) |
    #####: 3691:                         ((int)((ush) * (((inbuf + 22) + 2) + 1)) << 8))
    #####: 3692:                   << 16);
    #####: 3693:          if (decrypt) {
    #####: 3694:            tmp___0 = 12;
        -: 3695:          } else {
    #####: 3696:            tmp___0 = 0;
        -: 3697:          }
    #####: 3698:          if (n___0 != ((ulg)((int)((ush) * ((inbuf + 18) + 0)) |
    #####: 3699:                              ((int)((ush) * ((inbuf + 18) + 1)) << 8)) |
    #####: 3700:                        ((ulg)((int)((ush) * (((inbuf + 18) + 2) + 0)) |
    #####: 3701:                               ((int)((ush) * (((inbuf + 18) + 2) + 1)) << 8))
    #####: 3702:                         << 16)) -
    #####: 3703:                           (unsigned long)tmp___0) {
        -: 3704:            {
    #####: 3705:              fprintf((FILE * /* __restrict  */) stderr,
        -: 3706:                      (char const * /* __restrict  */) "len %ld, siz %ld\n",
        -: 3707:                      n___0,
    #####: 3708:                      (ulg)((int)((ush) * ((inbuf + 18) + 0)) |
    #####: 3709:                            ((int)((ush) * ((inbuf + 18) + 1)) << 8)) |
    #####: 3710:                          ((ulg)((int)((ush) * (((inbuf + 18) + 2) + 0)) |
    #####: 3711:                                 ((int)((ush) * (((inbuf + 18) + 2) + 1)) << 8))
    #####: 3712:                           << 16));
    #####: 3713:              error((char *)"invalid compressed data--length mismatch");
        -: 3714:            }
        -: 3715:          }
        -: 3716:          {
        -: 3717:            while (1) {
    #####: 3718:            while_continue: /* CIL Label */;
    #####: 3719:              tmp___5 = n___0;
    #####: 3720:              n___0--;
    #####: 3721:              if (!tmp___5) {
    #####: 3722:                goto while_break;
        -: 3723:              }
    #####: 3724:              if (inptr < insize) {
    #####: 3725:                tmp___1 = inptr;
    #####: 3726:                inptr++;
    #####: 3727:                tmp___3 = (int)inbuf[tmp___1];
        -: 3728:              } else {
        -: 3729:                {
    #####: 3730:                  tmp___2 = fill_inbuf(0);
    #####: 3731:                  tmp___3 = tmp___2;
        -: 3732:                }
        -: 3733:              }
    #####: 3734:              c = (uch)tmp___3;
    #####: 3735:              tmp___4 = outcnt;
    #####: 3736:              outcnt++;
    #####: 3737:              window[tmp___4] = c;
    #####: 3738:              if (outcnt == 32768U) {
        -: 3739:                {
    #####: 3740:                  flush_window();
        -: 3741:                }
        -: 3742:              }
        -: 3743:            }
    #####: 3744:          while_break: /* CIL Label */;
        -: 3745:          }
    #####: 3746:          { flush_window(); }
        -: 3747:        } else {
    #####: 3748:          { error((char *)"internal error, invalid method"); }
        -: 3749:        }
        -: 3750:      } else {
    #####: 3751:        { error((char *)"internal error, invalid method"); }
        -: 3752:      }
        -: 3753:    }
    #####: 3754:    if (!pkzip) {
    #####: 3755:      n = 0;
        -: 3756:      {
        -: 3757:        while (1) {
    #####: 3758:        while_continue___0: /* CIL Label */;
    #####: 3759:          if (!(n < 8)) {
    #####: 3760:            goto while_break___0;
        -: 3761:          }
    #####: 3762:          if (inptr < insize) {
    #####: 3763:            tmp___6 = inptr;
    #####: 3764:            inptr++;
    #####: 3765:            tmp___8 = (int)inbuf[tmp___6];
        -: 3766:          } else {
        -: 3767:            {
    #####: 3768:              tmp___7 = fill_inbuf(0);
    #####: 3769:              tmp___8 = tmp___7;
        -: 3770:            }
        -: 3771:          }
    #####: 3772:          buf[n] = (uch)tmp___8;
    #####: 3773:          n++;
        -: 3774:        }
    #####: 3775:      while_break___0: /* CIL Label */;
        -: 3776:      }
    #####: 3777:      orig_crc = (ulg)((int)((ush)buf[0]) | ((int)((ush)buf[1]) << 8)) |
    #####: 3778:                 ((ulg)((int)((ush) * ((buf + 2) + 0)) |
    #####: 3779:                        ((int)((ush) * ((buf + 2) + 1)) << 8))
    #####: 3780:                  << 16);
    #####: 3781:      orig_len___0 = (ulg)((int)((ush) * ((buf + 4) + 0)) |
    #####: 3782:                           ((int)((ush) * ((buf + 4) + 1)) << 8)) |
    #####: 3783:                     ((ulg)((int)((ush) * (((buf + 4) + 2) + 0)) |
    #####: 3784:                            ((int)((ush) * (((buf + 4) + 2) + 1)) << 8))
    #####: 3785:                      << 16);
        -: 3786:    } else {
    #####: 3787:      if (ext_header) {
    #####: 3788:        n = 0;
        -: 3789:        {
        -: 3790:          while (1) {
    #####: 3791:          while_continue___1: /* CIL Label */;
    #####: 3792:            if (!(n < 16)) {
    #####: 3793:              goto while_break___1;
        -: 3794:            }
    #####: 3795:            if (inptr < insize) {
    #####: 3796:              tmp___9 = inptr;
    #####: 3797:              inptr++;
    #####: 3798:              tmp___11 = (int)inbuf[tmp___9];
        -: 3799:            } else {
        -: 3800:              {
    #####: 3801:                tmp___10 = fill_inbuf(0);
    #####: 3802:                tmp___11 = tmp___10;
        -: 3803:              }
        -: 3804:            }
    #####: 3805:            buf[n] = (uch)tmp___11;
    #####: 3806:            n++;
        -: 3807:          }
    #####: 3808:        while_break___1: /* CIL Label */;
        -: 3809:        }
    #####: 3810:        orig_crc = (ulg)((int)((ush) * ((buf + 4) + 0)) |
    #####: 3811:                         ((int)((ush) * ((buf + 4) + 1)) << 8)) |
    #####: 3812:                   ((ulg)((int)((ush) * (((buf + 4) + 2) + 0)) |
    #####: 3813:                          ((int)((ush) * (((buf + 4) + 2) + 1)) << 8))
    #####: 3814:                    << 16);
    #####: 3815:        orig_len___0 = (ulg)((int)((ush) * ((buf + 12) + 0)) |
    #####: 3816:                             ((int)((ush) * ((buf + 12) + 1)) << 8)) |
    #####: 3817:                       ((ulg)((int)((ush) * (((buf + 12) + 2) + 0)) |
    #####: 3818:                              ((int)((ush) * (((buf + 12) + 2) + 1)) << 8))
    #####: 3819:                        << 16);
        -: 3820:      }
        -: 3821:    }
    #####: 3822:    { tmp___12 = updcrc(outbuf, 0U); }
    #####: 3823:    if (orig_crc != tmp___12) {
        -: 3824:      {
    #####: 3825:        error((char *)"invalid compressed data--crc error");
        -: 3826:      }
        -: 3827:    }
    #####: 3828:    if (orig_len___0 != (ulg)bytes_out) {
        -: 3829:      {
    #####: 3830:        error((char *)"invalid compressed data--length error");
        -: 3831:      }
        -: 3832:    }
    #####: 3833:    if (pkzip) {
    #####: 3834:      if (inptr + 4U < insize) {
    #####: 3835:        if (((ulg)((int)((ush) * ((inbuf + inptr) + 0)) |
    #####: 3836:                   ((int)((ush) * ((inbuf + inptr) + 1)) << 8)) |
    #####: 3837:             ((ulg)((int)((ush) * (((inbuf + inptr) + 2) + 0)) |
    #####: 3838:                    ((int)((ush) * (((inbuf + inptr) + 2) + 1)) << 8))
    #####: 3839:              << 16)) == 67324752UL) {
    #####: 3840:          if (to_stdout) {
    #####: 3841:            if (!quiet) {
        -: 3842:              {
    #####: 3843:                fprintf(
        -: 3844:                    (FILE * /* __restrict  */) stderr,
        -: 3845:                    (char const * /* __restrict  */) "%s: %s has more than one "
        -: 3846:                                                     "entry--rest ignored\n",
        -: 3847:                    progname, ifname);
        -: 3848:              }
        -: 3849:            }
    #####: 3850:            if (exit_code == 0) {
    #####: 3851:              exit_code = 2;
        -: 3852:            }
        -: 3853:          } else {
        -: 3854:            {
    #####: 3855:              fprintf(
        -: 3856:                  (FILE * /* __restrict  */) stderr,
        -: 3857:                  (char const * /* __restrict  */) "%s: %s has more than one "
        -: 3858:                                                   "entry -- unchanged\n",
        -: 3859:                  progname, ifname);
    #####: 3860:              exit_code = 1;
    #####: 3861:              pkzip = 0;
    #####: 3862:              ext_header = pkzip;
        -: 3863:            }
    #####: 3864:            return (1);
        -: 3865:          }
        -: 3866:        }
        -: 3867:      }
        -: 3868:    }
    #####: 3869:    pkzip = 0;
    #####: 3870:    ext_header = pkzip;
    #####: 3871:    return (0);
        -: 3872:  }
        -: 3873:}
        -: 3874:int file_read(char *buf, unsigned int size);
        -: 3875:void bi_init(file_t zipfile);
        -: 3876:void send_bits(int value, int length);
        -: 3877:unsigned int bi_reverse(unsigned int code, int len);
        -: 3878:void bi_windup(void);
        -: 3879:void copy_block(char *buf, unsigned int len, int header);
        -: 3880:int (*read_buf)(char *buf, unsigned int size);
        -: 3881:static file_t zfile;
        -: 3882:static unsigned short bi_buf;
        -: 3883:static int bi_valid;
    #####: 3884:void bi_init(file_t zipfile) {
        -: 3885:
        -: 3886:  {
    #####: 3887:    zfile = zipfile;
    #####: 3888:    bi_buf = (unsigned short)0;
    #####: 3889:    bi_valid = 0;
    #####: 3890:    if (zfile != -1) {
    #####: 3891:      read_buf = &file_read;
        -: 3892:    }
    #####: 3893:    return;
        -: 3894:  }
        -: 3895:}
    #####: 3896:void send_bits(int value, int length) {
        -: 3897:  unsigned int tmp;
        -: 3898:  unsigned int tmp___0;
        -: 3899:  unsigned int tmp___1;
        -: 3900:  unsigned int tmp___2;
        -: 3901:
        -: 3902:  {
    #####: 3903:    if (bi_valid > (int)(16UL * sizeof(char)) - length) {
    #####: 3904:      bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    #####: 3905:      if (outcnt < 16382U) {
    #####: 3906:        tmp = outcnt;
    #####: 3907:        outcnt++;
    #####: 3908:        outbuf[tmp] = (uch)((int)bi_buf & 255);
    #####: 3909:        tmp___0 = outcnt;
    #####: 3910:        outcnt++;
    #####: 3911:        outbuf[tmp___0] = (uch)((int)bi_buf >> 8);
        -: 3912:      } else {
    #####: 3913:        tmp___1 = outcnt;
    #####: 3914:        outcnt++;
    #####: 3915:        outbuf[tmp___1] = (uch)((int)bi_buf & 255);
    #####: 3916:        if (outcnt == 16384U) {
        -: 3917:          {
    #####: 3918:            flush_outbuf();
        -: 3919:          }
        -: 3920:        }
    #####: 3921:        tmp___2 = outcnt;
    #####: 3922:        outcnt++;
    #####: 3923:        outbuf[tmp___2] = (uch)((int)bi_buf >> 8);
    #####: 3924:        if (outcnt == 16384U) {
        -: 3925:          {
    #####: 3926:            flush_outbuf();
        -: 3927:          }
        -: 3928:        }
        -: 3929:      }
    #####: 3930:      bi_buf = (unsigned short)((int)((ush)value) >> (16UL * sizeof(char) -
        -: 3931:                                                      (unsigned long)bi_valid));
    #####: 3932:      bi_valid = (int)((unsigned long)bi_valid +
        -: 3933:                       ((unsigned long)length - 16UL * sizeof(char)));
        -: 3934:    } else {
    #####: 3935:      bi_buf = (unsigned short)((int)bi_buf | (value << bi_valid));
    #####: 3936:      bi_valid += length;
        -: 3937:    }
    #####: 3938:    return;
        -: 3939:  }
        -: 3940:}
    #####: 3941:unsigned int bi_reverse(unsigned int code, int len) {
        -: 3942:  register unsigned int res;
        -: 3943:
        -: 3944:  {
    #####: 3945:    res = 0U;
        -: 3946:    {
        -: 3947:      while (1) {
    #####: 3948:      while_continue: /* CIL Label */;
    #####: 3949:        res |= code & 1U;
    #####: 3950:        code >>= 1;
    #####: 3951:        res <<= 1;
    #####: 3952:        len--;
    #####: 3953:        if (!(len > 0)) {
    #####: 3954:          goto while_break;
        -: 3955:        }
        -: 3956:      }
    #####: 3957:    while_break: /* CIL Label */;
        -: 3958:    }
    #####: 3959:    return (res >> 1);
        -: 3960:  }
        -: 3961:}
    #####: 3962:void bi_windup(void) {
        -: 3963:  unsigned int tmp;
        -: 3964:  unsigned int tmp___0;
        -: 3965:  unsigned int tmp___1;
        -: 3966:  unsigned int tmp___2;
        -: 3967:  unsigned int tmp___3;
        -: 3968:
        -: 3969:  {
    #####: 3970:    if (bi_valid > 8) {
    #####: 3971:      if (outcnt < 16382U) {
    #####: 3972:        tmp = outcnt;
    #####: 3973:        outcnt++;
    #####: 3974:        outbuf[tmp] = (uch)((int)bi_buf & 255);
    #####: 3975:        tmp___0 = outcnt;
    #####: 3976:        outcnt++;
    #####: 3977:        outbuf[tmp___0] = (uch)((int)bi_buf >> 8);
        -: 3978:      } else {
    #####: 3979:        tmp___1 = outcnt;
    #####: 3980:        outcnt++;
    #####: 3981:        outbuf[tmp___1] = (uch)((int)bi_buf & 255);
    #####: 3982:        if (outcnt == 16384U) {
        -: 3983:          {
    #####: 3984:            flush_outbuf();
        -: 3985:          }
        -: 3986:        }
    #####: 3987:        tmp___2 = outcnt;
    #####: 3988:        outcnt++;
    #####: 3989:        outbuf[tmp___2] = (uch)((int)bi_buf >> 8);
    #####: 3990:        if (outcnt == 16384U) {
        -: 3991:          {
    #####: 3992:            flush_outbuf();
        -: 3993:          }
        -: 3994:        }
        -: 3995:      }
        -: 3996:    } else {
    #####: 3997:      if (bi_valid > 0) {
    #####: 3998:        tmp___3 = outcnt;
    #####: 3999:        outcnt++;
    #####: 4000:        outbuf[tmp___3] = (uch)bi_buf;
    #####: 4001:        if (outcnt == 16384U) {
        -: 4002:          {
    #####: 4003:            flush_outbuf();
        -: 4004:          }
        -: 4005:        }
        -: 4006:      }
        -: 4007:    }
    #####: 4008:    bi_buf = (unsigned short)0;
    #####: 4009:    bi_valid = 0;
    #####: 4010:    return;
        -: 4011:  }
        -: 4012:}
    #####: 4013:void copy_block(char *buf, unsigned int len, int header) {
        -: 4014:  unsigned int tmp;
        -: 4015:  unsigned int tmp___0;
        -: 4016:  unsigned int tmp___1;
        -: 4017:  unsigned int tmp___2;
        -: 4018:  unsigned int tmp___3;
        -: 4019:  unsigned int tmp___4;
        -: 4020:  unsigned int tmp___5;
        -: 4021:  unsigned int tmp___6;
        -: 4022:  unsigned int tmp___7;
        -: 4023:  char *tmp___8;
        -: 4024:  unsigned int tmp___9;
        -: 4025:
        -: 4026:  {
    #####: 4027:    { bi_windup(); }
    #####: 4028:    if (header) {
    #####: 4029:      if (outcnt < 16382U) {
    #####: 4030:        tmp = outcnt;
    #####: 4031:        outcnt++;
    #####: 4032:        outbuf[tmp] = (uch)((int)((ush)len) & 255);
    #####: 4033:        tmp___0 = outcnt;
    #####: 4034:        outcnt++;
    #####: 4035:        outbuf[tmp___0] = (uch)((int)((ush)len) >> 8);
        -: 4036:      } else {
    #####: 4037:        tmp___1 = outcnt;
    #####: 4038:        outcnt++;
    #####: 4039:        outbuf[tmp___1] = (uch)((int)((ush)len) & 255);
    #####: 4040:        if (outcnt == 16384U) {
        -: 4041:          {
    #####: 4042:            flush_outbuf();
        -: 4043:          }
        -: 4044:        }
    #####: 4045:        tmp___2 = outcnt;
    #####: 4046:        outcnt++;
    #####: 4047:        outbuf[tmp___2] = (uch)((int)((ush)len) >> 8);
    #####: 4048:        if (outcnt == 16384U) {
        -: 4049:          {
    #####: 4050:            flush_outbuf();
        -: 4051:          }
        -: 4052:        }
        -: 4053:      }
    #####: 4054:      if (outcnt < 16382U) {
    #####: 4055:        tmp___3 = outcnt;
    #####: 4056:        outcnt++;
    #####: 4057:        outbuf[tmp___3] = (uch)((int)((ush)(~len)) & 255);
    #####: 4058:        tmp___4 = outcnt;
    #####: 4059:        outcnt++;
    #####: 4060:        outbuf[tmp___4] = (uch)((int)((ush)(~len)) >> 8);
        -: 4061:      } else {
    #####: 4062:        tmp___5 = outcnt;
    #####: 4063:        outcnt++;
    #####: 4064:        outbuf[tmp___5] = (uch)((int)((ush)(~len)) & 255);
    #####: 4065:        if (outcnt == 16384U) {
        -: 4066:          {
    #####: 4067:            flush_outbuf();
        -: 4068:          }
        -: 4069:        }
    #####: 4070:        tmp___6 = outcnt;
    #####: 4071:        outcnt++;
    #####: 4072:        outbuf[tmp___6] = (uch)((int)((ush)(~len)) >> 8);
    #####: 4073:        if (outcnt == 16384U) {
        -: 4074:          {
    #####: 4075:            flush_outbuf();
        -: 4076:          }
        -: 4077:        }
        -: 4078:      }
        -: 4079:    }
        -: 4080:    {
        -: 4081:      while (1) {
    #####: 4082:      while_continue: /* CIL Label */;
    #####: 4083:        tmp___9 = len;
    #####: 4084:        len--;
    #####: 4085:        if (!tmp___9) {
    #####: 4086:          goto while_break;
        -: 4087:        }
    #####: 4088:        tmp___7 = outcnt;
    #####: 4089:        outcnt++;
    #####: 4090:        tmp___8 = buf;
    #####: 4091:        buf++;
    #####: 4092:        outbuf[tmp___7] = (uch)*tmp___8;
    #####: 4093:        if (outcnt == 16384U) {
        -: 4094:          {
    #####: 4095:            flush_outbuf();
        -: 4096:          }
        -: 4097:        }
        -: 4098:      }
    #####: 4099:    while_break: /* CIL Label */;
        -: 4100:    }
    #####: 4101:    return;
        -: 4102:  }
        -: 4103:}
        -: 4104:int level;
        -: 4105:void ct_init(ush *attr, int *methodp);
        -: 4106:int ct_tally(int dist, int lc);
        -: 4107:ulg flush_block(char *buf, ulg stored_len, int eof);
        -: 4108:static int extra_lbits[29] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2,
        -: 4109:                              2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0};
        -: 4110:static int extra_dbits[30] = {0, 0, 0,  0,  1,  1,  2,  2,  3,  3,
        -: 4111:                              4, 4, 5,  5,  6,  6,  7,  7,  8,  8,
        -: 4112:                              9, 9, 10, 10, 11, 11, 12, 12, 13, 13};
        -: 4113:static int extra_blbits[19] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -: 4114:                               0, 0, 0, 0, 0, 0, 2, 3, 7};
        -: 4115:static ct_data dyn_ltree[573];
        -: 4116:static ct_data dyn_dtree[61];
        -: 4117:static ct_data static_ltree[288];
        -: 4118:static ct_data static_dtree[30];
        -: 4119:static ct_data bl_tree[39];
        -: 4120:static tree_desc l_desc = {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15,
        -: 4121:                           0};
        -: 4122:static tree_desc d_desc = {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
        -: 4123:static tree_desc bl_desc = {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
        -: 4124:static ush bl_count[16];
        -: 4125:static uch bl_order[19] = {(uch)16, (uch)17, (uch)18, (uch)0,  (uch)8,
        -: 4126:                           (uch)7,  (uch)9,  (uch)6,  (uch)10, (uch)5,
        -: 4127:                           (uch)11, (uch)4,  (uch)12, (uch)3,  (uch)13,
        -: 4128:                           (uch)2,  (uch)14, (uch)1,  (uch)15};
        -: 4129:static int heap[573];
        -: 4130:static int heap_len;
        -: 4131:static int heap_max;
        -: 4132:static uch depth[573];
        -: 4133:static uch length_code[256];
        -: 4134:static uch dist_code[512];
        -: 4135:static int base_length[29];
        -: 4136:static int base_dist[30];
        -: 4137:static uch flag_buf[4096];
        -: 4138:static unsigned int last_lit;
        -: 4139:static unsigned int last_dist;
        -: 4140:static unsigned int last_flags;
        -: 4141:static uch flags;
        -: 4142:static uch flag_bit;
        -: 4143:static ulg opt_len;
        -: 4144:static ulg static_len;
        -: 4145:static ulg compressed_len;
        -: 4146:static ulg input_len;
        -: 4147:ush *file_type;
        -: 4148:int *file_method;
        -: 4149:long block_start;
        -: 4150:unsigned int strstart;
        -: 4151:static void init_block(void);
        -: 4152:static void pqdownheap(ct_data *tree, int k);
        -: 4153:static void gen_bitlen(tree_desc *desc);
        -: 4154:static void gen_codes(ct_data *tree, int max_code);
        -: 4155:static void build_tree___0(tree_desc *desc);
        -: 4156:static void scan_tree(ct_data *tree, int max_code);
        -: 4157:static void send_tree(ct_data *tree, int max_code);
        -: 4158:static int build_bl_tree(void);
        -: 4159:static void send_all_trees(int lcodes, int dcodes, int blcodes);
        -: 4160:static void compress_block(ct_data *ltree, ct_data *dtree);
        -: 4161:static void set_file_type(void);
    #####: 4162:void ct_init(ush *attr, int *methodp) {
        -: 4163:  int n;
        -: 4164:  int bits;
        -: 4165:  int length;
        -: 4166:  int code;
        -: 4167:  int dist;
        -: 4168:  int tmp;
        -: 4169:  int tmp___0;
        -: 4170:  int tmp___1;
        -: 4171:  int tmp___2;
        -: 4172:  int tmp___3;
        -: 4173:  int tmp___4;
        -: 4174:  int tmp___5;
        -: 4175:
        -: 4176:  {
    #####: 4177:    file_type = attr;
    #####: 4178:    file_method = methodp;
    #####: 4179:    input_len = (ulg)0L;
    #####: 4180:    compressed_len = input_len;
    #####: 4181:    if ((int)static_dtree[0].dl.len != 0) {
    #####: 4182:      return;
        -: 4183:    }
    #####: 4184:    length = 0;
    #####: 4185:    code = 0;
        -: 4186:    {
        -: 4187:      while (1) {
    #####: 4188:      while_continue: /* CIL Label */;
    #####: 4189:        if (!(code < 28)) {
    #####: 4190:          goto while_break;
        -: 4191:        }
    #####: 4192:        base_length[code] = length;
    #####: 4193:        n = 0;
        -: 4194:        {
        -: 4195:          while (1) {
    #####: 4196:          while_continue___0: /* CIL Label */;
    #####: 4197:            if (!(n < 1 << extra_lbits[code])) {
    #####: 4198:              goto while_break___0;
        -: 4199:            }
    #####: 4200:            tmp = length;
    #####: 4201:            length++;
    #####: 4202:            length_code[tmp] = (uch)code;
    #####: 4203:            n++;
        -: 4204:          }
    #####: 4205:        while_break___0: /* CIL Label */;
        -: 4206:        }
    #####: 4207:        code++;
        -: 4208:      }
    #####: 4209:    while_break: /* CIL Label */;
        -: 4210:    }
    #####: 4211:    length_code[length - 1] = (uch)code;
    #####: 4212:    dist = 0;
    #####: 4213:    code = 0;
        -: 4214:    {
        -: 4215:      while (1) {
    #####: 4216:      while_continue___1: /* CIL Label */;
    #####: 4217:        if (!(code < 16)) {
    #####: 4218:          goto while_break___1;
        -: 4219:        }
    #####: 4220:        base_dist[code] = dist;
    #####: 4221:        n = 0;
        -: 4222:        {
        -: 4223:          while (1) {
    #####: 4224:          while_continue___2: /* CIL Label */;
    #####: 4225:            if (!(n < 1 << extra_dbits[code])) {
    #####: 4226:              goto while_break___2;
        -: 4227:            }
    #####: 4228:            tmp___0 = dist;
    #####: 4229:            dist++;
    #####: 4230:            dist_code[tmp___0] = (uch)code;
    #####: 4231:            n++;
        -: 4232:          }
    #####: 4233:        while_break___2: /* CIL Label */;
        -: 4234:        }
    #####: 4235:        code++;
        -: 4236:      }
    #####: 4237:    while_break___1: /* CIL Label */;
        -: 4238:    }
    #####: 4239:    dist >>= 7;
        -: 4240:    {
        -: 4241:      while (1) {
    #####: 4242:      while_continue___3: /* CIL Label */;
    #####: 4243:        if (!(code < 30)) {
    #####: 4244:          goto while_break___3;
        -: 4245:        }
    #####: 4246:        base_dist[code] = dist << 7;
    #####: 4247:        n = 0;
        -: 4248:        {
        -: 4249:          while (1) {
    #####: 4250:          while_continue___4: /* CIL Label */;
    #####: 4251:            if (!(n < 1 << (extra_dbits[code] - 7))) {
    #####: 4252:              goto while_break___4;
        -: 4253:            }
    #####: 4254:            tmp___1 = dist;
    #####: 4255:            dist++;
    #####: 4256:            dist_code[256 + tmp___1] = (uch)code;
    #####: 4257:            n++;
        -: 4258:          }
    #####: 4259:        while_break___4: /* CIL Label */;
        -: 4260:        }
    #####: 4261:        code++;
        -: 4262:      }
    #####: 4263:    while_break___3: /* CIL Label */;
        -: 4264:    }
    #####: 4265:    bits = 0;
        -: 4266:    {
        -: 4267:      while (1) {
    #####: 4268:      while_continue___5: /* CIL Label */;
    #####: 4269:        if (!(bits <= 15)) {
    #####: 4270:          goto while_break___5;
        -: 4271:        }
    #####: 4272:        bl_count[bits] = (ush)0;
    #####: 4273:        bits++;
        -: 4274:      }
    #####: 4275:    while_break___5: /* CIL Label */;
        -: 4276:    }
    #####: 4277:    n = 0;
        -: 4278:    {
        -: 4279:      while (1) {
    #####: 4280:      while_continue___6: /* CIL Label */;
    #####: 4281:        if (!(n <= 143)) {
    #####: 4282:          goto while_break___6;
        -: 4283:        }
    #####: 4284:        tmp___2 = n;
    #####: 4285:        n++;
    #####: 4286:        static_ltree[tmp___2].dl.len = (ush)8;
    #####: 4287:        bl_count[8] = (ush)((int)bl_count[8] + 1);
        -: 4288:      }
    #####: 4289:    while_break___6: /* CIL Label */;
        -: 4290:    }
        -: 4291:    {
        -: 4292:      while (1) {
    #####: 4293:      while_continue___7: /* CIL Label */;
    #####: 4294:        if (!(n <= 255)) {
    #####: 4295:          goto while_break___7;
        -: 4296:        }
    #####: 4297:        tmp___3 = n;
    #####: 4298:        n++;
    #####: 4299:        static_ltree[tmp___3].dl.len = (ush)9;
    #####: 4300:        bl_count[9] = (ush)((int)bl_count[9] + 1);
        -: 4301:      }
    #####: 4302:    while_break___7: /* CIL Label */;
        -: 4303:    }
        -: 4304:    {
        -: 4305:      while (1) {
    #####: 4306:      while_continue___8: /* CIL Label */;
    #####: 4307:        if (!(n <= 279)) {
    #####: 4308:          goto while_break___8;
        -: 4309:        }
    #####: 4310:        tmp___4 = n;
    #####: 4311:        n++;
    #####: 4312:        static_ltree[tmp___4].dl.len = (ush)7;
    #####: 4313:        bl_count[7] = (ush)((int)bl_count[7] + 1);
        -: 4314:      }
    #####: 4315:    while_break___8: /* CIL Label */;
        -: 4316:    }
        -: 4317:    {
        -: 4318:      while (1) {
    #####: 4319:      while_continue___9: /* CIL Label */;
    #####: 4320:        if (!(n <= 287)) {
    #####: 4321:          goto while_break___9;
        -: 4322:        }
    #####: 4323:        tmp___5 = n;
    #####: 4324:        n++;
    #####: 4325:        static_ltree[tmp___5].dl.len = (ush)8;
    #####: 4326:        bl_count[8] = (ush)((int)bl_count[8] + 1);
        -: 4327:      }
    #####: 4328:    while_break___9: /* CIL Label */;
        -: 4329:    }
        -: 4330:    {
    #####: 4331:      gen_codes(static_ltree, 287);
    #####: 4332:      n = 0;
        -: 4333:    }
        -: 4334:    {
        -: 4335:      while (1) {
    #####: 4336:      while_continue___10: /* CIL Label */;
    #####: 4337:        if (!(n < 30)) {
    #####: 4338:          goto while_break___10;
        -: 4339:        }
        -: 4340:        {
    #####: 4341:          static_dtree[n].dl.len = (ush)5;
    #####: 4342:          static_dtree[n].fc.code = (ush)bi_reverse((unsigned int)n, 5);
    #####: 4343:          n++;
        -: 4344:        }
        -: 4345:      }
    #####: 4346:    while_break___10: /* CIL Label */;
        -: 4347:    }
    #####: 4348:    { init_block(); }
    #####: 4349:    return;
        -: 4350:  }
        -: 4351:}
    #####: 4352:static void init_block(void) {
        -: 4353:  int n;
        -: 4354:
        -: 4355:  {
    #####: 4356:    n = 0;
        -: 4357:    {
        -: 4358:      while (1) {
    #####: 4359:      while_continue: /* CIL Label */;
    #####: 4360:        if (!(n < 286)) {
    #####: 4361:          goto while_break;
        -: 4362:        }
    #####: 4363:        dyn_ltree[n].fc.freq = (ush)0;
    #####: 4364:        n++;
        -: 4365:      }
    #####: 4366:    while_break: /* CIL Label */;
        -: 4367:    }
    #####: 4368:    n = 0;
        -: 4369:    {
        -: 4370:      while (1) {
    #####: 4371:      while_continue___0: /* CIL Label */;
    #####: 4372:        if (!(n < 30)) {
    #####: 4373:          goto while_break___0;
        -: 4374:        }
    #####: 4375:        dyn_dtree[n].fc.freq = (ush)0;
    #####: 4376:        n++;
        -: 4377:      }
    #####: 4378:    while_break___0: /* CIL Label */;
        -: 4379:    }
    #####: 4380:    n = 0;
        -: 4381:    {
        -: 4382:      while (1) {
    #####: 4383:      while_continue___1: /* CIL Label */;
    #####: 4384:        if (!(n < 19)) {
    #####: 4385:          goto while_break___1;
        -: 4386:        }
    #####: 4387:        bl_tree[n].fc.freq = (ush)0;
    #####: 4388:        n++;
        -: 4389:      }
    #####: 4390:    while_break___1: /* CIL Label */;
        -: 4391:    }
    #####: 4392:    dyn_ltree[256].fc.freq = (ush)1;
    #####: 4393:    static_len = (ulg)0L;
    #####: 4394:    opt_len = static_len;
    #####: 4395:    last_flags = 0U;
    #####: 4396:    last_dist = last_flags;
    #####: 4397:    last_lit = last_dist;
    #####: 4398:    flags = (uch)0;
    #####: 4399:    flag_bit = (uch)1;
    #####: 4400:    return;
        -: 4401:  }
        -: 4402:}
    #####: 4403:static void pqdownheap(ct_data *tree, int k) {
        -: 4404:  int v;
        -: 4405:  int j___0;
        -: 4406:
        -: 4407:  {
    #####: 4408:    v = heap[k];
    #####: 4409:    j___0 = k << 1;
        -: 4410:    {
        -: 4411:      while (1) {
    #####: 4412:      while_continue: /* CIL Label */;
    #####: 4413:        if (!(j___0 <= heap_len)) {
    #####: 4414:          goto while_break;
        -: 4415:        }
    #####: 4416:        if (j___0 < heap_len) {
    #####: 4417:          if ((int)(tree + heap[j___0 + 1])->fc.freq <
    #####: 4418:              (int)(tree + heap[j___0])->fc.freq) {
    #####: 4419:            j___0++;
        -: 4420:          } else {
    #####: 4421:            if ((int)(tree + heap[j___0 + 1])->fc.freq ==
    #####: 4422:                (int)(tree + heap[j___0])->fc.freq) {
    #####: 4423:              if ((int)depth[heap[j___0 + 1]] <= (int)depth[heap[j___0]]) {
    #####: 4424:                j___0++;
        -: 4425:              }
        -: 4426:            }
        -: 4427:          }
        -: 4428:        }
    #####: 4429:        if ((int)(tree + v)->fc.freq < (int)(tree + heap[j___0])->fc.freq) {
    #####: 4430:          goto while_break;
        -: 4431:        } else {
    #####: 4432:          if ((int)(tree + v)->fc.freq == (int)(tree + heap[j___0])->fc.freq) {
    #####: 4433:            if ((int)depth[v] <= (int)depth[heap[j___0]]) {
    #####: 4434:              goto while_break;
        -: 4435:            }
        -: 4436:          }
        -: 4437:        }
    #####: 4438:        heap[k] = heap[j___0];
    #####: 4439:        k = j___0;
    #####: 4440:        j___0 <<= 1;
        -: 4441:      }
    #####: 4442:    while_break: /* CIL Label */;
        -: 4443:    }
    #####: 4444:    heap[k] = v;
    #####: 4445:    return;
        -: 4446:  }
        -: 4447:}
    #####: 4448:static void gen_bitlen(tree_desc *desc) {
        -: 4449:  ct_data *tree;
        -: 4450:  int *extra;
        -: 4451:  int base;
        -: 4452:  int max_code;
        -: 4453:  int max_length;
        -: 4454:  ct_data *stree;
        -: 4455:  int h;
        -: 4456:  int n;
        -: 4457:  int m;
        -: 4458:  int bits;
        -: 4459:  int xbits;
        -: 4460:  ush f;
        -: 4461:  int overflow;
        -: 4462:
        -: 4463:  {
    #####: 4464:    tree = desc->dyn_tree;
    #####: 4465:    extra = desc->extra_bits;
    #####: 4466:    base = desc->extra_base;
    #####: 4467:    max_code = desc->max_code;
    #####: 4468:    max_length = desc->max_length;
    #####: 4469:    stree = desc->static_tree;
    #####: 4470:    overflow = 0;
    #####: 4471:    bits = 0;
        -: 4472:    {
        -: 4473:      while (1) {
    #####: 4474:      while_continue: /* CIL Label */;
    #####: 4475:        if (!(bits <= 15)) {
    #####: 4476:          goto while_break;
        -: 4477:        }
    #####: 4478:        bl_count[bits] = (ush)0;
    #####: 4479:        bits++;
        -: 4480:      }
    #####: 4481:    while_break: /* CIL Label */;
        -: 4482:    }
    #####: 4483:    (tree + heap[heap_max])->dl.len = (ush)0;
    #####: 4484:    h = heap_max + 1;
        -: 4485:    {
        -: 4486:      while (1) {
    #####: 4487:      while_continue___0: /* CIL Label */;
    #####: 4488:        if (!(h < 573)) {
    #####: 4489:          goto while_break___0;
        -: 4490:        }
    #####: 4491:        n = heap[h];
    #####: 4492:        bits = (int)(tree + (int)(tree + n)->dl.dad)->dl.len + 1;
    #####: 4493:        if (bits > max_length) {
    #####: 4494:          bits = max_length;
    #####: 4495:          overflow++;
        -: 4496:        }
    #####: 4497:        (tree + n)->dl.len = (ush)bits;
    #####: 4498:        if (n > max_code) {
    #####: 4499:          goto __Cont;
        -: 4500:        }
    #####: 4501:        bl_count[bits] = (ush)((int)bl_count[bits] + 1);
    #####: 4502:        xbits = 0;
    #####: 4503:        if (n >= base) {
    #####: 4504:          xbits = *(extra + (n - base));
        -: 4505:        }
    #####: 4506:        f = (tree + n)->fc.freq;
    #####: 4507:        opt_len += (ulg)f * (ulg)(bits + xbits);
    #####: 4508:        if (stree) {
    #####: 4509:          static_len += (ulg)f * (ulg)((int)(stree + n)->dl.len + xbits);
        -: 4510:        }
    #####: 4511:      __Cont:
    #####: 4512:        h++;
        -: 4513:      }
    #####: 4514:    while_break___0: /* CIL Label */;
        -: 4515:    }
    #####: 4516:    if (overflow == 0) {
    #####: 4517:      return;
        -: 4518:    }
        -: 4519:    {
        -: 4520:      while (1) {
    #####: 4521:      while_continue___1: /* CIL Label */;
    #####: 4522:        bits = max_length - 1;
        -: 4523:        {
        -: 4524:          while (1) {
    #####: 4525:          while_continue___2: /* CIL Label */;
    #####: 4526:            if (!((int)bl_count[bits] == 0)) {
    #####: 4527:              goto while_break___2;
        -: 4528:            }
    #####: 4529:            bits--;
        -: 4530:          }
    #####: 4531:        while_break___2: /* CIL Label */;
        -: 4532:        }
    #####: 4533:        bl_count[bits] = (ush)((int)bl_count[bits] - 1);
    #####: 4534:        bl_count[bits + 1] = (ush)((int)bl_count[bits + 1] + 2);
    #####: 4535:        bl_count[max_length] = (ush)((int)bl_count[max_length] - 1);
    #####: 4536:        overflow -= 2;
    #####: 4537:        if (!(overflow > 0)) {
    #####: 4538:          goto while_break___1;
        -: 4539:        }
        -: 4540:      }
    #####: 4541:    while_break___1: /* CIL Label */;
        -: 4542:    }
    #####: 4543:    bits = max_length;
        -: 4544:    {
        -: 4545:      while (1) {
    #####: 4546:      while_continue___3: /* CIL Label */;
    #####: 4547:        if (!(bits != 0)) {
    #####: 4548:          goto while_break___3;
        -: 4549:        }
    #####: 4550:        n = (int)bl_count[bits];
        -: 4551:        {
        -: 4552:          while (1) {
    #####: 4553:          while_continue___4: /* CIL Label */;
    #####: 4554:            if (!(n != 0)) {
    #####: 4555:              goto while_break___4;
        -: 4556:            }
    #####: 4557:            h--;
    #####: 4558:            m = heap[h];
    #####: 4559:            if (m > max_code) {
    #####: 4560:              goto while_continue___4;
        -: 4561:            }
    #####: 4562:            if ((unsigned int)(tree + m)->dl.len != (unsigned int)bits) {
    #####: 4563:              opt_len += (ulg)(((long)bits - (long)(tree + m)->dl.len) *
    #####: 4564:                               (long)(tree + m)->fc.freq);
    #####: 4565:              (tree + m)->dl.len = (ush)bits;
        -: 4566:            }
    #####: 4567:            n--;
        -: 4568:          }
    #####: 4569:        while_break___4: /* CIL Label */;
        -: 4570:        }
    #####: 4571:        bits--;
        -: 4572:      }
    #####: 4573:    while_break___3: /* CIL Label */;
        -: 4574:    }
    #####: 4575:    return;
        -: 4576:  }
        -: 4577:}
    #####: 4578:static void gen_codes(ct_data *tree, int max_code) {
        -: 4579:  ush next_code[16];
        -: 4580:  ush code;
        -: 4581:  int bits;
        -: 4582:  int n;
        -: 4583:  int len;
        -: 4584:  ush tmp;
        -: 4585:  void *__cil_tmp10;
        -: 4586:
        -: 4587:  {
    #####: 4588:    code = (ush)0;
    #####: 4589:    bits = 1;
        -: 4590:    {
        -: 4591:      while (1) {
    #####: 4592:      while_continue: /* CIL Label */;
    #####: 4593:        if (!(bits <= 15)) {
    #####: 4594:          goto while_break;
        -: 4595:        }
    #####: 4596:        code = (ush)(((int)code + (int)bl_count[bits - 1]) << 1);
    #####: 4597:        next_code[bits] = code;
    #####: 4598:        bits++;
        -: 4599:      }
    #####: 4600:    while_break: /* CIL Label */;
        -: 4601:    }
    #####: 4602:    n = 0;
        -: 4603:    {
        -: 4604:      while (1) {
    #####: 4605:      while_continue___0: /* CIL Label */;
    #####: 4606:        if (!(n <= max_code)) {
    #####: 4607:          goto while_break___0;
        -: 4608:        }
    #####: 4609:        len = (int)(tree + n)->dl.len;
    #####: 4610:        if (len == 0) {
    #####: 4611:          goto __Cont;
        -: 4612:        }
        -: 4613:        {
    #####: 4614:          tmp = next_code[len];
    #####: 4615:          next_code[len] = (ush)((int)next_code[len] + 1);
    #####: 4616:          (tree + n)->fc.code = (ush)bi_reverse((unsigned int)tmp, len);
        -: 4617:        }
    #####: 4618:      __Cont:
    #####: 4619:        n++;
        -: 4620:      }
    #####: 4621:    while_break___0: /* CIL Label */;
        -: 4622:    }
    #####: 4623:    return;
        -: 4624:  }
        -: 4625:}
    #####: 4626:static void build_tree___0(tree_desc *desc) {
        -: 4627:  ct_data *tree;
        -: 4628:  ct_data *stree;
        -: 4629:  int elems;
        -: 4630:  int n;
        -: 4631:  int m;
        -: 4632:  int max_code;
        -: 4633:  int node;
        -: 4634:  int new;
        -: 4635:  int tmp;
        -: 4636:  int tmp___0;
        -: 4637:  int tmp___1;
        -: 4638:  ush tmp___2;
        -: 4639:  int tmp___3;
        -: 4640:
        -: 4641:  {
    #####: 4642:    tree = desc->dyn_tree;
    #####: 4643:    stree = desc->static_tree;
    #####: 4644:    elems = desc->elems;
    #####: 4645:    max_code = -1;
    #####: 4646:    node = elems;
    #####: 4647:    heap_len = 0;
    #####: 4648:    heap_max = 573;
    #####: 4649:    n = 0;
        -: 4650:    {
        -: 4651:      while (1) {
    #####: 4652:      while_continue: /* CIL Label */;
    #####: 4653:        if (!(n < elems)) {
    #####: 4654:          goto while_break;
        -: 4655:        }
    #####: 4656:        if ((int)(tree + n)->fc.freq != 0) {
    #####: 4657:          heap_len++;
    #####: 4658:          max_code = n;
    #####: 4659:          heap[heap_len] = max_code;
    #####: 4660:          depth[n] = (uch)0;
        -: 4661:        } else {
    #####: 4662:          (tree + n)->dl.len = (ush)0;
        -: 4663:        }
    #####: 4664:        n++;
        -: 4665:      }
    #####: 4666:    while_break: /* CIL Label */;
        -: 4667:    }
        -: 4668:    {
        -: 4669:      while (1) {
    #####: 4670:      while_continue___0: /* CIL Label */;
    #####: 4671:        if (!(heap_len < 2)) {
    #####: 4672:          goto while_break___0;
        -: 4673:        }
    #####: 4674:        heap_len++;
    #####: 4675:        if (max_code < 2) {
    #####: 4676:          max_code++;
    #####: 4677:          tmp = max_code;
        -: 4678:        } else {
    #####: 4679:          tmp = 0;
        -: 4680:        }
    #####: 4681:        heap[heap_len] = tmp;
    #####: 4682:        new = tmp;
    #####: 4683:        (tree + new)->fc.freq = (ush)1;
    #####: 4684:        depth[new] = (uch)0;
    #####: 4685:        opt_len--;
    #####: 4686:        if (stree) {
    #####: 4687:          static_len -= (ulg)(stree + new)->dl.len;
        -: 4688:        }
        -: 4689:      }
    #####: 4690:    while_break___0: /* CIL Label */;
        -: 4691:    }
    #####: 4692:    desc->max_code = max_code;
    #####: 4693:    n = heap_len / 2;
        -: 4694:    {
        -: 4695:      while (1) {
    #####: 4696:      while_continue___1: /* CIL Label */;
    #####: 4697:        if (!(n >= 1)) {
    #####: 4698:          goto while_break___1;
        -: 4699:        }
        -: 4700:        {
    #####: 4701:          pqdownheap(tree, n);
    #####: 4702:          n--;
        -: 4703:        }
        -: 4704:      }
    #####: 4705:    while_break___1: /* CIL Label */;
        -: 4706:    }
        -: 4707:    {
        -: 4708:      while (1) {
    #####: 4709:      while_continue___2: /* CIL Label */;
        -: 4710:        {
    #####: 4711:          n = heap[1];
    #####: 4712:          tmp___0 = heap_len;
    #####: 4713:          heap_len--;
    #####: 4714:          heap[1] = heap[tmp___0];
    #####: 4715:          pqdownheap(tree, 1);
    #####: 4716:          m = heap[1];
    #####: 4717:          heap_max--;
    #####: 4718:          heap[heap_max] = n;
    #####: 4719:          heap_max--;
    #####: 4720:          heap[heap_max] = m;
    #####: 4721:          (tree + node)->fc.freq =
    #####: 4722:              (ush)((int)(tree + n)->fc.freq + (int)(tree + m)->fc.freq);
        -: 4723:        }
    #####: 4724:        if ((int)depth[n] >= (int)depth[m]) {
    #####: 4725:          tmp___1 = (int)depth[n];
        -: 4726:        } else {
    #####: 4727:          tmp___1 = (int)depth[m];
        -: 4728:        }
        -: 4729:        {
    #####: 4730:          depth[node] = (uch)(tmp___1 + 1);
    #####: 4731:          tmp___2 = (ush)node;
    #####: 4732:          (tree + m)->dl.dad = tmp___2;
    #####: 4733:          (tree + n)->dl.dad = tmp___2;
    #####: 4734:          tmp___3 = node;
    #####: 4735:          node++;
    #####: 4736:          heap[1] = tmp___3;
    #####: 4737:          pqdownheap(tree, 1);
        -: 4738:        }
    #####: 4739:        if (!(heap_len >= 2)) {
    #####: 4740:          goto while_break___2;
        -: 4741:        }
        -: 4742:      }
    #####: 4743:    while_break___2: /* CIL Label */;
        -: 4744:    }
        -: 4745:    {
    #####: 4746:      heap_max--;
    #####: 4747:      heap[heap_max] = heap[1];
    #####: 4748:      gen_bitlen(desc);
    #####: 4749:      gen_codes(tree, max_code);
        -: 4750:    }
    #####: 4751:    return;
        -: 4752:  }
        -: 4753:}
    #####: 4754:static void scan_tree(ct_data *tree, int max_code) {
        -: 4755:  int n;
        -: 4756:  int prevlen;
        -: 4757:  int curlen;
        -: 4758:  int nextlen;
        -: 4759:  int count;
        -: 4760:  int max_count;
        -: 4761:  int min_count;
        -: 4762:
        -: 4763:  {
    #####: 4764:    prevlen = -1;
    #####: 4765:    nextlen = (int)(tree + 0)->dl.len;
    #####: 4766:    count = 0;
    #####: 4767:    max_count = 7;
    #####: 4768:    min_count = 4;
    #####: 4769:    if (nextlen == 0) {
    #####: 4770:      max_count = 138;
    #####: 4771:      min_count = 3;
        -: 4772:    }
    #####: 4773:    (tree + (max_code + 1))->dl.len = (ush)65535;
    #####: 4774:    n = 0;
        -: 4775:    {
        -: 4776:      while (1) {
    #####: 4777:      while_continue: /* CIL Label */;
    #####: 4778:        if (!(n <= max_code)) {
    #####: 4779:          goto while_break;
        -: 4780:        }
    #####: 4781:        curlen = nextlen;
    #####: 4782:        nextlen = (int)(tree + (n + 1))->dl.len;
    #####: 4783:        count++;
    #####: 4784:        if (count < max_count) {
    #####: 4785:          if (curlen == nextlen) {
    #####: 4786:            goto __Cont;
        -: 4787:          } else {
    #####: 4788:            goto _L;
        -: 4789:          }
        -: 4790:        } else {
    #####: 4791:        _L:
    #####: 4792:          if (count < min_count) {
    #####: 4793:            bl_tree[curlen].fc.freq =
    #####: 4794:                (ush)((int)bl_tree[curlen].fc.freq + count);
        -: 4795:          } else {
    #####: 4796:            if (curlen != 0) {
    #####: 4797:              if (curlen != prevlen) {
    #####: 4798:                bl_tree[curlen].fc.freq =
    #####: 4799:                    (ush)((int)bl_tree[curlen].fc.freq + 1);
        -: 4800:              }
    #####: 4801:              bl_tree[16].fc.freq = (ush)((int)bl_tree[16].fc.freq + 1);
        -: 4802:            } else {
    #####: 4803:              if (count <= 10) {
    #####: 4804:                bl_tree[17].fc.freq = (ush)((int)bl_tree[17].fc.freq + 1);
        -: 4805:              } else {
    #####: 4806:                bl_tree[18].fc.freq = (ush)((int)bl_tree[18].fc.freq + 1);
        -: 4807:              }
        -: 4808:            }
        -: 4809:          }
        -: 4810:        }
    #####: 4811:        count = 0;
    #####: 4812:        prevlen = curlen;
    #####: 4813:        if (nextlen == 0) {
    #####: 4814:          max_count = 138;
    #####: 4815:          min_count = 3;
        -: 4816:        } else {
    #####: 4817:          if (curlen == nextlen) {
    #####: 4818:            max_count = 6;
    #####: 4819:            min_count = 3;
        -: 4820:          } else {
    #####: 4821:            max_count = 7;
    #####: 4822:            min_count = 4;
        -: 4823:          }
        -: 4824:        }
    #####: 4825:      __Cont:
    #####: 4826:        n++;
        -: 4827:      }
    #####: 4828:    while_break: /* CIL Label */;
        -: 4829:    }
    #####: 4830:    return;
        -: 4831:  }
        -: 4832:}
    #####: 4833:static void send_tree(ct_data *tree, int max_code) {
        -: 4834:  int n;
        -: 4835:  int prevlen;
        -: 4836:  int curlen;
        -: 4837:  int nextlen;
        -: 4838:  int count;
        -: 4839:  int max_count;
        -: 4840:  int min_count;
        -: 4841:
        -: 4842:  {
    #####: 4843:    prevlen = -1;
    #####: 4844:    nextlen = (int)(tree + 0)->dl.len;
    #####: 4845:    count = 0;
    #####: 4846:    max_count = 7;
    #####: 4847:    min_count = 4;
    #####: 4848:    if (nextlen == 0) {
    #####: 4849:      max_count = 138;
    #####: 4850:      min_count = 3;
        -: 4851:    }
    #####: 4852:    n = 0;
        -: 4853:    {
        -: 4854:      while (1) {
    #####: 4855:      while_continue: /* CIL Label */;
    #####: 4856:        if (!(n <= max_code)) {
    #####: 4857:          goto while_break;
        -: 4858:        }
    #####: 4859:        curlen = nextlen;
    #####: 4860:        nextlen = (int)(tree + (n + 1))->dl.len;
    #####: 4861:        count++;
    #####: 4862:        if (count < max_count) {
    #####: 4863:          if (curlen == nextlen) {
    #####: 4864:            goto __Cont;
        -: 4865:          } else {
    #####: 4866:            goto _L;
        -: 4867:          }
        -: 4868:        } else {
    #####: 4869:        _L:
    #####: 4870:          if (count < min_count) {
        -: 4871:            {
        -: 4872:              while (1) {
    #####: 4873:              while_continue___0: /* CIL Label */;
        -: 4874:                {
    #####: 4875:                  send_bits((int)bl_tree[curlen].fc.code,
    #####: 4876:                            (int)bl_tree[curlen].dl.len);
    #####: 4877:                  count--;
        -: 4878:                }
    #####: 4879:                if (!(count != 0)) {
    #####: 4880:                  goto while_break___0;
        -: 4881:                }
        -: 4882:              }
    #####: 4883:            while_break___0: /* CIL Label */;
        -: 4884:            }
        -: 4885:          } else {
    #####: 4886:            if (curlen != 0) {
    #####: 4887:              if (curlen != prevlen) {
        -: 4888:                {
    #####: 4889:                  send_bits((int)bl_tree[curlen].fc.code,
    #####: 4890:                            (int)bl_tree[curlen].dl.len);
    #####: 4891:                  count--;
        -: 4892:                }
        -: 4893:              }
        -: 4894:              {
    #####: 4895:                send_bits((int)bl_tree[16].fc.code, (int)bl_tree[16].dl.len);
    #####: 4896:                send_bits(count - 3, 2);
        -: 4897:              }
        -: 4898:            } else {
    #####: 4899:              if (count <= 10) {
        -: 4900:                {
    #####: 4901:                  send_bits((int)bl_tree[17].fc.code, (int)bl_tree[17].dl.len);
    #####: 4902:                  send_bits(count - 3, 3);
        -: 4903:                }
        -: 4904:              } else {
        -: 4905:                {
    #####: 4906:                  send_bits((int)bl_tree[18].fc.code, (int)bl_tree[18].dl.len);
    #####: 4907:                  send_bits(count - 11, 7);
        -: 4908:                }
        -: 4909:              }
        -: 4910:            }
        -: 4911:          }
        -: 4912:        }
    #####: 4913:        count = 0;
    #####: 4914:        prevlen = curlen;
    #####: 4915:        if (nextlen == 0) {
    #####: 4916:          max_count = 138;
    #####: 4917:          min_count = 3;
        -: 4918:        } else {
    #####: 4919:          if (curlen == nextlen) {
    #####: 4920:            max_count = 6;
    #####: 4921:            min_count = 3;
        -: 4922:          } else {
    #####: 4923:            max_count = 7;
    #####: 4924:            min_count = 4;
        -: 4925:          }
        -: 4926:        }
    #####: 4927:      __Cont:
    #####: 4928:        n++;
        -: 4929:      }
    #####: 4930:    while_break: /* CIL Label */;
        -: 4931:    }
    #####: 4932:    return;
        -: 4933:  }
        -: 4934:}
    #####: 4935:static int build_bl_tree(void) {
        -: 4936:  int max_blindex;
        -: 4937:
        -: 4938:  {
        -: 4939:    {
    #####: 4940:      scan_tree(dyn_ltree, l_desc.max_code);
    #####: 4941:      scan_tree(dyn_dtree, d_desc.max_code);
    #####: 4942:      build_tree___0(&bl_desc);
    #####: 4943:      max_blindex = 18;
        -: 4944:    }
        -: 4945:    {
        -: 4946:      while (1) {
    #####: 4947:      while_continue: /* CIL Label */;
    #####: 4948:        if (!(max_blindex >= 3)) {
    #####: 4949:          goto while_break;
        -: 4950:        }
    #####: 4951:        if ((int)bl_tree[bl_order[max_blindex]].dl.len != 0) {
    #####: 4952:          goto while_break;
        -: 4953:        }
    #####: 4954:        max_blindex--;
        -: 4955:      }
    #####: 4956:    while_break: /* CIL Label */;
        -: 4957:    }
    #####: 4958:    opt_len += (ulg)(((3 * (max_blindex + 1) + 5) + 5) + 4);
    #####: 4959:    return (max_blindex);
        -: 4960:  }
        -: 4961:}
    #####: 4962:static void send_all_trees(int lcodes, int dcodes, int blcodes) {
        -: 4963:  int rank;
        -: 4964:
        -: 4965:  {
        -: 4966:    {
    #####: 4967:      send_bits(lcodes - 257, 5);
    #####: 4968:      send_bits(dcodes - 1, 5);
    #####: 4969:      send_bits(blcodes - 4, 4);
    #####: 4970:      rank = 0;
        -: 4971:    }
        -: 4972:    {
        -: 4973:      while (1) {
    #####: 4974:      while_continue: /* CIL Label */;
    #####: 4975:        if (!(rank < blcodes)) {
    #####: 4976:          goto while_break;
        -: 4977:        }
        -: 4978:        {
    #####: 4979:          send_bits((int)bl_tree[bl_order[rank]].dl.len, 3);
    #####: 4980:          rank++;
        -: 4981:        }
        -: 4982:      }
    #####: 4983:    while_break: /* CIL Label */;
        -: 4984:    }
        -: 4985:    {
    #####: 4986:      send_tree(dyn_ltree, lcodes - 1);
    #####: 4987:      send_tree(dyn_dtree, dcodes - 1);
        -: 4988:    }
    #####: 4989:    return;
        -: 4990:  }
        -: 4991:}
    #####: 4992:ulg flush_block(char *buf, ulg stored_len, int eof) {
        -: 4993:  ulg opt_lenb;
        -: 4994:  ulg static_lenb;
        -: 4995:  int max_blindex;
        -: 4996:
        -: 4997:  {
    #####: 4998:    flag_buf[last_flags] = flags;
    #####: 4999:    if ((int)*file_type == 65535) {
        -: 5000:      {
    #####: 5001:        set_file_type();
        -: 5002:      }
        -: 5003:    }
        -: 5004:    {
    #####: 5005:      build_tree___0(&l_desc);
    #####: 5006:      build_tree___0(&d_desc);
    #####: 5007:      max_blindex = build_bl_tree();
    #####: 5008:      opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
    #####: 5009:      static_lenb = ((static_len + 3UL) + 7UL) >> 3;
    #####: 5010:      input_len += stored_len;
        -: 5011:    }
    #####: 5012:    if (static_lenb <= opt_lenb) {
    #####: 5013:      opt_lenb = static_lenb;
        -: 5014:    }
    #####: 5015:    if (stored_len <= opt_lenb) {
    #####: 5016:      if (eof) {
    #####: 5017:        if (compressed_len == 0UL) {
    #####: 5018:          goto _L___2;
        -: 5019:        } else {
    #####: 5020:          goto _L___2;
        -: 5021:        }
        -: 5022:      } else {
    #####: 5023:        goto _L___2;
        -: 5024:      }
        -: 5025:    } else {
    #####: 5026:    _L___2:
    #####: 5027:      if (stored_len + 4UL <= opt_lenb) {
    #####: 5028:        if ((unsigned long)buf != (unsigned long)((char *)0)) {
        -: 5029:          {
    #####: 5030:            send_bits(eof, 3);
    #####: 5031:            compressed_len =
    #####: 5032:                ((compressed_len + 3UL) + 7UL) & 0xfffffffffffffff8UL;
    #####: 5033:            compressed_len += (stored_len + 4UL) << 3;
    #####: 5034:            copy_block(buf, (unsigned int)stored_len, 1);
        -: 5035:          }
        -: 5036:        } else {
    #####: 5037:          goto _L;
        -: 5038:        }
        -: 5039:      } else {
    #####: 5040:      _L:
    #####: 5041:        if (static_lenb == opt_lenb) {
        -: 5042:          {
    #####: 5043:            send_bits((1 << 1) + eof, 3);
    #####: 5044:            compress_block(static_ltree, static_dtree);
    #####: 5045:            compressed_len += 3UL + static_len;
        -: 5046:          }
        -: 5047:        } else {
        -: 5048:          {
    #####: 5049:            send_bits((2 << 1) + eof, 3);
    #####: 5050:            send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1,
        -: 5051:                           max_blindex + 1);
    #####: 5052:            compress_block(dyn_ltree, dyn_dtree);
    #####: 5053:            compressed_len += 3UL + opt_len;
        -: 5054:          }
        -: 5055:        }
        -: 5056:      }
        -: 5057:    }
    #####: 5058:    { init_block(); }
    #####: 5059:    if (eof) {
        -: 5060:      {
    #####: 5061:        bi_windup();
    #####: 5062:        compressed_len += 7UL;
        -: 5063:      }
        -: 5064:    }
    #####: 5065:    return (compressed_len >> 3);
        -: 5066:  }
        -: 5067:}
    #####: 5068:int ct_tally(int dist, int lc) {
        -: 5069:  unsigned int tmp;
        -: 5070:  int tmp___0;
        -: 5071:  unsigned int tmp___1;
        -: 5072:  unsigned int tmp___2;
        -: 5073:  ulg out_length;
        -: 5074:  ulg in_length;
        -: 5075:  int dcode;
        -: 5076:  int tmp___3;
        -: 5077:
        -: 5078:  {
    #####: 5079:    tmp = last_lit;
    #####: 5080:    last_lit++;
    #####: 5081:    inbuf[tmp] = (uch)lc;
    #####: 5082:    if (dist == 0) {
    #####: 5083:      dyn_ltree[lc].fc.freq = (ush)((int)dyn_ltree[lc].fc.freq + 1);
        -: 5084:    } else {
    #####: 5085:      dist--;
    #####: 5086:      dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq =
    #####: 5087:          (ush)((int)dyn_ltree[((int)length_code[lc] + 256) + 1].fc.freq + 1);
    #####: 5088:      if (dist < 256) {
    #####: 5089:        tmp___0 = (int)dist_code[dist];
        -: 5090:      } else {
    #####: 5091:        tmp___0 = (int)dist_code[256 + (dist >> 7)];
        -: 5092:      }
    #####: 5093:      dyn_dtree[tmp___0].fc.freq = (ush)((int)dyn_dtree[tmp___0].fc.freq + 1);
    #####: 5094:      tmp___1 = last_dist;
    #####: 5095:      last_dist++;
    #####: 5096:      d_buf[tmp___1] = (ush)dist;
    #####: 5097:      flags = (uch)((int)flags | (int)flag_bit);
        -: 5098:    }
    #####: 5099:    flag_bit = (uch)((int)flag_bit << 1);
    #####: 5100:    if ((last_lit & 7U) == 0U) {
    #####: 5101:      tmp___2 = last_flags;
    #####: 5102:      last_flags++;
    #####: 5103:      flag_buf[tmp___2] = flags;
    #####: 5104:      flags = (uch)0;
    #####: 5105:      flag_bit = (uch)1;
        -: 5106:    }
    #####: 5107:    if (level > 2) {
    #####: 5108:      if ((last_lit & 4095U) == 0U) {
    #####: 5109:        out_length = (ulg)last_lit * 8UL;
    #####: 5110:        in_length = (ulg)strstart - (ulg)block_start;
    #####: 5111:        dcode = 0;
        -: 5112:        {
        -: 5113:          while (1) {
    #####: 5114:          while_continue: /* CIL Label */;
    #####: 5115:            if (!(dcode < 30)) {
    #####: 5116:              goto while_break;
        -: 5117:            }
    #####: 5118:            out_length += (ulg)dyn_dtree[dcode].fc.freq *
    #####: 5119:                          (ulg)(5L + (long)extra_dbits[dcode]);
    #####: 5120:            dcode++;
        -: 5121:          }
    #####: 5122:        while_break: /* CIL Label */;
        -: 5123:        }
    #####: 5124:        out_length >>= 3;
    #####: 5125:        if (last_dist < last_lit / 2U) {
    #####: 5126:          if (out_length < in_length / 2UL) {
    #####: 5127:            return (1);
        -: 5128:          }
        -: 5129:        }
        -: 5130:      }
        -: 5131:    }
    #####: 5132:    if (last_lit == 32767U) {
    #####: 5133:      tmp___3 = 1;
        -: 5134:    } else {
    #####: 5135:      if (last_dist == 32768U) {
    #####: 5136:        tmp___3 = 1;
        -: 5137:      } else {
    #####: 5138:        tmp___3 = 0;
        -: 5139:      }
        -: 5140:    }
    #####: 5141:    return (tmp___3);
        -: 5142:  }
        -: 5143:}
    #####: 5144:static void compress_block(ct_data *ltree, ct_data *dtree) {
        -: 5145:  unsigned int dist;
        -: 5146:  int lc;
        -: 5147:  unsigned int lx;
        -: 5148:  unsigned int dx;
        -: 5149:  unsigned int fx;
        -: 5150:  uch flag;
        -: 5151:  unsigned int code;
        -: 5152:  int extra;
        -: 5153:  unsigned int tmp;
        -: 5154:  unsigned int tmp___0;
        -: 5155:  unsigned int tmp___1;
        -: 5156:
        -: 5157:  {
    #####: 5158:    lx = 0U;
    #####: 5159:    dx = 0U;
    #####: 5160:    fx = 0U;
    #####: 5161:    flag = (uch)0;
    #####: 5162:    if (last_lit != 0U) {
        -: 5163:      {
        -: 5164:        while (1) {
    #####: 5165:        while_continue: /* CIL Label */;
    #####: 5166:          if ((lx & 7U) == 0U) {
    #####: 5167:            tmp = fx;
    #####: 5168:            fx++;
    #####: 5169:            flag = flag_buf[tmp];
        -: 5170:          }
    #####: 5171:          tmp___0 = lx;
    #####: 5172:          lx++;
    #####: 5173:          lc = (int)inbuf[tmp___0];
    #####: 5174:          if (((int)flag & 1) == 0) {
        -: 5175:            {
    #####: 5176:              send_bits((int)(ltree + lc)->fc.code, (int)(ltree + lc)->dl.len);
        -: 5177:            }
        -: 5178:          } else {
        -: 5179:            {
    #####: 5180:              code = (unsigned int)length_code[lc];
    #####: 5181:              send_bits((int)(ltree + ((code + 256U) + 1U))->fc.code,
    #####: 5182:                        (int)(ltree + ((code + 256U) + 1U))->dl.len);
    #####: 5183:              extra = extra_lbits[code];
        -: 5184:            }
    #####: 5185:            if (extra != 0) {
        -: 5186:              {
    #####: 5187:                lc -= base_length[code];
    #####: 5188:                send_bits(lc, extra);
        -: 5189:              }
        -: 5190:            }
    #####: 5191:            tmp___1 = dx;
    #####: 5192:            dx++;
    #####: 5193:            dist = (unsigned int)d_buf[tmp___1];
    #####: 5194:            if (dist < 256U) {
    #####: 5195:              code = (unsigned int)dist_code[dist];
        -: 5196:            } else {
    #####: 5197:              code = (unsigned int)dist_code[256U + (dist >> 7)];
        -: 5198:            }
        -: 5199:            {
    #####: 5200:              send_bits((int)(dtree + code)->fc.code,
    #####: 5201:                        (int)(dtree + code)->dl.len);
    #####: 5202:              extra = extra_dbits[code];
        -: 5203:            }
    #####: 5204:            if (extra != 0) {
        -: 5205:              {
    #####: 5206:                dist -= (unsigned int)base_dist[code];
    #####: 5207:                send_bits((int)dist, extra);
        -: 5208:              }
        -: 5209:            }
        -: 5210:          }
    #####: 5211:          flag = (uch)((int)flag >> 1);
    #####: 5212:          if (!(lx < last_lit)) {
    #####: 5213:            goto while_break;
        -: 5214:          }
        -: 5215:        }
    #####: 5216:      while_break: /* CIL Label */;
        -: 5217:      }
        -: 5218:    }
    #####: 5219:    { send_bits((int)(ltree + 256)->fc.code, (int)(ltree + 256)->dl.len); }
    #####: 5220:    return;
        -: 5221:  }
        -: 5222:}
    #####: 5223:static void set_file_type(void) {
        -: 5224:  int n;
        -: 5225:  unsigned int ascii_freq;
        -: 5226:  unsigned int bin_freq;
        -: 5227:  int tmp;
        -: 5228:  int tmp___0;
        -: 5229:  int tmp___1;
        -: 5230:
        -: 5231:  {
    #####: 5232:    n = 0;
    #####: 5233:    ascii_freq = 0U;
    #####: 5234:    bin_freq = 0U;
        -: 5235:    {
        -: 5236:      while (1) {
    #####: 5237:      while_continue: /* CIL Label */;
    #####: 5238:        if (!(n < 7)) {
    #####: 5239:          goto while_break;
        -: 5240:        }
    #####: 5241:        tmp = n;
    #####: 5242:        n++;
    #####: 5243:        bin_freq += (unsigned int)dyn_ltree[tmp].fc.freq;
        -: 5244:      }
    #####: 5245:    while_break: /* CIL Label */;
        -: 5246:    }
        -: 5247:    {
        -: 5248:      while (1) {
    #####: 5249:      while_continue___0: /* CIL Label */;
    #####: 5250:        if (!(n < 128)) {
    #####: 5251:          goto while_break___0;
        -: 5252:        }
    #####: 5253:        tmp___0 = n;
    #####: 5254:        n++;
    #####: 5255:        ascii_freq += (unsigned int)dyn_ltree[tmp___0].fc.freq;
        -: 5256:      }
    #####: 5257:    while_break___0: /* CIL Label */;
        -: 5258:    }
        -: 5259:    {
        -: 5260:      while (1) {
    #####: 5261:      while_continue___1: /* CIL Label */;
    #####: 5262:        if (!(n < 256)) {
    #####: 5263:          goto while_break___1;
        -: 5264:        }
    #####: 5265:        tmp___1 = n;
    #####: 5266:        n++;
    #####: 5267:        bin_freq += (unsigned int)dyn_ltree[tmp___1].fc.freq;
        -: 5268:      }
    #####: 5269:    while_break___1: /* CIL Label */;
        -: 5270:    }
    #####: 5271:    if (bin_freq > ascii_freq >> 2) {
    #####: 5272:      *file_type = (ush)0;
        -: 5273:    } else {
    #####: 5274:      *file_type = (ush)1;
        -: 5275:    }
    #####: 5276:    return;
        -: 5277:  }
        -: 5278:}
        -: 5279:void lm_init(int pack_level, ush *flags___0);
        -: 5280:ulg deflate(void);
        -: 5281:ulg window_size = 65536UL;
        -: 5282:static unsigned int ins_h;
        -: 5283:unsigned int prev_length;
        -: 5284:unsigned int match_start;
        -: 5285:static int eofile;
        -: 5286:static unsigned int lookahead;
        -: 5287:unsigned int max_chain_length;
        -: 5288:static unsigned int max_lazy_match;
        -: 5289:static int compr_level;
        -: 5290:unsigned int good_match;
        -: 5291:int nice_match;
        -: 5292:static config configuration_table[10] = {
        -: 5293:    {(ush)0, (ush)0, (ush)0, (ush)0},
        -: 5294:    {(ush)4, (ush)4, (ush)8, (ush)4},
        -: 5295:    {(ush)4, (ush)5, (ush)16, (ush)8},
        -: 5296:    {(ush)4, (ush)6, (ush)32, (ush)32},
        -: 5297:    {(ush)4, (ush)4, (ush)16, (ush)16},
        -: 5298:    {(ush)8, (ush)16, (ush)32, (ush)32},
        -: 5299:    {(ush)8, (ush)16, (ush)128, (ush)128},
        -: 5300:    {(ush)8, (ush)32, (ush)128, (ush)256},
        -: 5301:    {(ush)32, (ush)128, (ush)258, (ush)1024},
        -: 5302:    {(ush)32, (ush)258, (ush)258, (ush)4096}};
        -: 5303:static void fill_window(void);
        -: 5304:static ulg deflate_fast(void);
        -: 5305:int longest_match(IPos cur_match);
    #####: 5306:void lm_init(int pack_level, ush *flags___0) {
        -: 5307:  register unsigned int j___0;
        -: 5308:  unsigned int tmp;
        -: 5309:  char *__cil_tmp6;
        -: 5310:  char *__cil_tmp7;
        -: 5311:
        -: 5312:  {
    #####: 5313:    if (pack_level < 1) {
        -: 5314:      {
    #####: 5315:        error((char *)"bad pack level");
        -: 5316:      }
        -: 5317:    } else {
    #####: 5318:      if (pack_level > 9) {
        -: 5319:        {
    #####: 5320:          error((char *)"bad pack level");
        -: 5321:        }
        -: 5322:      }
        -: 5323:    }
        -: 5324:    {
    #####: 5325:      compr_level = pack_level;
    #####: 5326:      memset((voidp)((char *)(prev + 32768)), 0,
        -: 5327:             (unsigned long)((unsigned int)(1 << 15)) *
        -: 5328:                 sizeof(*(prev + 32768)));
    #####: 5329:      max_lazy_match = (unsigned int)configuration_table[pack_level].max_lazy;
    #####: 5330:      good_match = (unsigned int)configuration_table[pack_level].good_length;
    #####: 5331:      nice_match = (int)configuration_table[pack_level].nice_length;
    #####: 5332:      max_chain_length =
    #####: 5333:          (unsigned int)configuration_table[pack_level].max_chain;
        -: 5334:    }
    #####: 5335:    if (pack_level == 1) {
    #####: 5336:      *flags___0 = (ush)((int)*flags___0 | 4);
        -: 5337:    } else {
    #####: 5338:      if (pack_level == 9) {
    #####: 5339:        *flags___0 = (ush)((int)*flags___0 | 2);
        -: 5340:      }
        -: 5341:    }
    #####: 5342:    strstart = 0U;
    #####: 5343:    block_start = 0L;
        -: 5344:    if (sizeof(int) <= 2UL) {
        -: 5345:      tmp = 32768U;
        -: 5346:    } else {
    #####: 5347:      tmp = 65536U;
        -: 5348:    }
    #####: 5349:    { lookahead = (unsigned int)(*read_buf)((char *)(window), tmp); }
    #####: 5350:    if (lookahead == 0U) {
    #####: 5351:      eofile = 1;
    #####: 5352:      lookahead = 0U;
    #####: 5353:      return;
        -: 5354:    } else {
    #####: 5355:      if (lookahead == 4294967295U) {
    #####: 5356:        eofile = 1;
    #####: 5357:        lookahead = 0U;
    #####: 5358:        return;
        -: 5359:      }
        -: 5360:    }
    #####: 5361:    eofile = 0;
        -: 5362:    {
        -: 5363:      while (1) {
    #####: 5364:      while_continue: /* CIL Label */;
    #####: 5365:        if (lookahead < 262U) {
    #####: 5366:          if (!(!eofile)) {
    #####: 5367:            goto while_break;
        -: 5368:          }
        -: 5369:        } else {
    #####: 5370:          goto while_break;
        -: 5371:        }
    #####: 5372:        { fill_window(); }
        -: 5373:      }
    #####: 5374:    while_break: /* CIL Label */;
        -: 5375:    }
    #####: 5376:    ins_h = 0U;
    #####: 5377:    j___0 = 0U;
        -: 5378:    {
        -: 5379:      while (1) {
    #####: 5380:      while_continue___0: /* CIL Label */;
    #####: 5381:        if (!(j___0 < 2U)) {
    #####: 5382:          goto while_break___0;
        -: 5383:        }
    #####: 5384:        ins_h = ((ins_h << 5) ^ (unsigned int)window[j___0]) &
        -: 5385:                ((unsigned int)(1 << 15) - 1U);
    #####: 5386:        j___0++;
        -: 5387:      }
    #####: 5388:    while_break___0: /* CIL Label */;
        -: 5389:    }
    #####: 5390:    return;
        -: 5391:  }
        -: 5392:}
    #####: 5393:int longest_match(IPos cur_match) {
        -: 5394:  unsigned int chain_length;
        -: 5395:  register uch *scan;
        -: 5396:  register uch *match;
        -: 5397:  register int len;
        -: 5398:  int best_len;
        -: 5399:  IPos limit;
        -: 5400:  unsigned int tmp;
        -: 5401:  register uch *strend;
        -: 5402:  register uch scan_end1;
        -: 5403:  register uch scan_end;
        -: 5404:
        -: 5405:  {
    #####: 5406:    chain_length = max_chain_length;
    #####: 5407:    scan = window + strstart;
    #####: 5408:    best_len = (int)prev_length;
    #####: 5409:    if (strstart > 32506U) {
    #####: 5410:      tmp = strstart - 32506U;
        -: 5411:    } else {
    #####: 5412:      tmp = 0U;
        -: 5413:    }
    #####: 5414:    limit = tmp;
    #####: 5415:    strend = (window + strstart) + 258;
    #####: 5416:    scan_end1 = *(scan + (best_len - 1));
    #####: 5417:    scan_end = *(scan + best_len);
    #####: 5418:    if (prev_length >= good_match) {
    #####: 5419:      chain_length >>= 2;
        -: 5420:    }
        -: 5421:    {
        -: 5422:      while (1) {
    #####: 5423:      while_continue: /* CIL Label */;
    #####: 5424:        match = window + cur_match;
    #####: 5425:        if ((int)*(match + best_len) != (int)scan_end) {
    #####: 5426:          goto __Cont;
        -: 5427:        } else {
    #####: 5428:          if ((int)*(match + (best_len - 1)) != (int)scan_end1) {
    #####: 5429:            goto __Cont;
        -: 5430:          } else {
    #####: 5431:            if ((int)*match != (int)*scan) {
    #####: 5432:              goto __Cont;
        -: 5433:            } else {
    #####: 5434:              match++;
    #####: 5435:              if ((int)*match != (int)*(scan + 1)) {
    #####: 5436:                goto __Cont;
        -: 5437:              }
        -: 5438:            }
        -: 5439:          }
        -: 5440:        }
    #####: 5441:        scan += 2;
    #####: 5442:        match++;
        -: 5443:        {
        -: 5444:          while (1) {
    #####: 5445:          while_continue___0: /* CIL Label */;
    #####: 5446:            scan++;
    #####: 5447:            match++;
    #####: 5448:            if ((int)*scan == (int)*match) {
    #####: 5449:              scan++;
    #####: 5450:              match++;
    #####: 5451:              if ((int)*scan == (int)*match) {
    #####: 5452:                scan++;
    #####: 5453:                match++;
    #####: 5454:                if ((int)*scan == (int)*match) {
    #####: 5455:                  scan++;
    #####: 5456:                  match++;
    #####: 5457:                  if ((int)*scan == (int)*match) {
    #####: 5458:                    scan++;
    #####: 5459:                    match++;
    #####: 5460:                    if ((int)*scan == (int)*match) {
    #####: 5461:                      scan++;
    #####: 5462:                      match++;
    #####: 5463:                      if ((int)*scan == (int)*match) {
    #####: 5464:                        scan++;
    #####: 5465:                        match++;
    #####: 5466:                        if ((int)*scan == (int)*match) {
    #####: 5467:                          scan++;
    #####: 5468:                          match++;
    #####: 5469:                          if ((int)*scan == (int)*match) {
    #####: 5470:                            if (!((unsigned long)scan <
    #####: 5471:                                  (unsigned long)strend)) {
    #####: 5472:                              goto while_break___0;
        -: 5473:                            }
        -: 5474:                          } else {
    #####: 5475:                            goto while_break___0;
        -: 5476:                          }
        -: 5477:                        } else {
    #####: 5478:                          goto while_break___0;
        -: 5479:                        }
        -: 5480:                      } else {
    #####: 5481:                        goto while_break___0;
        -: 5482:                      }
        -: 5483:                    } else {
    #####: 5484:                      goto while_break___0;
        -: 5485:                    }
        -: 5486:                  } else {
    #####: 5487:                    goto while_break___0;
        -: 5488:                  }
        -: 5489:                } else {
    #####: 5490:                  goto while_break___0;
        -: 5491:                }
        -: 5492:              } else {
    #####: 5493:                goto while_break___0;
        -: 5494:              }
        -: 5495:            } else {
    #####: 5496:              goto while_break___0;
        -: 5497:            }
        -: 5498:          }
    #####: 5499:        while_break___0: /* CIL Label */;
        -: 5500:        }
    #####: 5501:        len = 258 - (int)(strend - scan);
    #####: 5502:        scan = strend - 258;
    #####: 5503:        if (len > best_len) {
    #####: 5504:          match_start = cur_match;
    #####: 5505:          best_len = len;
    #####: 5506:          if (len >= nice_match) {
    #####: 5507:            goto while_break;
        -: 5508:          }
    #####: 5509:          scan_end1 = *(scan + (best_len - 1));
    #####: 5510:          scan_end = *(scan + best_len);
        -: 5511:        }
    #####: 5512:      __Cont:
    #####: 5513:        cur_match = (IPos)prev[cur_match & 32767U];
    #####: 5514:        if (cur_match > limit) {
    #####: 5515:          chain_length--;
    #####: 5516:          if (!(chain_length != 0U)) {
    #####: 5517:            goto while_break;
        -: 5518:          }
        -: 5519:        } else {
    #####: 5520:          goto while_break;
        -: 5521:        }
        -: 5522:      }
    #####: 5523:    while_break: /* CIL Label */;
        -: 5524:    }
    #####: 5525:    return (best_len);
        -: 5526:  }
        -: 5527:}
    #####: 5528:static void fill_window(void) {
        -: 5529:  register unsigned int n;
        -: 5530:  register unsigned int m;
        -: 5531:  unsigned int more;
        -: 5532:  unsigned int tmp;
        -: 5533:  unsigned int tmp___0;
        -: 5534:
        -: 5535:  {
    #####: 5536:    more = (unsigned int)((window_size - (ulg)lookahead) - (ulg)strstart);
    #####: 5537:    if (more == 4294967295U) {
    #####: 5538:      more--;
        -: 5539:    } else {
    #####: 5540:      if (strstart >= 65274U) {
        -: 5541:        {
    #####: 5542:          memcpy((void * /* __restrict  */)((char *)(window)),
        -: 5543:                 (void const * /* __restrict  */)((char *)(window) + 32768),
        -: 5544:                 (size_t)32768U);
    #####: 5545:          match_start -= 32768U;
    #####: 5546:          strstart -= 32768U;
    #####: 5547:          block_start -= 32768L;
    #####: 5548:          n = 0U;
        -: 5549:        }
        -: 5550:        {
        -: 5551:          while (1) {
    #####: 5552:          while_continue: /* CIL Label */;
    #####: 5553:            if (!(n < (unsigned int)(1 << 15))) {
    #####: 5554:              goto while_break;
        -: 5555:            }
    #####: 5556:            m = (unsigned int)*((prev + 32768) + n);
    #####: 5557:            if (m >= 32768U) {
    #####: 5558:              tmp = m - 32768U;
        -: 5559:            } else {
    #####: 5560:              tmp = 0U;
        -: 5561:            }
    #####: 5562:            *((prev + 32768) + n) = (Pos)tmp;
    #####: 5563:            n++;
        -: 5564:          }
    #####: 5565:        while_break: /* CIL Label */;
        -: 5566:        }
    #####: 5567:        n = 0U;
        -: 5568:        {
        -: 5569:          while (1) {
    #####: 5570:          while_continue___0: /* CIL Label */;
    #####: 5571:            if (!(n < 32768U)) {
    #####: 5572:              goto while_break___0;
        -: 5573:            }
    #####: 5574:            m = (unsigned int)prev[n];
    #####: 5575:            if (m >= 32768U) {
    #####: 5576:              tmp___0 = m - 32768U;
        -: 5577:            } else {
    #####: 5578:              tmp___0 = 0U;
        -: 5579:            }
    #####: 5580:            prev[n] = (Pos)tmp___0;
    #####: 5581:            n++;
        -: 5582:          }
    #####: 5583:        while_break___0: /* CIL Label */;
        -: 5584:        }
    #####: 5585:        more += 32768U;
        -: 5586:      }
        -: 5587:    }
    #####: 5588:    if (!eofile) {
        -: 5589:      {
    #####: 5590:        n = (unsigned int)(*read_buf)(((char *)(window) + strstart) + lookahead,
        -: 5591:                                      more);
        -: 5592:      }
    #####: 5593:      if (n == 0U) {
    #####: 5594:        eofile = 1;
        -: 5595:      } else {
    #####: 5596:        if (n == 4294967295U) {
    #####: 5597:          eofile = 1;
        -: 5598:        } else {
    #####: 5599:          lookahead += n;
        -: 5600:        }
        -: 5601:      }
        -: 5602:    }
    #####: 5603:    return;
        -: 5604:  }
        -: 5605:}
    #####: 5606:static ulg deflate_fast(void) {
        -: 5607:  IPos hash_head;
        -: 5608:  int flush;
        -: 5609:  unsigned int match_length;
        -: 5610:  char *tmp;
        -: 5611:  char *tmp___0;
        -: 5612:  ulg tmp___1;
        -: 5613:
        -: 5614:  {
    #####: 5615:    match_length = 0U;
    #####: 5616:    prev_length = 2U;
        -: 5617:    {
        -: 5618:      while (1) {
    #####: 5619:      while_continue: /* CIL Label */;
    #####: 5620:        if (!(lookahead != 0U)) {
    #####: 5621:          goto while_break;
        -: 5622:        }
    #####: 5623:        ins_h = ((ins_h << 5) ^ (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 5624:                ((unsigned int)(1 << 15) - 1U);
    #####: 5625:        hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 5626:        prev[strstart & 32767U] = (ush)hash_head;
    #####: 5627:        *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 5628:        if (hash_head != 0U) {
    #####: 5629:          if (strstart - hash_head <= 32506U) {
        -: 5630:            {
    #####: 5631:              match_length = (unsigned int)longest_match(hash_head);
        -: 5632:            }
    #####: 5633:            if (match_length > lookahead) {
    #####: 5634:              match_length = lookahead;
        -: 5635:            }
        -: 5636:          }
        -: 5637:        }
    #####: 5638:        if (match_length >= 3U) {
        -: 5639:          {
    #####: 5640:            flush = ct_tally((int)(strstart - match_start),
    #####: 5641:                             (int)(match_length - 3U));
    #####: 5642:            lookahead -= match_length;
        -: 5643:          }
    #####: 5644:          if (match_length <= max_lazy_match) {
    #####: 5645:            match_length--;
        -: 5646:            {
        -: 5647:              while (1) {
    #####: 5648:              while_continue___0: /* CIL Label */;
    #####: 5649:                strstart++;
    #####: 5650:                ins_h = ((ins_h << 5) ^
    #####: 5651:                         (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 5652:                        ((unsigned int)(1 << 15) - 1U);
    #####: 5653:                hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 5654:                prev[strstart & 32767U] = (ush)hash_head;
    #####: 5655:                *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 5656:                match_length--;
    #####: 5657:                if (!(match_length != 0U)) {
    #####: 5658:                  goto while_break___0;
        -: 5659:                }
        -: 5660:              }
    #####: 5661:            while_break___0: /* CIL Label */;
        -: 5662:            }
    #####: 5663:            strstart++;
        -: 5664:          } else {
    #####: 5665:            strstart += match_length;
    #####: 5666:            match_length = 0U;
    #####: 5667:            ins_h = (unsigned int)window[strstart];
    #####: 5668:            ins_h = ((ins_h << 5) ^ (unsigned int)window[strstart + 1U]) &
        -: 5669:                    ((unsigned int)(1 << 15) - 1U);
        -: 5670:          }
        -: 5671:        } else {
        -: 5672:          {
    #####: 5673:            flush = ct_tally(0, (int)window[strstart]);
    #####: 5674:            lookahead--;
    #####: 5675:            strstart++;
        -: 5676:          }
        -: 5677:        }
    #####: 5678:        if (flush) {
    #####: 5679:          if (block_start >= 0L) {
    #####: 5680:            tmp = (char *)(&window[(unsigned int)block_start]);
        -: 5681:          } else {
    #####: 5682:            tmp = (char *)((void *)0);
        -: 5683:          }
        -: 5684:          {
    #####: 5685:            flush_block(tmp, (ulg)((long)strstart - block_start), 0);
    #####: 5686:            block_start = (long)strstart;
        -: 5687:          }
        -: 5688:        }
        -: 5689:        {
        -: 5690:          while (1) {
    #####: 5691:          while_continue___1: /* CIL Label */;
    #####: 5692:            if (lookahead < 262U) {
    #####: 5693:              if (!(!eofile)) {
    #####: 5694:                goto while_break___1;
        -: 5695:              }
        -: 5696:            } else {
    #####: 5697:              goto while_break___1;
        -: 5698:            }
    #####: 5699:            { fill_window(); }
        -: 5700:          }
    #####: 5701:        while_break___1: /* CIL Label */;
        -: 5702:        }
        -: 5703:      }
    #####: 5704:    while_break: /* CIL Label */;
        -: 5705:    }
    #####: 5706:    if (block_start >= 0L) {
    #####: 5707:      tmp___0 = (char *)(&window[(unsigned int)block_start]);
        -: 5708:    } else {
    #####: 5709:      tmp___0 = (char *)((void *)0);
        -: 5710:    }
    #####: 5711:    { tmp___1 = flush_block(tmp___0, (ulg)((long)strstart - block_start), 1); }
    #####: 5712:    return (tmp___1);
        -: 5713:  }
        -: 5714:}
    #####: 5715:ulg deflate(void) {
        -: 5716:  IPos hash_head;
        -: 5717:  IPos prev_match;
        -: 5718:  int flush;
        -: 5719:  int match_available;
        -: 5720:  register unsigned int match_length;
        -: 5721:  ulg tmp;
        -: 5722:  char *tmp___0;
        -: 5723:  char *tmp___1;
        -: 5724:  int tmp___2;
        -: 5725:  char *tmp___3;
        -: 5726:  ulg tmp___4;
        -: 5727:
        -: 5728:  {
    #####: 5729:    match_available = 0;
    #####: 5730:    match_length = 2U;
    #####: 5731:    if (compr_level <= 3) {
        -: 5732:      {
    #####: 5733:        tmp = deflate_fast();
        -: 5734:      }
    #####: 5735:      return (tmp);
        -: 5736:    }
        -: 5737:    {
        -: 5738:      while (1) {
    #####: 5739:      while_continue: /* CIL Label */;
    #####: 5740:        if (!(lookahead != 0U)) {
    #####: 5741:          goto while_break;
        -: 5742:        }
    #####: 5743:        ins_h = ((ins_h << 5) ^ (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 5744:                ((unsigned int)(1 << 15) - 1U);
    #####: 5745:        hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 5746:        prev[strstart & 32767U] = (ush)hash_head;
    #####: 5747:        *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 5748:        prev_length = match_length;
    #####: 5749:        prev_match = match_start;
    #####: 5750:        match_length = 2U;
    #####: 5751:        if (hash_head != 0U) {
    #####: 5752:          if (prev_length < max_lazy_match) {
    #####: 5753:            if (strstart - hash_head <= 32506U) {
        -: 5754:              {
    #####: 5755:                match_length = (unsigned int)longest_match(hash_head);
        -: 5756:              }
    #####: 5757:              if (match_length > lookahead) {
    #####: 5758:                match_length = lookahead;
        -: 5759:              }
    #####: 5760:              if (match_length == 3U) {
    #####: 5761:                if (strstart - match_start > 4096U) {
    #####: 5762:                  match_length--;
        -: 5763:                }
        -: 5764:              }
        -: 5765:            }
        -: 5766:          }
        -: 5767:        }
    #####: 5768:        if (prev_length >= 3U) {
    #####: 5769:          if (match_length <= prev_length) {
        -: 5770:            {
    #####: 5771:              flush = ct_tally((int)((strstart - 1U) - prev_match),
    #####: 5772:                               (int)(prev_length - 3U));
    #####: 5773:              lookahead -= prev_length - 1U;
    #####: 5774:              prev_length -= 2U;
        -: 5775:            }
        -: 5776:            {
        -: 5777:              while (1) {
    #####: 5778:              while_continue___0: /* CIL Label */;
    #####: 5779:                strstart++;
    #####: 5780:                ins_h = ((ins_h << 5) ^
    #####: 5781:                         (unsigned int)window[(strstart + 3U) - 1U]) &
        -: 5782:                        ((unsigned int)(1 << 15) - 1U);
    #####: 5783:                hash_head = (IPos) * ((prev + 32768) + ins_h);
    #####: 5784:                prev[strstart & 32767U] = (ush)hash_head;
    #####: 5785:                *((prev + 32768) + ins_h) = (ush)strstart;
    #####: 5786:                prev_length--;
    #####: 5787:                if (!(prev_length != 0U)) {
    #####: 5788:                  goto while_break___0;
        -: 5789:                }
        -: 5790:              }
    #####: 5791:            while_break___0: /* CIL Label */;
        -: 5792:            }
    #####: 5793:            match_available = 0;
    #####: 5794:            match_length = 2U;
    #####: 5795:            strstart++;
    #####: 5796:            if (flush) {
    #####: 5797:              if (block_start >= 0L) {
    #####: 5798:                tmp___0 = (char *)(&window[(unsigned int)block_start]);
        -: 5799:              } else {
    #####: 5800:                tmp___0 = (char *)((void *)0);
        -: 5801:              }
        -: 5802:              {
    #####: 5803:                flush_block(tmp___0, (ulg)((long)strstart - block_start), 0);
    #####: 5804:                block_start = (long)strstart;
        -: 5805:              }
        -: 5806:            }
        -: 5807:          } else {
    #####: 5808:            goto _L;
        -: 5809:          }
        -: 5810:        } else {
    #####: 5811:        _L:
    #####: 5812:          if (match_available) {
        -: 5813:            {
    #####: 5814:              tmp___2 = ct_tally(0, (int)window[strstart - 1U]);
        -: 5815:            }
    #####: 5816:            if (tmp___2) {
    #####: 5817:              if (block_start >= 0L) {
    #####: 5818:                tmp___1 = (char *)(&window[(unsigned int)block_start]);
        -: 5819:              } else {
    #####: 5820:                tmp___1 = (char *)((void *)0);
        -: 5821:              }
        -: 5822:              {
    #####: 5823:                flush_block(tmp___1, (ulg)((long)strstart - block_start), 0);
    #####: 5824:                block_start = (long)strstart;
        -: 5825:              }
        -: 5826:            }
    #####: 5827:            strstart++;
    #####: 5828:            lookahead--;
        -: 5829:          } else {
    #####: 5830:            match_available = 1;
    #####: 5831:            strstart++;
    #####: 5832:            lookahead--;
        -: 5833:          }
        -: 5834:        }
        -: 5835:        {
        -: 5836:          while (1) {
    #####: 5837:          while_continue___1: /* CIL Label */;
    #####: 5838:            if (lookahead < 262U) {
    #####: 5839:              if (!(!eofile)) {
    #####: 5840:                goto while_break___1;
        -: 5841:              }
        -: 5842:            } else {
    #####: 5843:              goto while_break___1;
        -: 5844:            }
    #####: 5845:            { fill_window(); }
        -: 5846:          }
    #####: 5847:        while_break___1: /* CIL Label */;
        -: 5848:        }
        -: 5849:      }
    #####: 5850:    while_break: /* CIL Label */;
        -: 5851:    }
    #####: 5852:    if (match_available) {
        -: 5853:      {
    #####: 5854:        ct_tally(0, (int)window[strstart - 1U]);
        -: 5855:      }
        -: 5856:    }
    #####: 5857:    if (block_start >= 0L) {
    #####: 5858:      tmp___3 = (char *)(&window[(unsigned int)block_start]);
        -: 5859:    } else {
    #####: 5860:      tmp___3 = (char *)((void *)0);
        -: 5861:    }
    #####: 5862:    { tmp___4 = flush_block(tmp___3, (ulg)((long)strstart - block_start), 1); }
    #####: 5863:    return (tmp___4);
        -: 5864:  }
        -: 5865:}
        -: 5866:long header_bytes;
        -: 5867:long time_stamp;
        -: 5868:int save_orig_name;
        -: 5869:int zip(int in, int out);
        -: 5870:static ulg crc___0;
    #####: 5871:int zip(int in, int out) {
        -: 5872:  uch flags___0;
        -: 5873:  ush attr;
        -: 5874:  ush deflate_flags;
        -: 5875:  unsigned int tmp;
        -: 5876:  unsigned int tmp___0;
        -: 5877:  unsigned int tmp___1;
        -: 5878:  unsigned int tmp___2;
        -: 5879:  unsigned int tmp___3;
        -: 5880:  unsigned int tmp___4;
        -: 5881:  unsigned int tmp___5;
        -: 5882:  unsigned int tmp___6;
        -: 5883:  unsigned int tmp___7;
        -: 5884:  unsigned int tmp___8;
        -: 5885:  unsigned int tmp___9;
        -: 5886:  unsigned int tmp___10;
        -: 5887:  unsigned int tmp___11;
        -: 5888:  unsigned int tmp___12;
        -: 5889:  char *p;
        -: 5890:  char *tmp___13;
        -: 5891:  unsigned int tmp___14;
        -: 5892:  char *tmp___15;
        -: 5893:  unsigned int tmp___16;
        -: 5894:  unsigned int tmp___17;
        -: 5895:  unsigned int tmp___18;
        -: 5896:  unsigned int tmp___19;
        -: 5897:  unsigned int tmp___20;
        -: 5898:  unsigned int tmp___21;
        -: 5899:  unsigned int tmp___22;
        -: 5900:  unsigned int tmp___23;
        -: 5901:  unsigned int tmp___24;
        -: 5902:  unsigned int tmp___25;
        -: 5903:  unsigned int tmp___26;
        -: 5904:  unsigned int tmp___27;
        -: 5905:  unsigned int tmp___28;
        -: 5906:  unsigned int tmp___29;
        -: 5907:  unsigned int tmp___30;
        -: 5908:  unsigned int tmp___31;
        -: 5909:  char *__cil_tmp40;
        -: 5910:  char *__cil_tmp41;
        -: 5911:
        -: 5912:  {
    #####: 5913:    flags___0 = (uch)0;
    #####: 5914:    attr = (ush)0;
    #####: 5915:    deflate_flags = (ush)0;
    #####: 5916:    ifd = in;
    #####: 5917:    ofd = out;
    #####: 5918:    outcnt = 0U;
    #####: 5919:    method = 8;
    #####: 5920:    tmp = outcnt;
    #####: 5921:    outcnt++;
    #####: 5922:    outbuf[tmp] = (uch) * ("\037\213" + 0);
    #####: 5923:    if (outcnt == 16384U) {
        -: 5924:      {
    #####: 5925:        flush_outbuf();
        -: 5926:      }
        -: 5927:    }
    #####: 5928:    tmp___0 = outcnt;
    #####: 5929:    outcnt++;
    #####: 5930:    outbuf[tmp___0] = (uch) * ("\037\213" + 1);
    #####: 5931:    if (outcnt == 16384U) {
        -: 5932:      {
    #####: 5933:        flush_outbuf();
        -: 5934:      }
        -: 5935:    }
    #####: 5936:    tmp___1 = outcnt;
    #####: 5937:    outcnt++;
    #####: 5938:    outbuf[tmp___1] = (uch)8;
    #####: 5939:    if (outcnt == 16384U) {
        -: 5940:      {
    #####: 5941:        flush_outbuf();
        -: 5942:      }
        -: 5943:    }
    #####: 5944:    if (save_orig_name) {
    #####: 5945:      flags___0 = (uch)((int)flags___0 | 8);
        -: 5946:    }
    #####: 5947:    tmp___2 = outcnt;
    #####: 5948:    outcnt++;
    #####: 5949:    outbuf[tmp___2] = flags___0;
    #####: 5950:    if (outcnt == 16384U) {
        -: 5951:      {
    #####: 5952:        flush_outbuf();
        -: 5953:      }
        -: 5954:    }
    #####: 5955:    if (outcnt < 16382U) {
    #####: 5956:      tmp___3 = outcnt;
    #####: 5957:      outcnt++;
    #####: 5958:      outbuf[tmp___3] = (uch)((time_stamp & 65535L) & 255L);
    #####: 5959:      tmp___4 = outcnt;
    #####: 5960:      outcnt++;
    #####: 5961:      outbuf[tmp___4] = (uch)((int)((ush)(time_stamp & 65535L)) >> 8);
        -: 5962:    } else {
    #####: 5963:      tmp___5 = outcnt;
    #####: 5964:      outcnt++;
    #####: 5965:      outbuf[tmp___5] = (uch)((time_stamp & 65535L) & 255L);
    #####: 5966:      if (outcnt == 16384U) {
        -: 5967:        {
    #####: 5968:          flush_outbuf();
        -: 5969:        }
        -: 5970:      }
    #####: 5971:      tmp___6 = outcnt;
    #####: 5972:      outcnt++;
    #####: 5973:      outbuf[tmp___6] = (uch)((int)((ush)(time_stamp & 65535L)) >> 8);
    #####: 5974:      if (outcnt == 16384U) {
        -: 5975:        {
    #####: 5976:          flush_outbuf();
        -: 5977:        }
        -: 5978:      }
        -: 5979:    }
    #####: 5980:    if (outcnt < 16382U) {
    #####: 5981:      tmp___7 = outcnt;
    #####: 5982:      outcnt++;
    #####: 5983:      outbuf[tmp___7] = (uch)(((ulg)time_stamp >> 16) & 255UL);
    #####: 5984:      tmp___8 = outcnt;
    #####: 5985:      outcnt++;
    #####: 5986:      outbuf[tmp___8] = (uch)((int)((ush)((ulg)time_stamp >> 16)) >> 8);
        -: 5987:    } else {
    #####: 5988:      tmp___9 = outcnt;
    #####: 5989:      outcnt++;
    #####: 5990:      outbuf[tmp___9] = (uch)(((ulg)time_stamp >> 16) & 255UL);
    #####: 5991:      if (outcnt == 16384U) {
        -: 5992:        {
    #####: 5993:          flush_outbuf();
        -: 5994:        }
        -: 5995:      }
    #####: 5996:      tmp___10 = outcnt;
    #####: 5997:      outcnt++;
    #####: 5998:      outbuf[tmp___10] = (uch)((int)((ush)((ulg)time_stamp >> 16)) >> 8);
    #####: 5999:      if (outcnt == 16384U) {
        -: 6000:        {
    #####: 6001:          flush_outbuf();
        -: 6002:        }
        -: 6003:      }
        -: 6004:    }
        -: 6005:    {
    #####: 6006:      crc___0 = updcrc((uch *)0, 0U);
    #####: 6007:      bi_init(out);
    #####: 6008:      ct_init(&attr, &method);
    #####: 6009:      lm_init(level, &deflate_flags);
    #####: 6010:      tmp___11 = outcnt;
    #####: 6011:      outcnt++;
    #####: 6012:      outbuf[tmp___11] = (uch)deflate_flags;
        -: 6013:    }
    #####: 6014:    if (outcnt == 16384U) {
        -: 6015:      {
    #####: 6016:        flush_outbuf();
        -: 6017:      }
        -: 6018:    }
    #####: 6019:    tmp___12 = outcnt;
    #####: 6020:    outcnt++;
    #####: 6021:    outbuf[tmp___12] = (uch)3;
    #####: 6022:    if (outcnt == 16384U) {
        -: 6023:      {
    #####: 6024:        flush_outbuf();
        -: 6025:      }
        -: 6026:    }
    #####: 6027:    if (save_orig_name) {
        -: 6028:      {
    #####: 6029:        tmp___13 = basename(ifname);
    #####: 6030:        p = tmp___13;
        -: 6031:      }
        -: 6032:      {
        -: 6033:        while (1) {
    #####: 6034:        while_continue: /* CIL Label */;
    #####: 6035:          tmp___14 = outcnt;
    #####: 6036:          outcnt++;
    #####: 6037:          outbuf[tmp___14] = (uch)*p;
    #####: 6038:          if (outcnt == 16384U) {
        -: 6039:            {
    #####: 6040:              flush_outbuf();
        -: 6041:            }
        -: 6042:          }
    #####: 6043:          tmp___15 = p;
    #####: 6044:          p++;
    #####: 6045:          if (!*tmp___15) {
    #####: 6046:            goto while_break;
        -: 6047:          }
        -: 6048:        }
    #####: 6049:      while_break: /* CIL Label */;
        -: 6050:      }
        -: 6051:    }
        -: 6052:    {
    #####: 6053:      header_bytes = (long)outcnt;
    #####: 6054:      deflate();
        -: 6055:    }
    #####: 6056:    if (outcnt < 16382U) {
    #####: 6057:      tmp___16 = outcnt;
    #####: 6058:      outcnt++;
    #####: 6059:      outbuf[tmp___16] = (uch)((crc___0 & 65535UL) & 255UL);
    #####: 6060:      tmp___17 = outcnt;
    #####: 6061:      outcnt++;
    #####: 6062:      outbuf[tmp___17] = (uch)((int)((ush)(crc___0 & 65535UL)) >> 8);
        -: 6063:    } else {
    #####: 6064:      tmp___18 = outcnt;
    #####: 6065:      outcnt++;
    #####: 6066:      outbuf[tmp___18] = (uch)((crc___0 & 65535UL) & 255UL);
    #####: 6067:      if (outcnt == 16384U) {
        -: 6068:        {
    #####: 6069:          flush_outbuf();
        -: 6070:        }
        -: 6071:      }
    #####: 6072:      tmp___19 = outcnt;
    #####: 6073:      outcnt++;
    #####: 6074:      outbuf[tmp___19] = (uch)((int)((ush)(crc___0 & 65535UL)) >> 8);
    #####: 6075:      if (outcnt == 16384U) {
        -: 6076:        {
    #####: 6077:          flush_outbuf();
        -: 6078:        }
        -: 6079:      }
        -: 6080:    }
    #####: 6081:    if (outcnt < 16382U) {
    #####: 6082:      tmp___20 = outcnt;
    #####: 6083:      outcnt++;
    #####: 6084:      outbuf[tmp___20] = (uch)((crc___0 >> 16) & 255UL);
    #####: 6085:      tmp___21 = outcnt;
    #####: 6086:      outcnt++;
    #####: 6087:      outbuf[tmp___21] = (uch)((int)((ush)(crc___0 >> 16)) >> 8);
        -: 6088:    } else {
    #####: 6089:      tmp___22 = outcnt;
    #####: 6090:      outcnt++;
    #####: 6091:      outbuf[tmp___22] = (uch)((crc___0 >> 16) & 255UL);
    #####: 6092:      if (outcnt == 16384U) {
        -: 6093:        {
    #####: 6094:          flush_outbuf();
        -: 6095:        }
        -: 6096:      }
    #####: 6097:      tmp___23 = outcnt;
    #####: 6098:      outcnt++;
    #####: 6099:      outbuf[tmp___23] = (uch)((int)((ush)(crc___0 >> 16)) >> 8);
    #####: 6100:      if (outcnt == 16384U) {
        -: 6101:        {
    #####: 6102:          flush_outbuf();
        -: 6103:        }
        -: 6104:      }
        -: 6105:    }
    #####: 6106:    if (outcnt < 16382U) {
    #####: 6107:      tmp___24 = outcnt;
    #####: 6108:      outcnt++;
    #####: 6109:      outbuf[tmp___24] = (uch)((bytes_in & 65535L) & 255L);
    #####: 6110:      tmp___25 = outcnt;
    #####: 6111:      outcnt++;
    #####: 6112:      outbuf[tmp___25] = (uch)((int)((ush)(bytes_in & 65535L)) >> 8);
        -: 6113:    } else {
    #####: 6114:      tmp___26 = outcnt;
    #####: 6115:      outcnt++;
    #####: 6116:      outbuf[tmp___26] = (uch)((bytes_in & 65535L) & 255L);
    #####: 6117:      if (outcnt == 16384U) {
        -: 6118:        {
    #####: 6119:          flush_outbuf();
        -: 6120:        }
        -: 6121:      }
    #####: 6122:      tmp___27 = outcnt;
    #####: 6123:      outcnt++;
    #####: 6124:      outbuf[tmp___27] = (uch)((int)((ush)(bytes_in & 65535L)) >> 8);
    #####: 6125:      if (outcnt == 16384U) {
        -: 6126:        {
    #####: 6127:          flush_outbuf();
        -: 6128:        }
        -: 6129:      }
        -: 6130:    }
    #####: 6131:    if (outcnt < 16382U) {
    #####: 6132:      tmp___28 = outcnt;
    #####: 6133:      outcnt++;
    #####: 6134:      outbuf[tmp___28] = (uch)(((ulg)bytes_in >> 16) & 255UL);
    #####: 6135:      tmp___29 = outcnt;
    #####: 6136:      outcnt++;
    #####: 6137:      outbuf[tmp___29] = (uch)((int)((ush)((ulg)bytes_in >> 16)) >> 8);
        -: 6138:    } else {
    #####: 6139:      tmp___30 = outcnt;
    #####: 6140:      outcnt++;
    #####: 6141:      outbuf[tmp___30] = (uch)(((ulg)bytes_in >> 16) & 255UL);
    #####: 6142:      if (outcnt == 16384U) {
        -: 6143:        {
    #####: 6144:          flush_outbuf();
        -: 6145:        }
        -: 6146:      }
    #####: 6147:      tmp___31 = outcnt;
    #####: 6148:      outcnt++;
    #####: 6149:      outbuf[tmp___31] = (uch)((int)((ush)((ulg)bytes_in >> 16)) >> 8);
    #####: 6150:      if (outcnt == 16384U) {
        -: 6151:        {
    #####: 6152:          flush_outbuf();
        -: 6153:        }
        -: 6154:      }
        -: 6155:    }
        -: 6156:    {
    #####: 6157:      header_bytes = (long)((unsigned long)header_bytes + 2UL * sizeof(long));
    #####: 6158:      flush_outbuf();
        -: 6159:    }
    #####: 6160:    return (0);
        -: 6161:  }
        -: 6162:}
    #####: 6163:int file_read(char *buf, unsigned int size) {
        -: 6164:  unsigned int len;
        -: 6165:
        -: 6166:  {
    #####: 6167:    { len = (unsigned int)read(ifd, (void *)buf, (size_t)size); }
    #####: 6168:    if (len == 4294967295U) {
    #####: 6169:      return ((int)len);
        -: 6170:    } else {
    #####: 6171:      if (len == 0U) {
    #####: 6172:        return ((int)len);
        -: 6173:      }
        -: 6174:    }
        -: 6175:    {
    #####: 6176:      crc___0 = updcrc((uch *)buf, len);
    #####: 6177:      bytes_in = (long)((ulg)bytes_in + (ulg)len);
        -: 6178:    }
    #####: 6179:    return ((int)len);
        -: 6180:  }
        -: 6181:}
        -: 6182:static char *license_msg[15] = {
        -: 6183:    (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",
        -: 6184:    (char *)"   This program is free software; you can redistribute it and/or "
        -: 6185:            "modify",
        -: 6186:    (char *)"   it under the terms of the GNU General Public License as "
        -: 6187:            "published by",
        -: 6188:    (char *)"   the Free Software Foundation; either version 2, or (at your "
        -: 6189:            "option)",
        -: 6190:    (char *)"   any later version.",
        -: 6191:    (char *)"",
        -: 6192:    (char
        -: 6193:         *)"   This program is distributed in the hope that it will be useful,",
        -: 6194:    (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of",
        -: 6195:    (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
        -: 6196:    (char *)"   GNU General Public License for more details.",
        -: 6197:    (char *)"",
        -: 6198:    (char *)"   You should have received a copy of the GNU General Public "
        -: 6199:            "License",
        -: 6200:    (char *)"   along with this program; if not, write to the Free Software",
        -: 6201:    (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
        -: 6202:    (char *)0};
        -: 6203:extern __attribute__((__nothrow__))
        -: 6204:__sighandler_t(__attribute__((__leaf__)) signal)(int __sig,
        -: 6205:                                                 void (*__handler)(int));
        -: 6206:extern __attribute__((__nothrow__)) int(
        -: 6207:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6208:    stat)(char const *__restrict __file, struct stat *__restrict __buf);
        -: 6209:extern
        -: 6210:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(2), __leaf__))
        -: 6211:                                     fstat)(int __fd, struct stat *__buf);
        -: 6212:extern __attribute__((__nothrow__)) int(
        -: 6213:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6214:    lstat)(char const *__restrict __file, struct stat *__restrict __buf);
        -: 6215:extern
        -: 6216:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 6217:                                     chmod)(char const *__file,
        -: 6218:                                            __mode_t __mode);
        -: 6219:extern struct _IO_FILE *stdin;
        -: 6220:extern struct _IO_FILE *stdout;
        -: 6221:extern int fflush(FILE *__stream);
        -: 6222:extern int printf(char const *__restrict __format, ...);
        -: 6223:extern char *fgets(char *__restrict __s, int __n, FILE *__restrict __stream);
        -: 6224:extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
        -: 6225:                                        fileno)(FILE *__stream);
        -: 6226:extern __attribute__((__nothrow__)) int(
        -: 6227:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6228:    memcmp)(void const *__s1, void const *__s2, size_t __n)
        -: 6229:    __attribute__((__pure__));
        -: 6230:extern __attribute__((__nothrow__)) char *(
        -: 6231:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6232:    strncpy)(char *__restrict __dest, char const *__restrict __src, size_t __n);
        -: 6233:extern __attribute__((__nothrow__)) char *(
        -: 6234:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6235:    strcat)(char *__restrict __dest, char const *__restrict __src);
        -: 6236:extern __attribute__((__nothrow__)) int(
        -: 6237:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6238:    strcmp)(char const *__s1, char const *__s2) __attribute__((__pure__));
        -: 6239:extern __attribute__((__nothrow__)) int(
        -: 6240:    __attribute__((__nonnull__(1, 2), __leaf__))
        -: 6241:    strncmp)(char const *__s1, char const *__s2, size_t __n)
        -: 6242:    __attribute__((__pure__));
        -: 6243:long ifile_size;
        -: 6244:int verbose;
        -: 6245:extern char *optarg;
        -: 6246:extern int optind;
        -: 6247:extern int getopt_long(int argc, char *const *argv, char const *shortopts,
        -: 6248:                       struct option const *longopts, int *longind);
        -: 6249:extern __attribute__((__nothrow__)) char *(__attribute__((__leaf__))
        -: 6250:                                           ctime)(time_t const *__timer);
        -: 6251:extern int(__attribute__((__nonnull__(1))) open)(char const *__file,
        -: 6252:                                                 int __oflag, ...);
        -: 6253:extern __attribute__((__nothrow__))
        -: 6254:__off_t(__attribute__((__leaf__)) lseek)(int __fd, __off_t __offset,
        -: 6255:                                         int __whence);
        -: 6256:extern int close(int __fd);
        -: 6257:extern
        -: 6258:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 6259:                                     chown)(char const *__file, __uid_t __owner,
        -: 6260:                                            __gid_t __group);
        -: 6261:extern __attribute__((__nothrow__)) int(__attribute__((__leaf__))
        -: 6262:                                        isatty)(int __fd);
        -: 6263:extern
        -: 6264:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 6265:                                     unlink)(char const *__name);
        -: 6266:extern
        -: 6267:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 6268:                                     atoi)(char const *__nptr)
        -: 6269:        __attribute__((__pure__));
        -: 6270:extern __attribute__((__nothrow__, __noreturn__)) void(__attribute__((__leaf__))
        -: 6271:                                                       exit)(int __status);
        -: 6272:extern DIR *(__attribute__((__nonnull__(1))) opendir)(char const *__name);
        -: 6273:extern int(__attribute__((__nonnull__(1))) closedir)(DIR *__dirp);
        -: 6274:extern struct dirent *(__attribute__((__nonnull__(1))) readdir)(DIR *__dirp);
        -: 6275:extern
        -: 6276:    __attribute__((__nothrow__)) int(__attribute__((__nonnull__(1), __leaf__))
        -: 6277:                                     utime)(char const *__file,
        -: 6278:                                            struct utimbuf const *__file_times);
        -: 6279:int ascii = 0;
        -: 6280:int to_stdout = 0;
        -: 6281:int decompress = 0;
        -: 6282:int force = 0;
        -: 6283:int no_name = -1;
        -: 6284:int no_time = -1;
        -: 6285:int recursive = 0;
        -: 6286:int list = 0;
        -: 6287:int verbose = 0;
        -: 6288:int quiet = 0;
        -: 6289:int do_lzw = 0;
        -: 6290:int test = 0;
        -: 6291:int foreground;
        -: 6292:int maxbits = 16;
        -: 6293:int method = 8;
        -: 6294:int level = 6;
        -: 6295:int exit_code = 0;
        -: 6296:int last_member;
        -: 6297:int part_nb;
        -: 6298:char *env;
        -: 6299:char **args = (char **)((void *)0);
        -: 6300:char z_suffix[31];
        -: 6301:int z_len;
        -: 6302:long total_in = 0L;
        -: 6303:long total_out = 0L;
        -: 6304:int remove_ofname = 0;
        -: 6305:struct stat istat;
        -: 6306:struct option longopts[24] = {
        -: 6307:    {"ascii", 0, (int *)0, 'a'},      {"to-stdout", 0, (int *)0, 'c'},
        -: 6308:    {"stdout", 0, (int *)0, 'c'},     {"decompress", 0, (int *)0, 'd'},
        -: 6309:    {"uncompress", 0, (int *)0, 'd'}, {"force", 0, (int *)0, 'f'},
        -: 6310:    {"help", 0, (int *)0, 'h'},       {"list", 0, (int *)0, 'l'},
        -: 6311:    {"license", 0, (int *)0, 'L'},    {"no-name", 0, (int *)0, 'n'},
        -: 6312:    {"name", 0, (int *)0, 'N'},       {"quiet", 0, (int *)0, 'q'},
        -: 6313:    {"silent", 0, (int *)0, 'q'},     {"recursive", 0, (int *)0, 'r'},
        -: 6314:    {"suffix", 1, (int *)0, 'S'},     {"test", 0, (int *)0, 't'},
        -: 6315:    {"no-time", 0, (int *)0, 'T'},    {"verbose", 0, (int *)0, 'v'},
        -: 6316:    {"version", 0, (int *)0, 'V'},    {"fast", 0, (int *)0, '1'},
        -: 6317:    {"best", 0, (int *)0, '9'},       {"lzw", 0, (int *)0, 'Z'},
        -: 6318:    {"bits", 1, (int *)0, 'b'},       {(char const *)0, 0, (int *)0, 0}};
        -: 6319:static void usage(void);
        -: 6320:static void help(void);
        -: 6321:static void license(void);
        -: 6322:static void version(void);
        -: 6323:static void treat_stdin(void);
        -: 6324:static void treat_file(char *iname);
        -: 6325:static int create_outfile(void);
        -: 6326:static int do_stat(char *name, struct stat *sbuf);
        -: 6327:static char *get_suffix(char *name);
        -: 6328:static int get_istat(char *iname, struct stat *sbuf);
        -: 6329:static int make_ofname(void);
        -: 6330:static int same_file(struct stat *stat1, struct stat *stat2);
        -: 6331:static int name_too_long(char *name, struct stat *statb);
        -: 6332:static void shorten_name(char *name);
        -: 6333:static int get_method(int in);
        -: 6334:static void do_list(int ifd___0, int method___0);
        -: 6335:static int check_ofname(void);
        -: 6336:static void copy_stat(struct stat *ifstat);
        -: 6337:static void do_exit(int exitcode);
        -: 6338:int main(int argc, char **argv);
        -: 6339:int (*work)(int infile, int outfile) = &zip;
        -: 6340:static void treat_dir(char *dir);
        -: 6341:static void reset_times(char *name, struct stat *statb);
        1: 6342:static void usage(void) {
        -: 6343:
        -: 6344:  {
        -: 6345:    {
        1: 6346:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6347:              (char const * /* __restrict  */) "usage: %s [-%scdfhlLnN%stvV19] "
        -: 6348:                                               "[-S suffix] [file ...]\n",
        -: 6349:              progname, "", "r");
        -: 6350:    }
        1: 6351:    return;
        -: 6352:  }
        -: 6353:}
        -: 6354:static char *help_msg[18] = {
        -: 6355:    (char *)" -c --stdout      write on standard output, keep original files "
        -: 6356:            "unchanged",
        -: 6357:    (char *)" -d --decompress  decompress",
        -: 6358:    (char *)" -f --force       force overwrite of output file and compress "
        -: 6359:            "links",
        -: 6360:    (char *)" -h --help        give this help",
        -: 6361:    (char *)" -l --list        list compressed file contents",
        -: 6362:    (char *)" -L --license     display software license",
        -: 6363:    (char *)" -n --no-name     do not save or restore the original name and "
        -: 6364:            "time stamp",
        -: 6365:    (char
        -: 6366:         *)" -N --name        save or restore the original name and time stamp",
        -: 6367:    (char *)" -q --quiet       suppress all warnings",
        -: 6368:    (char *)" -r --recursive   operate recursively on directories",
        -: 6369:    (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",
        -: 6370:    (char *)" -t --test        test compressed file integrity",
        -: 6371:    (char *)" -v --verbose     verbose mode",
        -: 6372:    (char *)" -V --version     display version number",
        -: 6373:    (char *)" -1 --fast        compress faster",
        -: 6374:    (char *)" -9 --best        compress better",
        -: 6375:    (char *)" file...          files to (de)compress. If none given, use "
        -: 6376:            "standard input.",
        -: 6377:    (char *)0};
        1: 6378:static void help(void) {
        -: 6379:  char **p;
        -: 6380:  char **tmp;
        -: 6381:
        -: 6382:  {
        -: 6383:    {
        1: 6384:      p = help_msg;
        1: 6385:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6386:              (char const * /* __restrict  */) "%s %s (%s)\n", progname,
        -: 6387:              "1.2.4", "18 Aug 93");
        1: 6388:      usage();
        -: 6389:    }
        -: 6390:    {
        -: 6391:      while (1) {
       18: 6392:      while_continue: /* CIL Label */;
       18: 6393:        if (!*p) {
        1: 6394:          goto while_break;
        -: 6395:        }
        -: 6396:        {
       17: 6397:          tmp = p;
       17: 6398:          p++;
       17: 6399:          fprintf((FILE * /* __restrict  */) stderr,
        -: 6400:                  (char const * /* __restrict  */) "%s\n", *tmp);
        -: 6401:        }
        -: 6402:      }
        1: 6403:    while_break: /* CIL Label */;
        -: 6404:    }
        1: 6405:    return;
        -: 6406:  }
        -: 6407:}
    #####: 6408:static void license(void) {
        -: 6409:  char **p;
        -: 6410:  char **tmp;
        -: 6411:
        -: 6412:  {
        -: 6413:    {
    #####: 6414:      p = license_msg;
    #####: 6415:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6416:              (char const * /* __restrict  */) "%s %s (%s)\n", progname,
        -: 6417:              "1.2.4", "18 Aug 93");
        -: 6418:    }
        -: 6419:    {
        -: 6420:      while (1) {
    #####: 6421:      while_continue: /* CIL Label */;
    #####: 6422:        if (!*p) {
    #####: 6423:          goto while_break;
        -: 6424:        }
        -: 6425:        {
    #####: 6426:          tmp = p;
    #####: 6427:          p++;
    #####: 6428:          fprintf((FILE * /* __restrict  */) stderr,
        -: 6429:                  (char const * /* __restrict  */) "%s\n", *tmp);
        -: 6430:        }
        -: 6431:      }
    #####: 6432:    while_break: /* CIL Label */;
        -: 6433:    }
    #####: 6434:    return;
        -: 6435:  }
        -: 6436:}
    #####: 6437:static void version(void) {
        -: 6438:
        -: 6439:  {
        -: 6440:    {
    #####: 6441:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6442:              (char const * /* __restrict  */) "%s %s (%s)\n", progname,
        -: 6443:              "1.2.4", "18 Aug 93");
    #####: 6444:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6445:              (char const * /* __restrict  */) "Compilation options:\n%s %s ",
        -: 6446:              "DIRENT", "UTIME");
    #####: 6447:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6448:              (char const * /* __restrict  */) "STDC_HEADERS ");
    #####: 6449:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6450:              (char const * /* __restrict  */) "HAVE_UNISTD_H ");
    #####: 6451:      fprintf((FILE * /* __restrict  */) stderr,
        -: 6452:              (char const * /* __restrict  */) "\n");
        -: 6453:    }
    #####: 6454:    return;
        -: 6455:  }
        -: 6456:}
        -: 6458:  int file_count;
        -: 6459:  int proglen;
        -: 6460:  int optc;
        -: 6461:  int tmp;
        -: 6462:  void (*tmp___0)(int);
        -: 6463:  void (*tmp___1)(int);
        -: 6464:  void (*tmp___2)(int);
        -: 6465:  int tmp___3;
        -: 6466:  int tmp___4;
        -: 6467:  int tmp___5;
        -: 6468:  int tmp___6;
        -: 6469:  int tmp___7;
        -: 6470:  int tmp___8;
        -: 6471:  char *__cil_tmp19;
        -: 6472:  char *__cil_tmp20;
        -: 6473:
        -: 6474:  {
        -: 6475:    {
        -: 6478:    }
        -: 6480:      {
        -: 6482:      }
    #####: 6484:        *(progname + (proglen - 4)) = (char)'\000';
        -: 6485:      }
        -: 6486:    }
    #####: 6489:      args = argv;
        -: 6490:    }
        -: 6491:    {
        -: 6494:    }
        -: 6496:      {
        -: 6498:      }
        -: 6499:    }
        -: 6502:      {
        -: 6504:      }
        -: 6505:    }
        -: 6508:      {
        -: 6510:      }
        -: 6511:    }
    #####: 6514:      decompress = 1;
        -: 6515:    } else {
    #####: 6518:        decompress = 1;
        -: 6519:      } else {
    #####: 6522:          to_stdout = 1;
    #####: 6523:          decompress = to_stdout;
        -: 6524:        } else {
    #####: 6527:            to_stdout = 1;
    #####: 6528:            decompress = to_stdout;
        -: 6529:          }
        -: 6530:        }
        -: 6531:      }
        -: 6532:    }
        -: 6533:    {
        -: 6535:              (char const * /* __restrict  */) ".gz", sizeof(z_suffix) - 1UL);
        -: 6537:    }
        -: 6538:    {
        -: 6539:      while (1) {
        -: 6541:        {
        -: 6543:                             "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
        -: 6544:                             (struct option const *)(longopts), (int *)0);
        -: 6545:        }
        -: 6548:        }
        -: 6549:        {
    #####: 6551:            goto case_97;
        -: 6552:          }
    #####: 6554:            goto case_98;
        -: 6555:          }
    #####: 6557:            goto case_99;
        -: 6558:          }
    #####: 6560:            goto case_100;
        -: 6561:          }
    #####: 6563:            goto case_102;
        -: 6564:          }
        1: 6566:            goto case_104;
        -: 6567:          }
    #####: 6569:            goto case_104;
        -: 6570:          }
    #####: 6572:            goto case_104;
        -: 6573:          }
    #####: 6575:            goto case_108;
        -: 6576:          }
    #####: 6578:            goto case_76;
        -: 6579:          }
    #####: 6581:            goto case_109;
        -: 6582:          }
    #####: 6584:            goto case_77;
        -: 6585:          }
    #####: 6587:            goto case_110;
        -: 6588:          }
    #####: 6590:            goto case_78;
        -: 6591:          }
    #####: 6593:            goto case_113;
        -: 6594:          }
    #####: 6596:            goto case_114;
        -: 6597:          }
    #####: 6599:            goto case_83;
        -: 6600:          }
    #####: 6602:            goto case_116;
        -: 6603:          }
    #####: 6605:            goto case_118;
        -: 6606:          }
    #####: 6608:            goto case_86;
        -: 6609:          }
    #####: 6611:            goto case_90;
        -: 6612:          }
    #####: 6614:            goto case_49;
        -: 6615:          }
    #####: 6617:            goto case_49;
        -: 6618:          }
    #####: 6620:            goto case_49;
        -: 6621:          }
    #####: 6623:            goto case_49;
        -: 6624:          }
    #####: 6626:            goto case_49;
        -: 6627:          }
    #####: 6629:            goto case_49;
        -: 6630:          }
    #####: 6632:            goto case_49;
        -: 6633:          }
    #####: 6635:            goto case_49;
        -: 6636:          }
        -: 6639:          }
    #####: 6640:          goto switch_default;
    #####: 6641:        case_97: /* CIL Label */
    #####: 6642:          ascii = 1;
    #####: 6643:          goto switch_break;
    #####: 6644:        case_98 : /* CIL Label */
        -: 6645:        {
    #####: 6646:          maxbits = atoi((char const *)optarg);
        -: 6647:        }
    #####: 6648:          goto switch_break;
    #####: 6649:        case_99: /* CIL Label */
    #####: 6650:          to_stdout = 1;
    #####: 6651:          goto switch_break;
    #####: 6652:        case_100: /* CIL Label */
    #####: 6653:          decompress = 1;
    #####: 6654:          goto switch_break;
    #####: 6655:        case_102: /* CIL Label */
    #####: 6656:          force++;
    #####: 6657:          goto switch_break;
        1: 6658:        case_104: /* CIL Label */
        1: 6659:        case_72:  /* CIL Label */
        1: 6660:        case_63 : /* CIL Label */
        -: 6661:        {
        1: 6662:          help();
        1: 6663:          do_exit(0);
        -: 6664:        }
    #####: 6665:          goto switch_break;
    #####: 6666:        case_108: /* CIL Label */
    #####: 6667:          to_stdout = 1;
    #####: 6668:          decompress = to_stdout;
    #####: 6669:          list = decompress;
    #####: 6670:          goto switch_break;
    #####: 6671:        case_76 : /* CIL Label */
        -: 6672:        {
    #####: 6673:          license();
    #####: 6674:          do_exit(0);
        -: 6675:        }
    #####: 6676:          goto switch_break;
    #####: 6677:        case_109: /* CIL Label */
    #####: 6678:          no_time = 1;
    #####: 6679:          goto switch_break;
    #####: 6680:        case_77: /* CIL Label */
    #####: 6681:          no_time = 0;
    #####: 6682:          goto switch_break;
    #####: 6683:        case_110: /* CIL Label */
    #####: 6684:          no_time = 1;
    #####: 6685:          no_name = no_time;
    #####: 6686:          goto switch_break;
    #####: 6687:        case_78: /* CIL Label */
    #####: 6688:          no_time = 0;
    #####: 6689:          no_name = no_time;
    #####: 6690:          goto switch_break;
    #####: 6691:        case_113: /* CIL Label */
    #####: 6692:          quiet = 1;
    #####: 6693:          verbose = 0;
    #####: 6694:          goto switch_break;
    #####: 6695:        case_114: /* CIL Label */
    #####: 6696:          recursive = 1;
    #####: 6697:          goto switch_break;
    #####: 6698:        case_83 : /* CIL Label */
        -: 6699:        {
    #####: 6700:          z_len = (int)strlen((char const *)optarg);
    #####: 6701:          strcpy((char * /* __restrict  */)(z_suffix),
        -: 6702:                 (char const * /* __restrict  */)optarg);
        -: 6703:        }
    #####: 6704:          goto switch_break;
    #####: 6705:        case_116: /* CIL Label */
    #####: 6706:          to_stdout = 1;
    #####: 6707:          decompress = to_stdout;
    #####: 6708:          test = decompress;
    #####: 6709:          goto switch_break;
    #####: 6710:        case_118: /* CIL Label */
    #####: 6711:          verbose++;
    #####: 6712:          quiet = 0;
    #####: 6713:          goto switch_break;
    #####: 6714:        case_86 : /* CIL Label */
        -: 6715:        {
    #####: 6716:          version();
    #####: 6717:          do_exit(0);
        -: 6718:        }
    #####: 6719:          goto switch_break;
    #####: 6720:        case_90 : /* CIL Label */
        -: 6721:        {
    #####: 6722:          fprintf((FILE * /* __restrict  */) stderr,
        -: 6723:                  (char const * /* __restrict  */) "%s: -Z not supported in "
        -: 6724:                                                   "this version\n",
        -: 6725:                  progname);
    #####: 6726:          usage();
    #####: 6727:          do_exit(1);
        -: 6728:        }
    #####: 6729:          goto switch_break;
    #####: 6741:        switch_default : /* CIL Label */
        -: 6742:        {
    #####: 6743:          usage();
    #####: 6744:          do_exit(1);
        -: 6745:        }
        -: 6747:        }
        -: 6748:      }
        -: 6750:    }
        -: 6753:    }
        -: 6756:    }
    #####: 6759:      if (!quiet) {
        -: 6760:        {
    #####: 6761:          fprintf((FILE * /* __restrict  */) stderr,
        -: 6762:                  (char const * /* __restrict  */) "%s: option --ascii ignored "
        -: 6763:                                                   "on this system\n",
        -: 6764:                  progname);
        -: 6765:        }
        -: 6766:      }
        -: 6767:    }
    #####: 6769:      if (!decompress) {
        -: 6770:        {
    #####: 6771:          fprintf(
        -: 6772:              (FILE * /* __restrict  */) stderr,
        -: 6773:              (char const * /* __restrict  */) "%s: incorrect suffix \'%s\'\n",
        -: 6774:              progname, optarg);
    #####: 6775:          do_exit(1);
        -: 6776:        }
        -: 6777:      } else {
    #####: 6778:        goto _L;
        -: 6779:      }
        -: 6780:    } else {
        -: 6783:        {
    #####: 6784:          fprintf(
        -: 6785:              (FILE * /* __restrict  */) stderr,
        -: 6786:              (char const * /* __restrict  */) "%s: incorrect suffix \'%s\'\n",
        -: 6787:              progname, optarg);
    #####: 6788:          do_exit(1);
        -: 6789:        }
        -: 6790:      }
        -: 6791:    }
    #####: 6793:      if (!decompress) {
    #####: 6794:        work = &lzw;
        -: 6795:      }
        -: 6796:    }
    #####: 6798:      if (to_stdout) {
    #####: 6799:        if (!test) {
    #####: 6800:          if (!list) {
    #####: 6801:            if (!decompress) {
    #####: 6802:              tmp___7 = 1;
        -: 6803:            } else {
    #####: 6804:              if (!ascii) {
    #####: 6805:                tmp___7 = 1;
        -: 6806:              } else {
    #####: 6807:                tmp___7 = 0;
        -: 6808:              }
        -: 6809:            }
        -: 6810:          } else {
    #####: 6811:            tmp___7 = 0;
        -: 6812:          }
        -: 6813:        } else {
    #####: 6814:          tmp___7 = 0;
        -: 6815:        }
        -: 6816:      } else {
    #####: 6817:        tmp___7 = 0;
        -: 6818:      }
        -: 6819:      {
        -: 6820:        while (1) {
    #####: 6821:        while_continue___0: /* CIL Label */;
    #####: 6822:          if (!(optind < argc)) {
    #####: 6823:            goto while_break___0;
        -: 6824:          }
        -: 6825:          {
    #####: 6826:            tmp___8 = optind;
    #####: 6827:            optind++;
    #####: 6828:            treat_file(*(argv + tmp___8));
        -: 6829:          }
        -: 6830:        }
    #####: 6831:      while_break___0: /* CIL Label */;
        -: 6832:      }
        -: 6833:    } else {
        -: 6835:    }
    #####: 6836:    if (list) {
    #####: 6837:      if (!quiet) {
    #####: 6838:        if (file_count > 1) {
        -: 6839:          {
    #####: 6840:            do_list(-1, -1);
        -: 6841:          }
        -: 6842:        }
        -: 6843:      }
        -: 6844:    }
    #####: 6845:    { do_exit(exit_code); }
    #####: 6846:    return (exit_code);
        -: 6847:  }
        -: 6848:}
        -: 6850:  char const *tmp;
        -: 6851:  char const *tmp___0;
        -: 6852:  struct _IO_FILE *tmp___1;
        -: 6853:  int tmp___2;
        -: 6854:  int tmp___3;
        -: 6855:  int tmp___4;
        -: 6856:  int tmp___5;
        -: 6857:  int tmp___6;
        -: 6858:  int tmp___7;
        -: 6859:  int tmp___8;
        -: 6860:  int tmp___9;
        -: 6861:  int tmp___10;
        -: 6862:  char *__cil_tmp13;
        -: 6863:  char *__cil_tmp14;
        -: 6864:  char *__cil_tmp15;
        -: 6865:  char *__cil_tmp16;
        -: 6866:  char *__cil_tmp17;
        -: 6867:  char *__cil_tmp18;
        -: 6868:  char *__cil_tmp19;
        -: 6869:
        -: 6870:  {
    #####: 6874:          tmp___1 = stdin;
        -: 6875:        } else {
        -: 6877:        }
        -: 6878:        {
        -: 6881:        }
    #####: 6884:            tmp = "de";
        -: 6885:          } else {
        -: 6887:          }
    #####: 6889:            tmp___0 = "read from";
        -: 6890:          } else {
        -: 6892:          }
        -: 6893:          {
        -: 6895:                    (char const * /* __restrict  */) "%s: compressed data not "
        -: 6896:                                                     "%s a terminal. Use -f to "
        -: 6897:                                                     "force %scompression.\n",
        -: 6898:                    progname, tmp___0, tmp);
        -: 6900:                    (char const * /* __restrict  */) "For help, type: %s -h\n",
        -: 6901:                    progname);
        -: 6903:          }
        -: 6904:        }
        -: 6905:      }
        -: 6906:    }
    #####: 6907:    if (decompress) {
    #####: 6908:      tmp___4 = 1;
        -: 6909:    } else {
    #####: 6910:      if (!ascii) {
    #####: 6911:        tmp___4 = 1;
        -: 6912:      } else {
    #####: 6913:        tmp___4 = 0;
        -: 6914:      }
        -: 6915:    }
    #####: 6916:    if (!test) {
    #####: 6917:      if (!list) {
    #####: 6918:        if (!decompress) {
    #####: 6919:          tmp___5 = 1;
        -: 6920:        } else {
    #####: 6921:          if (!ascii) {
    #####: 6922:            tmp___5 = 1;
        -: 6923:          } else {
    #####: 6924:            tmp___5 = 0;
        -: 6925:          }
        -: 6926:        }
        -: 6927:      } else {
    #####: 6928:        tmp___5 = 0;
        -: 6929:      }
        -: 6930:    } else {
    #####: 6931:      tmp___5 = 0;
        -: 6932:    }
        -: 6933:    {
    #####: 6934:      strcpy((char * /* __restrict  */)(ifname),
        -: 6935:             (char const * /* __restrict  */) "stdin");
    #####: 6936:      strcpy((char * /* __restrict  */)(ofname),
        -: 6937:             (char const * /* __restrict  */) "stdout");
    #####: 6938:      time_stamp = 0L;
        -: 6939:    }
    #####: 6940:    if (list) {
    #####: 6941:      goto _L;
        -: 6942:    } else {
    #####: 6943:      if (!no_time) {
    #####: 6944:      _L : {
    #####: 6945:        tmp___6 = fileno(stdin);
    #####: 6946:        tmp___7 = fstat(tmp___6, &istat);
        -: 6947:      }
    #####: 6948:        if (tmp___7 != 0) {
        -: 6949:          {
    #####: 6950:            error((char *)"fstat(stdin)");
        -: 6951:          }
        -: 6952:        }
    #####: 6953:        time_stamp = istat.st_mtim.tv_sec;
        -: 6954:      }
        -: 6955:    }
        -: 6956:    {
    #####: 6957:      ifile_size = -1L;
    #####: 6958:      clear_bufs();
    #####: 6959:      to_stdout = 1;
    #####: 6960:      part_nb = 0;
        -: 6961:    }
    #####: 6962:    if (decompress) {
        -: 6963:      {
    #####: 6964:        method = get_method(ifd);
        -: 6965:      }
    #####: 6966:      if (method < 0) {
        -: 6967:        {
    #####: 6968:          do_exit(exit_code);
        -: 6969:        }
        -: 6970:      }
        -: 6971:    }
    #####: 6972:    if (list) {
        -: 6973:      {
    #####: 6974:        do_list(ifd, method);
        -: 6975:      }
    #####: 6976:      return;
        -: 6977:    }
        -: 6978:    {
        -: 6979:      while (1) {
    #####: 6980:      while_continue: /* CIL Label */;
        -: 6981:        {
    #####: 6982:          tmp___8 = fileno(stdout);
    #####: 6983:          tmp___9 = fileno(stdin);
    #####: 6984:          tmp___10 = (*work)(tmp___9, tmp___8);
        -: 6985:        }
    #####: 6986:        if (tmp___10 != 0) {
    #####: 6987:          return;
        -: 6988:        }
    #####: 6989:        if (!decompress) {
    #####: 6990:          goto while_break;
        -: 6991:        } else {
    #####: 6992:          if (last_member) {
    #####: 6993:            goto while_break;
        -: 6994:          } else {
    #####: 6995:            if (inptr == insize) {
    #####: 6996:              goto while_break;
        -: 6997:            }
        -: 6998:          }
        -: 6999:        }
    #####: 7000:        { method = get_method(ifd); }
    #####: 7001:        if (method < 0) {
    #####: 7002:          return;
        -: 7003:        }
    #####: 7004:        bytes_out = 0L;
        -: 7005:      }
    #####: 7006:    while_break: /* CIL Label */;
        -: 7007:    }
    #####: 7008:    if (verbose) {
    #####: 7009:      if (test) {
        -: 7010:        {
    #####: 7011:          fprintf((FILE * /* __restrict  */) stderr,
        -: 7012:                  (char const * /* __restrict  */) " OK\n");
        -: 7013:        }
        -: 7014:      } else {
    #####: 7015:        if (!decompress) {
        -: 7016:          {
    #####: 7017:            display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in,
        -: 7018:                          stderr);
    #####: 7019:            fprintf((FILE * /* __restrict  */) stderr,
        -: 7020:                    (char const * /* __restrict  */) "\n");
        -: 7021:          }
        -: 7022:        }
        -: 7023:      }
        -: 7024:    }
    #####: 7025:    return;
        -: 7026:  }
        -: 7027:}
    #####: 7028:static void treat_file(char *iname) {
        -: 7029:  int cflag;
        -: 7030:  int tmp;
        -: 7031:  int tmp___0;
        -: 7032:  struct stat st;
        -: 7033:  int tmp___1;
        -: 7034:  int tmp___2;
        -: 7035:  int tmp___3;
        -: 7036:  int tmp___4;
        -: 7037:  char const *tmp___7;
        -: 7038:  size_t tmp___8;
        -: 7039:  char const *tmp___9;
        -: 7040:  size_t tmp___10;
        -: 7041:  int tmp___11;
        -: 7042:  int tmp___12;
        -: 7043:  void *__cil_tmp16;
        -: 7044:  char *__cil_tmp17;
        -: 7045:  char *__cil_tmp18;
        -: 7046:  char *__cil_tmp19;
        -: 7047:  char *__cil_tmp20;
        -: 7048:
        -: 7049:  {
    #####: 7050:    { tmp = strcmp((char const *)iname, "-"); }
    #####: 7051:    if (tmp == 0) {
        -: 7052:      {
    #####: 7053:        cflag = to_stdout;
    #####: 7054:        treat_stdin();
    #####: 7055:        to_stdout = cflag;
        -: 7056:      }
    #####: 7057:      return;
        -: 7058:    }
    #####: 7059:    { tmp___0 = get_istat(iname, &istat); }
    #####: 7060:    if (tmp___0 != 0) {
    #####: 7061:      return;
        -: 7062:    }
    #####: 7063:    if ((istat.st_mode & 61440U) == 16384U) {
    #####: 7064:      if (recursive) {
        -: 7065:        {
    #####: 7066:          st = istat;
    #####: 7067:          treat_dir(iname);
    #####: 7068:          reset_times(iname, &st);
        -: 7069:        }
        -: 7070:      } else {
    #####: 7071:        if (!quiet) {
        -: 7072:          {
    #####: 7073:            fprintf(
        -: 7074:                (FILE * /* __restrict  */) stderr,
        -: 7075:                (char const
        -: 7076:                     * /* __restrict  */) "%s: %s is a directory -- ignored\n",
        -: 7077:                progname, ifname);
        -: 7078:          }
        -: 7079:        }
    #####: 7080:        if (exit_code == 0) {
    #####: 7081:          exit_code = 2;
        -: 7082:        }
        -: 7083:      }
    #####: 7084:      return;
        -: 7085:    }
    #####: 7086:    if (!((istat.st_mode & 61440U) == 32768U)) {
    #####: 7087:      if (!quiet) {
        -: 7088:        {
    #####: 7089:          fprintf(
        -: 7090:              (FILE * /* __restrict  */) stderr,
        -: 7091:              (char const * /* __restrict  */) "%s: %s is not a directory or a "
        -: 7092:                                               "regular file - ignored\n",
        -: 7093:              progname, ifname);
        -: 7094:        }
        -: 7095:      }
    #####: 7096:      if (exit_code == 0) {
    #####: 7097:        exit_code = 2;
        -: 7098:      }
    #####: 7099:      return;
        -: 7100:    }
    #####: 7101:    if (istat.st_nlink > 1UL) {
    #####: 7102:      if (!to_stdout) {
    #####: 7103:        if (!force) {
    #####: 7104:          if (!quiet) {
    #####: 7105:            if (istat.st_nlink > 2UL) {
    #####: 7106:              tmp___1 = 's';
        -: 7107:            } else {
    #####: 7108:              tmp___1 = ' ';
        -: 7109:            }
        -: 7110:            {
    #####: 7111:              fprintf((FILE * /* __restrict  */) stderr,
        -: 7112:                      (char const * /* __restrict  */) "%s: %s has %d other "
        -: 7113:                                                       "link%c -- unchanged\n",
    #####: 7114:                      progname, ifname, (int)istat.st_nlink - 1, tmp___1);
        -: 7115:            }
        -: 7116:          }
    #####: 7117:          if (exit_code == 0) {
    #####: 7118:            exit_code = 2;
        -: 7119:          }
    #####: 7120:          return;
        -: 7121:        }
        -: 7122:      }
        -: 7123:    }
    #####: 7124:    ifile_size = istat.st_size;
    #####: 7125:    if (no_time) {
    #####: 7126:      if (!list) {
    #####: 7127:        time_stamp = 0L;
        -: 7128:      } else {
    #####: 7129:        time_stamp = istat.st_mtim.tv_sec;
        -: 7130:      }
        -: 7131:    } else {
    #####: 7132:      time_stamp = istat.st_mtim.tv_sec;
        -: 7133:    }
    #####: 7134:    if (to_stdout) {
    #####: 7135:      if (!list) {
    #####: 7136:        if (!test) {
        -: 7137:          {
    #####: 7138:            strcpy((char * /* __restrict  */)(ofname),
        -: 7139:                   (char const * /* __restrict  */) "stdout");
        -: 7140:          }
        -: 7141:        } else {
    #####: 7142:          goto _L___0;
        -: 7143:        }
        -: 7144:      } else {
    #####: 7145:        goto _L___0;
        -: 7146:      }
        -: 7147:    } else {
    #####: 7148:    _L___0 : { tmp___2 = make_ofname(); }
    #####: 7149:      if (tmp___2 != 0) {
    #####: 7150:        return;
        -: 7151:      }
        -: 7152:    }
    #####: 7153:    if (ascii) {
    #####: 7154:      if (!decompress) {
    #####: 7155:        tmp___3 = 0;
        -: 7156:      } else {
    #####: 7157:        tmp___3 = 0;
        -: 7158:      }
        -: 7159:    } else {
    #####: 7160:      tmp___3 = 0;
        -: 7161:    }
    #####: 7162:    { ifd = open((char const *)(ifname), tmp___3, 384); }
    #####: 7163:    if (ifd == -1) {
        -: 7164:      {
    #####: 7165:        fprintf((FILE * /* __restrict  */) stderr,
        -: 7166:                (char const * /* __restrict  */) "%s: ", progname);
    #####: 7167:        perror((char const *)(ifname));
    #####: 7168:        exit_code = 1;
        -: 7169:      }
    #####: 7170:      return;
        -: 7171:    }
        -: 7172:    {
    #####: 7173:      clear_bufs();
    #####: 7174:      part_nb = 0;
        -: 7175:    }
    #####: 7176:    if (decompress) {
        -: 7177:      {
    #####: 7178:        method = get_method(ifd);
        -: 7179:      }
    #####: 7180:      if (method < 0) {
        -: 7181:        {
    #####: 7182:          close(ifd);
        -: 7183:        }
    #####: 7184:        return;
        -: 7185:      }
        -: 7186:    }
    #####: 7187:    if (list) {
        -: 7188:      {
    #####: 7189:        do_list(ifd, method);
    #####: 7190:        close(ifd);
        -: 7191:      }
    #####: 7192:      return;
        -: 7193:    }
    #####: 7194:    if (to_stdout) {
        -: 7195:      {
    #####: 7196:        ofd = fileno(stdout);
        -: 7197:      }
        -: 7198:    } else {
    #####: 7199:      { tmp___4 = create_outfile(); }
    #####: 7200:      if (tmp___4 != 0) {
    #####: 7201:        return;
        -: 7202:      }
    #####: 7203:      if (!decompress) {
    #####: 7204:        if (save_orig_name) {
    #####: 7205:          if (!verbose) {
    #####: 7206:            if (!quiet) {
        -: 7207:              {
    #####: 7208:                fprintf((FILE * /* __restrict  */) stderr,
        -: 7209:                        (char const
        -: 7210:                             * /* __restrict  */) "%s: %s compressed to %s\n",
        -: 7211:                        progname, ifname, ofname);
        -: 7212:              }
        -: 7213:            }
        -: 7214:          }
        -: 7215:        }
        -: 7216:      }
        -: 7217:    }
    #####: 7218:    if (!save_orig_name) {
    #####: 7219:      save_orig_name = !no_name;
        -: 7220:    }
    #####: 7221:    if (verbose) {
        -: 7222:      {
    #####: 7223:        tmp___10 = strlen((char const *)(ifname));
        -: 7224:      }
    #####: 7225:      if ((int)tmp___10 >= 15) {
    #####: 7226:        tmp___9 = "";
        -: 7227:      } else {
    #####: 7228:        { tmp___8 = strlen((char const *)(ifname)); }
    #####: 7229:        if ((int)tmp___8 >= 7) {
    #####: 7230:          tmp___7 = "\t";
        -: 7231:        } else {
    #####: 7232:          tmp___7 = "\t\t";
        -: 7233:        }
    #####: 7234:        tmp___9 = tmp___7;
        -: 7235:      }
        -: 7236:      {
    #####: 7237:        fprintf((FILE * /* __restrict  */) stderr,
        -: 7238:                (char const * /* __restrict  */) "%s:\t%s", ifname, tmp___9);
        -: 7239:      }
        -: 7240:    }
        -: 7241:    {
        -: 7242:      while (1) {
    #####: 7243:      while_continue: /* CIL Label */;
    #####: 7244:        { tmp___11 = (*work)(ifd, ofd); }
    #####: 7245:        if (tmp___11 != 0) {
    #####: 7246:          method = -1;
    #####: 7247:          goto while_break;
        -: 7248:        }
    #####: 7249:        if (!decompress) {
    #####: 7250:          goto while_break;
        -: 7251:        } else {
    #####: 7252:          if (last_member) {
    #####: 7253:            goto while_break;
        -: 7254:          } else {
    #####: 7255:            if (inptr == insize) {
    #####: 7256:              goto while_break;
        -: 7257:            }
        -: 7258:          }
        -: 7259:        }
    #####: 7260:        { method = get_method(ifd); }
    #####: 7261:        if (method < 0) {
    #####: 7262:          goto while_break;
        -: 7263:        }
    #####: 7264:        bytes_out = 0L;
        -: 7265:      }
    #####: 7266:    while_break: /* CIL Label */;
        -: 7267:    }
    #####: 7268:    { close(ifd); }
    #####: 7269:    if (!to_stdout) {
        -: 7270:      {
    #####: 7271:        tmp___12 = close(ofd);
        -: 7272:      }
    #####: 7273:      if (tmp___12) {
        -: 7274:        {
    #####: 7275:          write_error();
        -: 7276:        }
        -: 7277:      }
        -: 7278:    }
    #####: 7279:    if (method == -1) {
    #####: 7280:      if (!to_stdout) {
        -: 7281:        {
    #####: 7282:          unlink((char const *)(ofname));
        -: 7283:        }
        -: 7284:      }
    #####: 7285:      return;
        -: 7286:    }
    #####: 7287:    if (verbose) {
    #####: 7288:      if (test) {
        -: 7289:        {
    #####: 7290:          fprintf((FILE * /* __restrict  */) stderr,
        -: 7291:                  (char const * /* __restrict  */) " OK");
        -: 7292:        }
        -: 7293:      } else {
    #####: 7294:        if (decompress) {
        -: 7295:          {
    #####: 7296:            display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out,
        -: 7297:                          stderr);
        -: 7298:          }
        -: 7299:        } else {
        -: 7300:          {
    #####: 7301:            display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in,
        -: 7302:                          stderr);
        -: 7303:          }
        -: 7304:        }
        -: 7305:      }
    #####: 7306:      if (!test) {
    #####: 7307:        if (!to_stdout) {
        -: 7308:          {
    #####: 7309:            fprintf((FILE * /* __restrict  */) stderr,
        -: 7310:                    (char const * /* __restrict  */) " -- replaced with %s",
        -: 7311:                    ofname);
        -: 7312:          }
        -: 7313:        }
        -: 7314:      }
        -: 7315:      {
    #####: 7316:        fprintf((FILE * /* __restrict  */) stderr,
        -: 7317:                (char const * /* __restrict  */) "\n");
        -: 7318:      }
        -: 7319:    }
    #####: 7320:    if (!to_stdout) {
        -: 7321:      {
    #####: 7322:        copy_stat(&istat);
        -: 7323:      }
        -: 7324:    }
    #####: 7325:    return;
        -: 7326:  }
        -: 7327:}
    #####: 7328:static int create_outfile(void) {
        -: 7329:  struct stat ostat;
        -: 7330:  int flags___0;
        -: 7331:  int tmp;
        -: 7332:  int tmp___0;
        -: 7333:  int tmp___1;
        -: 7334:  void *__cil_tmp6;
        -: 7335:
        -: 7336:  {
    #####: 7337:    flags___0 = 193;
    #####: 7338:    if (ascii) {
    #####: 7339:      if (decompress) {
    #####: 7340:        flags___0 &= -1;
        -: 7341:      }
        -: 7342:    }
        -: 7343:    {
        -: 7344:      while (1) {
    #####: 7345:      while_continue: /* CIL Label */;
    #####: 7346:        { tmp = check_ofname(); }
    #####: 7347:        if (tmp != 0) {
        -: 7348:          {
    #####: 7349:            close(ifd);
        -: 7350:          }
    #####: 7351:          return (1);
        -: 7352:        }
        -: 7353:        {
    #####: 7354:          remove_ofname = 1;
    #####: 7355:          ofd = open((char const *)(ofname), flags___0, 384);
        -: 7356:        }
    #####: 7357:        if (ofd == -1) {
        -: 7358:          {
    #####: 7359:            perror((char const *)(ofname));
    #####: 7360:            close(ifd);
    #####: 7361:            exit_code = 1;
        -: 7362:          }
    #####: 7363:          return (1);
        -: 7364:        }
    #####: 7365:        { tmp___0 = fstat(ofd, &ostat); }
    #####: 7366:        if (tmp___0 != 0) {
        -: 7367:          {
    #####: 7368:            fprintf((FILE * /* __restrict  */) stderr,
        -: 7369:                    (char const * /* __restrict  */) "%s: ", progname);
    #####: 7370:            perror((char const *)(ofname));
    #####: 7371:            close(ifd);
    #####: 7372:            close(ofd);
    #####: 7373:            unlink((char const *)(ofname));
    #####: 7374:            exit_code = 1;
        -: 7375:          }
    #####: 7376:          return (1);
        -: 7377:        }
    #####: 7378:        { tmp___1 = name_too_long(ofname, &ostat); }
    #####: 7379:        if (!tmp___1) {
    #####: 7380:          return (0);
        -: 7381:        }
    #####: 7382:        if (decompress) {
    #####: 7383:          if (!quiet) {
        -: 7384:            {
    #####: 7385:              fprintf(
        -: 7386:                  (FILE * /* __restrict  */) stderr,
        -: 7387:                  (char const
        -: 7388:                       * /* __restrict  */) "%s: %s: warning, name truncated\n",
        -: 7389:                  progname, ofname);
        -: 7390:            }
        -: 7391:          }
    #####: 7392:          if (exit_code == 0) {
    #####: 7393:            exit_code = 2;
        -: 7394:          }
    #####: 7395:          return (0);
        -: 7396:        }
        -: 7397:        {
    #####: 7398:          close(ofd);
    #####: 7399:          unlink((char const *)(ofname));
    #####: 7400:          shorten_name(ofname);
        -: 7401:        }
        -: 7402:      }
        -: 7403:    while_break: /* CIL Label */;
        -: 7404:    }
        -: 7405:  }
        -: 7406:}
    #####: 7407:static int do_stat(char *name, struct stat *sbuf) {
        -: 7408:  int *tmp;
        -: 7409:  int tmp___0;
        -: 7410:  int tmp___1;
        -: 7411:
        -: 7412:  {
        -: 7413:    {
    #####: 7414:      tmp = __errno_location();
    #####: 7415:      *tmp = 0;
        -: 7416:    }
    #####: 7417:    if (!to_stdout) {
    #####: 7418:      if (!force) {
        -: 7419:        {
    #####: 7420:          tmp___0 = lstat((char const * /* __restrict  */)name,
        -: 7421:                          (struct stat * /* __restrict  */) sbuf);
        -: 7422:        }
    #####: 7423:        return (tmp___0);
        -: 7424:      }
        -: 7425:    }
        -: 7426:    {
    #####: 7427:      tmp___1 = stat((char const * /* __restrict  */)name,
        -: 7428:                     (struct stat * /* __restrict  */) sbuf);
        -: 7429:    }
    #####: 7430:    return (tmp___1);
        -: 7431:  }
        -: 7432:}
        -: 7433:static char *known_suffixes[9] = {
        -: 7434:    z_suffix,       (char *)".gz",  (char *)".z",
        -: 7435:    (char *)".taz", (char *)".tgz", (char *)"-gz",
        -: 7436:    (char *)"-z",   (char *)"_z",   (char *)((void *)0)};
    #####: 7437:static char *get_suffix(char *name) {
        -: 7438:  int nlen;
        -: 7439:  int slen;
        -: 7440:  char suffix[33];
        -: 7441:  char **suf;
        -: 7442:  int tmp;
        -: 7443:  int s;
        -: 7444:  int tmp___0;
        -: 7445:  int tmp___1;
        -: 7446:  void *__cil_tmp13;
        -: 7447:
        -: 7448:  {
        -: 7449:    {
    #####: 7450:      suf = known_suffixes;
    #####: 7451:      tmp = strcmp((char const *)(z_suffix), "z");
        -: 7452:    }
    #####: 7453:    if (tmp == 0) {
    #####: 7454:      suf++;
        -: 7455:    }
    #####: 7456:    { nlen = (int)strlen((char const *)name); }
    #####: 7457:    if (nlen <= 32) {
        -: 7458:      {
    #####: 7459:        strcpy((char * /* __restrict  */)(suffix),
        -: 7460:               (char const * /* __restrict  */)name);
        -: 7461:      }
        -: 7462:    } else {
        -: 7463:      {
    #####: 7464:        strcpy((char * /* __restrict  */)(suffix),
    #####: 7465:               (char const * /* __restrict  */)(((name + nlen) - 30) - 2));
        -: 7466:      }
        -: 7467:    }
        -: 7468:    {
    #####: 7469:      strlwr(suffix);
    #####: 7470:      slen = (int)strlen((char const *)(suffix));
        -: 7471:    }
        -: 7472:    {
        -: 7473:      while (1) {
    #####: 7474:      while_continue: /* CIL Label */;
        -: 7475:        {
    #####: 7476:          tmp___0 = (int)strlen((char const *)*suf);
    #####: 7477:          s = tmp___0;
        -: 7478:        }
    #####: 7479:        if (slen > s) {
    #####: 7480:          if ((int)suffix[(slen - s) - 1] != 47) {
        -: 7481:            {
    #####: 7482:              tmp___1 = strcmp((char const *)((suffix + slen) - s),
        -: 7483:                               (char const *)*suf);
        -: 7484:            }
    #####: 7485:            if (tmp___1 == 0) {
    #####: 7486:              return ((name + nlen) - s);
        -: 7487:            }
        -: 7488:          }
        -: 7489:        }
    #####: 7490:        suf++;
    #####: 7491:        if (!((unsigned long)*suf != (unsigned long)((void *)0))) {
    #####: 7492:          goto while_break;
        -: 7493:        }
        -: 7494:      }
    #####: 7495:    while_break: /* CIL Label */;
        -: 7496:    }
    #####: 7497:    return ((char *)((void *)0));
        -: 7498:  }
        -: 7499:}
        -: 7500:static char *suffixes[6] = {z_suffix,     (char *)".gz", (char *)".z",
        -: 7501:                            (char *)"-z", (char *)".Z",  (char *)((void *)0)};
    #####: 7502:static int get_istat(char *iname, struct stat *sbuf) {
        -: 7503:  int ilen;
        -: 7504:  char **suf;
        -: 7505:  char *s;
        -: 7506:  int tmp;
        -: 7507:  int *tmp___0;
        -: 7508:  int tmp___1;
        -: 7509:  int tmp___2;
        -: 7510:
        -: 7511:  {
        -: 7512:    {
    #####: 7513:      suf = suffixes;
    #####: 7514:      strcpy((char * /* __restrict  */)(ifname),
        -: 7515:             (char const * /* __restrict  */)iname);
    #####: 7516:      tmp = do_stat(ifname, sbuf);
        -: 7517:    }
    #####: 7518:    if (tmp == 0) {
    #####: 7519:      return (0);
        -: 7520:    }
    #####: 7521:    if (!decompress) {
        -: 7522:      {
    #####: 7523:        perror((char const *)(ifname));
    #####: 7524:        exit_code = 1;
        -: 7525:      }
    #####: 7526:      return (1);
        -: 7527:    } else {
    #####: 7528:      { tmp___0 = __errno_location(); }
    #####: 7529:      if (*tmp___0 != 2) {
        -: 7530:        {
    #####: 7531:          perror((char const *)(ifname));
    #####: 7532:          exit_code = 1;
        -: 7533:        }
    #####: 7534:        return (1);
        -: 7535:      }
        -: 7536:    }
    #####: 7537:    { s = get_suffix(ifname); }
    #####: 7538:    if ((unsigned long)s != (unsigned long)((void *)0)) {
        -: 7539:      {
    #####: 7540:        perror((char const *)(ifname));
    #####: 7541:        exit_code = 1;
        -: 7542:      }
    #####: 7543:      return (1);
        -: 7544:    }
        -: 7545:    {
    #####: 7546:      ilen = (int)strlen((char const *)(ifname));
    #####: 7547:      tmp___1 = strcmp((char const *)(z_suffix), ".gz");
        -: 7548:    }
    #####: 7549:    if (tmp___1 == 0) {
    #####: 7550:      suf++;
        -: 7551:    }
        -: 7552:    {
        -: 7553:      while (1) {
    #####: 7554:      while_continue: /* CIL Label */;
        -: 7555:        {
    #####: 7556:          s = *suf;
    #####: 7557:          strcat((char * /* __restrict  */)(ifname),
        -: 7558:                 (char const * /* __restrict  */)s);
    #####: 7559:          tmp___2 = do_stat(ifname, sbuf);
        -: 7560:        }
    #####: 7561:        if (tmp___2 == 0) {
    #####: 7562:          return (0);
        -: 7563:        }
    #####: 7564:        ifname[ilen] = (char)'\000';
    #####: 7565:        suf++;
    #####: 7566:        if (!((unsigned long)*suf != (unsigned long)((void *)0))) {
    #####: 7567:          goto while_break;
        -: 7568:        }
        -: 7569:      }
    #####: 7570:    while_break: /* CIL Label */;
        -: 7571:    }
        -: 7572:    {
    #####: 7573:      strcat((char * /* __restrict  */)(ifname),
        -: 7574:             (char const * /* __restrict  */)(z_suffix));
    #####: 7575:      perror((char const *)(ifname));
    #####: 7576:      exit_code = 1;
        -: 7577:    }
    #####: 7578:    return (1);
        -: 7579:  }
        -: 7580:}
    #####: 7581:static int make_ofname(void) {
        -: 7582:  char *suff;
        -: 7583:  int tmp;
        -: 7584:  int tmp___0;
        -: 7585:  char *__cil_tmp4;
        -: 7586:  char *__cil_tmp5;
        -: 7587:
        -: 7588:  {
        -: 7589:    {
    #####: 7590:      strcpy((char * /* __restrict  */)(ofname),
        -: 7591:             (char const * /* __restrict  */)(ifname));
    #####: 7592:      suff = get_suffix(ofname);
        -: 7593:    }
    #####: 7594:    if (decompress) {
    #####: 7595:      if ((unsigned long)suff == (unsigned long)((void *)0)) {
    #####: 7596:        if (!recursive) {
    #####: 7597:          if (list) {
    #####: 7598:            return (0);
        -: 7599:          } else {
    #####: 7600:            if (test) {
    #####: 7601:              return (0);
        -: 7602:            }
        -: 7603:          }
        -: 7604:        }
    #####: 7605:        if (verbose) {
    #####: 7606:          goto _L;
        -: 7607:        } else {
    #####: 7608:          if (!recursive) {
    #####: 7609:            if (!quiet) {
    #####: 7610:            _L:
    #####: 7611:              if (!quiet) {
        -: 7612:                {
    #####: 7613:                  fprintf(
        -: 7614:                      (FILE * /* __restrict  */) stderr,
        -: 7615:                      (char const * /* __restrict  */) "%s: %s: unknown suffix "
        -: 7616:                                                       "-- ignored\n",
        -: 7617:                      progname, ifname);
        -: 7618:                }
        -: 7619:              }
    #####: 7620:              if (exit_code == 0) {
    #####: 7621:                exit_code = 2;
        -: 7622:              }
        -: 7623:            }
        -: 7624:          }
        -: 7625:        }
    #####: 7626:        return (2);
        -: 7627:      }
        -: 7628:      {
    #####: 7629:        strlwr(suff);
    #####: 7630:        tmp = strcmp((char const *)suff, ".tgz");
        -: 7631:      }
    #####: 7632:      if (tmp == 0) {
        -: 7633:        {
    #####: 7634:          strcpy((char * /* __restrict  */)suff,
        -: 7635:                 (char const * /* __restrict  */) ".tar");
        -: 7636:        }
        -: 7637:      } else {
    #####: 7638:        { tmp___0 = strcmp((char const *)suff, ".taz"); }
    #####: 7639:        if (tmp___0 == 0) {
        -: 7640:          {
    #####: 7641:            strcpy((char * /* __restrict  */)suff,
        -: 7642:                   (char const * /* __restrict  */) ".tar");
        -: 7643:          }
        -: 7644:        } else {
    #####: 7645:          *suff = (char)'\000';
        -: 7646:        }
        -: 7647:      }
        -: 7648:    } else {
    #####: 7649:      if ((unsigned long)suff != (unsigned long)((void *)0)) {
    #####: 7650:        if (verbose) {
        -: 7651:          {
    #####: 7652:            fprintf((FILE * /* __restrict  */) stderr,
        -: 7653:                    (char const * /* __restrict  */) "%s: %s already has %s "
        -: 7654:                                                     "suffix -- unchanged\n",
        -: 7655:                    progname, ifname, suff);
        -: 7656:          }
        -: 7657:        } else {
    #####: 7658:          if (!recursive) {
    #####: 7659:            if (!quiet) {
        -: 7660:              {
    #####: 7661:                fprintf(
        -: 7662:                    (FILE * /* __restrict  */) stderr,
        -: 7663:                    (char const * /* __restrict  */) "%s: %s already has %s "
        -: 7664:                                                     "suffix -- unchanged\n",
        -: 7665:                    progname, ifname, suff);
        -: 7666:              }
        -: 7667:            }
        -: 7668:          }
        -: 7669:        }
    #####: 7670:        if (exit_code == 0) {
    #####: 7671:          exit_code = 2;
        -: 7672:        }
    #####: 7673:        return (2);
        -: 7674:      } else {
        -: 7675:        {
    #####: 7676:          save_orig_name = 0;
    #####: 7677:          strcat((char * /* __restrict  */)(ofname),
        -: 7678:                 (char const * /* __restrict  */)(z_suffix));
        -: 7679:        }
        -: 7680:      }
        -: 7681:    }
    #####: 7682:    return (0);
        -: 7683:  }
        -: 7684:}
    #####: 7685:static int get_method(int in) {
        -: 7686:  uch flags___0;
        -: 7687:  char magic[2];
        -: 7688:  ulg stamp;
        -: 7689:  unsigned int tmp;
        -: 7690:  int tmp___0;
        -: 7691:  int tmp___1;
        -: 7692:  unsigned int tmp___2;
        -: 7693:  int tmp___3;
        -: 7694:  int tmp___4;
        -: 7695:  unsigned int tmp___5;
        -: 7696:  int tmp___6;
        -: 7697:  int tmp___7;
        -: 7698:  unsigned int tmp___8;
        -: 7699:  int tmp___9;
        -: 7700:  int tmp___10;
        -: 7701:  unsigned int tmp___11;
        -: 7702:  int tmp___12;
        -: 7703:  int tmp___13;
        -: 7704:  unsigned int tmp___14;
        -: 7705:  int tmp___15;
        -: 7706:  int tmp___16;
        -: 7707:  unsigned int tmp___17;
        -: 7708:  int tmp___18;
        -: 7709:  int tmp___19;
        -: 7710:  unsigned int tmp___20;
        -: 7711:  int tmp___21;
        -: 7712:  int tmp___22;
        -: 7713:  unsigned int tmp___23;
        -: 7714:  int tmp___24;
        -: 7715:  int tmp___25;
        -: 7716:  unsigned int tmp___26;
        -: 7717:  int tmp___27;
        -: 7718:  int tmp___28;
        -: 7719:  unsigned int tmp___29;
        -: 7720:  unsigned int tmp___30;
        -: 7721:  unsigned int part;
        -: 7722:  unsigned int tmp___31;
        -: 7723:  int tmp___32;
        -: 7724:  int tmp___33;
        -: 7725:  unsigned int tmp___34;
        -: 7726:  int tmp___35;
        -: 7727:  int tmp___36;
        -: 7728:  unsigned int len;
        -: 7729:  unsigned int tmp___37;
        -: 7730:  int tmp___38;
        -: 7731:  int tmp___39;
        -: 7732:  unsigned int tmp___40;
        -: 7733:  int tmp___41;
        -: 7734:  int tmp___42;
        -: 7735:  unsigned int tmp___43;
        -: 7736:  unsigned int tmp___44;
        -: 7737:  char c;
        -: 7738:  unsigned int tmp___45;
        -: 7739:  int tmp___46;
        -: 7740:  char *p;
        -: 7741:  char *tmp___47;
        -: 7742:  char *base;
        -: 7743:  unsigned int tmp___48;
        -: 7744:  int tmp___49;
        -: 7745:  int tmp___50;
        -: 7746:  char *tmp___51;
        -: 7747:  unsigned int tmp___52;
        -: 7748:  int tmp___53;
        -: 7749:  int tmp___54;
        -: 7750:  int tmp___55;
        -: 7751:  int tmp___56;
        -: 7752:  int tmp___57;
        -: 7753:  int tmp___58;
        -: 7754:  int tmp___59;
        -: 7755:  int tmp___60;
        -: 7756:  int tmp___61;
        -: 7757:  int tmp___62;
        -: 7758:  void *__cil_tmp74;
        -: 7759:  char *__cil_tmp75;
        -: 7760:
        -: 7761:  {
    #####: 7762:    if (force) {
    #####: 7763:      if (to_stdout) {
    #####: 7764:        if (inptr < insize) {
    #####: 7765:          tmp = inptr;
    #####: 7766:          inptr++;
    #####: 7767:          tmp___1 = (int)inbuf[tmp];
        -: 7768:        } else {
        -: 7769:          {
    #####: 7770:            tmp___0 = fill_inbuf(1);
    #####: 7771:            tmp___1 = tmp___0;
        -: 7772:          }
        -: 7773:        }
    #####: 7774:        magic[0] = (char)tmp___1;
    #####: 7775:        if (inptr < insize) {
    #####: 7776:          tmp___2 = inptr;
    #####: 7777:          inptr++;
    #####: 7778:          tmp___4 = (int)inbuf[tmp___2];
        -: 7779:        } else {
        -: 7780:          {
    #####: 7781:            tmp___3 = fill_inbuf(1);
    #####: 7782:            tmp___4 = tmp___3;
        -: 7783:          }
        -: 7784:        }
    #####: 7785:        magic[1] = (char)tmp___4;
        -: 7786:      } else {
    #####: 7787:        goto _L;
        -: 7788:      }
        -: 7789:    } else {
    #####: 7790:    _L:
    #####: 7791:      if (inptr < insize) {
    #####: 7792:        tmp___5 = inptr;
    #####: 7793:        inptr++;
    #####: 7794:        tmp___7 = (int)inbuf[tmp___5];
        -: 7795:      } else {
        -: 7796:        {
    #####: 7797:          tmp___6 = fill_inbuf(0);
    #####: 7798:          tmp___7 = tmp___6;
        -: 7799:        }
        -: 7800:      }
    #####: 7801:      magic[0] = (char)tmp___7;
    #####: 7802:      if (inptr < insize) {
    #####: 7803:        tmp___8 = inptr;
    #####: 7804:        inptr++;
    #####: 7805:        tmp___10 = (int)inbuf[tmp___8];
        -: 7806:      } else {
        -: 7807:        {
    #####: 7808:          tmp___9 = fill_inbuf(0);
    #####: 7809:          tmp___10 = tmp___9;
        -: 7810:        }
        -: 7811:      }
    #####: 7812:      magic[1] = (char)tmp___10;
        -: 7813:    }
        -: 7814:    {
    #####: 7815:      method = -1;
    #####: 7816:      part_nb++;
    #####: 7817:      header_bytes = 0L;
    #####: 7818:      last_member = 0;
        -: 7819:      tmp___61 =
    #####: 7820:          memcmp((void const *)(magic), (void const *)"\037\213", (size_t)2);
        -: 7821:    }
    #####: 7822:    if (tmp___61 == 0) {
    #####: 7823:      goto _L___4;
        -: 7824:    } else {
        -: 7825:      {
        -: 7826:        tmp___62 =
    #####: 7827:            memcmp((void const *)(magic), (void const *)"\037\236", (size_t)2);
        -: 7828:      }
    #####: 7829:      if (tmp___62 == 0) {
    #####: 7830:      _L___4:
    #####: 7831:        if (inptr < insize) {
    #####: 7832:          tmp___11 = inptr;
    #####: 7833:          inptr++;
    #####: 7834:          tmp___13 = (int)inbuf[tmp___11];
        -: 7835:        } else {
        -: 7836:          {
    #####: 7837:            tmp___12 = fill_inbuf(0);
    #####: 7838:            tmp___13 = tmp___12;
        -: 7839:          }
        -: 7840:        }
    #####: 7841:        method = tmp___13;
    #####: 7842:        if (method != 8) {
        -: 7843:          {
    #####: 7844:            fprintf(
        -: 7845:                (FILE * /* __restrict  */) stderr,
        -: 7846:                (char const * /* __restrict  */) "%s: %s: unknown method %d -- "
        -: 7847:                                                 "get newer version of gzip\n",
        -: 7848:                progname, ifname, method);
    #####: 7849:            exit_code = 1;
        -: 7850:          }
    #####: 7851:          return (-1);
        -: 7852:        }
    #####: 7853:        work = &unzip;
    #####: 7854:        if (inptr < insize) {
    #####: 7855:          tmp___14 = inptr;
    #####: 7856:          inptr++;
    #####: 7857:          tmp___16 = (int)inbuf[tmp___14];
        -: 7858:        } else {
        -: 7859:          {
    #####: 7860:            tmp___15 = fill_inbuf(0);
    #####: 7861:            tmp___16 = tmp___15;
        -: 7862:          }
        -: 7863:        }
    #####: 7864:        flags___0 = (uch)tmp___16;
    #####: 7865:        if (((int)flags___0 & 32) != 0) {
        -: 7866:          {
    #####: 7867:            fprintf(
        -: 7868:                (FILE * /* __restrict  */) stderr,
        -: 7869:                (char const * /* __restrict  */) "%s: %s is encrypted -- get "
        -: 7870:                                                 "newer version of gzip\n",
        -: 7871:                progname, ifname);
    #####: 7872:            exit_code = 1;
        -: 7873:          }
    #####: 7874:          return (-1);
        -: 7875:        }
    #####: 7876:        if (((int)flags___0 & 2) != 0) {
        -: 7877:          {
    #####: 7878:            fprintf(
        -: 7879:                (FILE * /* __restrict  */) stderr,
        -: 7880:                (char const
        -: 7881:                     * /* __restrict  */) "%s: %s is a a multi-part gzip file "
        -: 7882:                                          "-- get newer version of gzip\n",
        -: 7883:                progname, ifname);
    #####: 7884:            exit_code = 1;
        -: 7885:          }
    #####: 7886:          if (force <= 1) {
    #####: 7887:            return (-1);
        -: 7888:          }
        -: 7889:        }
    #####: 7890:        if (((int)flags___0 & 192) != 0) {
        -: 7891:          {
    #####: 7892:            fprintf(
        -: 7893:                (FILE * /* __restrict  */) stderr,
        -: 7894:                (char const * /* __restrict  */) "%s: %s has flags 0x%x -- get "
        -: 7895:                                                 "newer version of gzip\n",
        -: 7896:                progname, ifname, (int)flags___0);
    #####: 7897:            exit_code = 1;
        -: 7898:          }
    #####: 7899:          if (force <= 1) {
    #####: 7900:            return (-1);
        -: 7901:          }
        -: 7902:        }
    #####: 7903:        if (inptr < insize) {
    #####: 7904:          tmp___17 = inptr;
    #####: 7905:          inptr++;
    #####: 7906:          tmp___19 = (int)inbuf[tmp___17];
        -: 7907:        } else {
        -: 7908:          {
    #####: 7909:            tmp___18 = fill_inbuf(0);
    #####: 7910:            tmp___19 = tmp___18;
        -: 7911:          }
        -: 7912:        }
    #####: 7913:        stamp = (ulg)tmp___19;
    #####: 7914:        if (inptr < insize) {
    #####: 7915:          tmp___20 = inptr;
    #####: 7916:          inptr++;
    #####: 7917:          tmp___22 = (int)inbuf[tmp___20];
        -: 7918:        } else {
        -: 7919:          {
    #####: 7920:            tmp___21 = fill_inbuf(0);
    #####: 7921:            tmp___22 = tmp___21;
        -: 7922:          }
        -: 7923:        }
    #####: 7924:        stamp |= (ulg)tmp___22 << 8;
    #####: 7925:        if (inptr < insize) {
    #####: 7926:          tmp___23 = inptr;
    #####: 7927:          inptr++;
    #####: 7928:          tmp___25 = (int)inbuf[tmp___23];
        -: 7929:        } else {
        -: 7930:          {
    #####: 7931:            tmp___24 = fill_inbuf(0);
    #####: 7932:            tmp___25 = tmp___24;
        -: 7933:          }
        -: 7934:        }
    #####: 7935:        stamp |= (ulg)tmp___25 << 16;
    #####: 7936:        if (inptr < insize) {
    #####: 7937:          tmp___26 = inptr;
    #####: 7938:          inptr++;
    #####: 7939:          tmp___28 = (int)inbuf[tmp___26];
        -: 7940:        } else {
        -: 7941:          {
    #####: 7942:            tmp___27 = fill_inbuf(0);
    #####: 7943:            tmp___28 = tmp___27;
        -: 7944:          }
        -: 7945:        }
    #####: 7946:        stamp |= (ulg)tmp___28 << 24;
    #####: 7947:        if (stamp != 0UL) {
    #####: 7948:          if (!no_time) {
    #####: 7949:            time_stamp = (long)stamp;
        -: 7950:          }
        -: 7951:        }
    #####: 7952:        if (inptr < insize) {
    #####: 7953:          tmp___29 = inptr;
    #####: 7954:          inptr++;
        -: 7955:        } else {
    #####: 7956:          { fill_inbuf(0); }
        -: 7957:        }
    #####: 7958:        if (inptr < insize) {
    #####: 7959:          tmp___30 = inptr;
    #####: 7960:          inptr++;
        -: 7961:        } else {
    #####: 7962:          { fill_inbuf(0); }
        -: 7963:        }
    #####: 7964:        if (((int)flags___0 & 2) != 0) {
    #####: 7965:          if (inptr < insize) {
    #####: 7966:            tmp___31 = inptr;
    #####: 7967:            inptr++;
    #####: 7968:            tmp___33 = (int)inbuf[tmp___31];
        -: 7969:          } else {
        -: 7970:            {
    #####: 7971:              tmp___32 = fill_inbuf(0);
    #####: 7972:              tmp___33 = tmp___32;
        -: 7973:            }
        -: 7974:          }
    #####: 7975:          part = (unsigned int)tmp___33;
    #####: 7976:          if (inptr < insize) {
    #####: 7977:            tmp___34 = inptr;
    #####: 7978:            inptr++;
    #####: 7979:            tmp___36 = (int)inbuf[tmp___34];
        -: 7980:          } else {
        -: 7981:            {
    #####: 7982:              tmp___35 = fill_inbuf(0);
    #####: 7983:              tmp___36 = tmp___35;
        -: 7984:            }
        -: 7985:          }
    #####: 7986:          part |= (unsigned int)tmp___36 << 8;
    #####: 7987:          if (verbose) {
        -: 7988:            {
    #####: 7989:              fprintf(
        -: 7990:                  (FILE * /* __restrict  */) stderr,
        -: 7991:                  (char const * /* __restrict  */) "%s: %s: part number %u\n",
        -: 7992:                  progname, ifname, part);
        -: 7993:            }
        -: 7994:          }
        -: 7995:        }
    #####: 7996:        if (((int)flags___0 & 4) != 0) {
    #####: 7997:          if (inptr < insize) {
    #####: 7998:            tmp___37 = inptr;
    #####: 7999:            inptr++;
    #####: 8000:            tmp___39 = (int)inbuf[tmp___37];
        -: 8001:          } else {
        -: 8002:            {
    #####: 8003:              tmp___38 = fill_inbuf(0);
    #####: 8004:              tmp___39 = tmp___38;
        -: 8005:            }
        -: 8006:          }
    #####: 8007:          len = (unsigned int)tmp___39;
    #####: 8008:          if (inptr < insize) {
    #####: 8009:            tmp___40 = inptr;
    #####: 8010:            inptr++;
    #####: 8011:            tmp___42 = (int)inbuf[tmp___40];
        -: 8012:          } else {
        -: 8013:            {
    #####: 8014:              tmp___41 = fill_inbuf(0);
    #####: 8015:              tmp___42 = tmp___41;
        -: 8016:            }
        -: 8017:          }
    #####: 8018:          len |= (unsigned int)tmp___42 << 8;
    #####: 8019:          if (verbose) {
        -: 8020:            {
    #####: 8021:              fprintf((FILE * /* __restrict  */) stderr,
        -: 8022:                      (char const * /* __restrict  */) "%s: %s: extra field of "
        -: 8023:                                                       "%u bytes ignored\n",
        -: 8024:                      progname, ifname, len);
        -: 8025:            }
        -: 8026:          }
        -: 8027:          {
        -: 8028:            while (1) {
    #####: 8029:            while_continue: /* CIL Label */;
    #####: 8030:              tmp___44 = len;
    #####: 8031:              len--;
    #####: 8032:              if (!tmp___44) {
    #####: 8033:                goto while_break;
        -: 8034:              }
    #####: 8035:              if (inptr < insize) {
    #####: 8036:                tmp___43 = inptr;
    #####: 8037:                inptr++;
        -: 8038:              } else {
    #####: 8039:                { fill_inbuf(0); }
        -: 8040:              }
        -: 8041:            }
    #####: 8042:          while_break: /* CIL Label */;
        -: 8043:          }
        -: 8044:        }
    #####: 8045:        if (((int)flags___0 & 8) != 0) {
    #####: 8046:          if (no_name) {
    #####: 8047:            goto _L___0;
        -: 8048:          } else {
    #####: 8049:            if (to_stdout) {
    #####: 8050:              if (!list) {
    #####: 8051:                goto _L___0;
        -: 8052:              } else {
    #####: 8053:                goto _L___1;
        -: 8054:              }
        -: 8055:            } else {
    #####: 8056:            _L___1:
    #####: 8057:              if (part_nb > 1) {
    #####: 8058:              _L___0 : {
        -: 8059:                while (1) {
    #####: 8060:                while_continue___0: /* CIL Label */;
    #####: 8061:                  if (inptr < insize) {
    #####: 8062:                    tmp___45 = inptr;
    #####: 8063:                    inptr++;
    #####: 8064:                    c = (char)inbuf[tmp___45];
        -: 8065:                  } else {
        -: 8066:                    {
    #####: 8067:                      tmp___46 = fill_inbuf(0);
    #####: 8068:                      c = (char)tmp___46;
        -: 8069:                    }
        -: 8070:                  }
    #####: 8071:                  if (!((int)c != 0)) {
    #####: 8072:                    goto while_break___0;
        -: 8073:                  }
        -: 8074:                }
    #####: 8075:              while_break___0: /* CIL Label */;
        -: 8076:              }
        -: 8077:              } else {
        -: 8078:                {
    #####: 8079:                  tmp___47 = basename(ofname);
    #####: 8080:                  p = tmp___47;
    #####: 8081:                  base = p;
        -: 8082:                }
        -: 8083:                {
        -: 8084:                  while (1) {
    #####: 8085:                  while_continue___1: /* CIL Label */;
    #####: 8086:                    if (inptr < insize) {
    #####: 8087:                      tmp___48 = inptr;
    #####: 8088:                      inptr++;
    #####: 8089:                      tmp___50 = (int)inbuf[tmp___48];
        -: 8090:                    } else {
        -: 8091:                      {
    #####: 8092:                        tmp___49 = fill_inbuf(0);
    #####: 8093:                        tmp___50 = tmp___49;
        -: 8094:                      }
        -: 8095:                    }
    #####: 8096:                    *p = (char)tmp___50;
    #####: 8097:                    tmp___51 = p;
    #####: 8098:                    p++;
    #####: 8099:                    if ((int)*tmp___51 == 0) {
    #####: 8100:                      goto while_break___1;
        -: 8101:                    }
    #####: 8102:                    if ((unsigned long)p >=
    #####: 8103:                        (unsigned long)(ofname + sizeof(ofname))) {
        -: 8104:                      {
    #####: 8105:                        error((char *)"corrupted input -- file name too large");
        -: 8106:                      }
        -: 8107:                    }
        -: 8108:                  }
    #####: 8109:                while_break___1: /* CIL Label */;
        -: 8110:                }
    #####: 8111:                if (!list) {
    #####: 8112:                  if (base) {
    #####: 8113:                    list = 0;
        -: 8114:                  }
        -: 8115:                }
        -: 8116:              }
        -: 8117:            }
        -: 8118:          }
        -: 8119:        }
    #####: 8120:        if (((int)flags___0 & 16) != 0) {
        -: 8121:          {
        -: 8122:            while (1) {
    #####: 8123:            while_continue___2: /* CIL Label */;
    #####: 8124:              if (inptr < insize) {
    #####: 8125:                tmp___52 = inptr;
    #####: 8126:                inptr++;
    #####: 8127:                tmp___54 = (int)inbuf[tmp___52];
        -: 8128:              } else {
        -: 8129:                {
    #####: 8130:                  tmp___53 = fill_inbuf(0);
    #####: 8131:                  tmp___54 = tmp___53;
        -: 8132:                }
        -: 8133:              }
    #####: 8134:              if (!(tmp___54 != 0)) {
    #####: 8135:                goto while_break___2;
        -: 8136:              }
        -: 8137:            }
    #####: 8138:          while_break___2: /* CIL Label */;
        -: 8139:          }
        -: 8140:        }
    #####: 8141:        if (part_nb == 1) {
    #####: 8142:          header_bytes = (long)((unsigned long)inptr + 2UL * sizeof(long));
        -: 8143:        }
        -: 8144:      } else {
        -: 8145:        {
    #####: 8146:          tmp___59 = memcmp((void const *)(magic), (void const *)"PK\003\004",
        -: 8147:                            (size_t)2);
        -: 8148:        }
    #####: 8149:        if (tmp___59 == 0) {
    #####: 8150:          if (inptr == 2U) {
        -: 8151:            {
    #####: 8152:              tmp___60 = memcmp((void const *)((char *)(inbuf)),
        -: 8153:                                (void const *)"PK\003\004", (size_t)4);
        -: 8154:            }
    #####: 8155:            if (tmp___60 == 0) {
        -: 8156:              {
    #####: 8157:                inptr = 0U;
    #####: 8158:                work = &unzip;
    #####: 8159:                tmp___55 = check_zipfile(in);
        -: 8160:              }
    #####: 8161:              if (tmp___55 != 0) {
    #####: 8162:                return (-1);
        -: 8163:              }
    #####: 8164:              last_member = 1;
        -: 8165:            } else {
    #####: 8166:              goto _L___3;
        -: 8167:            }
        -: 8168:          } else {
    #####: 8169:            goto _L___3;
        -: 8170:          }
        -: 8171:        } else {
    #####: 8172:        _L___3 : {
    #####: 8173:          tmp___58 = memcmp((void const *)(magic), (void const *)"\037\036",
        -: 8174:                            (size_t)2);
        -: 8175:        }
    #####: 8176:          if (tmp___58 == 0) {
    #####: 8177:            work = &unpack;
    #####: 8178:            method = 2;
        -: 8179:          } else {
        -: 8180:            {
    #####: 8181:              tmp___57 = memcmp((void const *)(magic), (void const *)"\037\235",
        -: 8182:                                (size_t)2);
        -: 8183:            }
    #####: 8184:            if (tmp___57 == 0) {
    #####: 8185:              work = &unlzw;
    #####: 8186:              method = 1;
    #####: 8187:              last_member = 1;
        -: 8188:            } else {
        -: 8189:              {
    #####: 8190:                tmp___56 = memcmp((void const *)(magic),
        -: 8191:                                  (void const *)"\037\240", (size_t)2);
        -: 8192:              }
    #####: 8193:              if (tmp___56 == 0) {
    #####: 8194:                work = &unlzh;
    #####: 8195:                method = 3;
    #####: 8196:                last_member = 1;
        -: 8197:              } else {
    #####: 8198:                if (force) {
    #####: 8199:                  if (to_stdout) {
    #####: 8200:                    if (!list) {
    #####: 8201:                      method = 0;
    #####: 8202:                      work = &copy;
    #####: 8203:                      inptr = 0U;
    #####: 8204:                      last_member = 1;
        -: 8205:                    }
        -: 8206:                  }
        -: 8207:                }
        -: 8208:              }
        -: 8209:            }
        -: 8210:          }
        -: 8211:        }
        -: 8212:      }
        -: 8213:    }
    #####: 8214:    if (method >= 0) {
    #####: 8215:      return (method);
        -: 8216:    }
    #####: 8217:    if (part_nb == 1) {
        -: 8218:      {
    #####: 8219:        fprintf(
        -: 8220:            (FILE * /* __restrict  */) stderr,
        -: 8221:            (char const * /* __restrict  */) "\n%s: %s: not in gzip format\n",
        -: 8222:            progname, ifname);
    #####: 8223:        exit_code = 1;
        -: 8224:      }
    #####: 8225:      return (-1);
        -: 8226:    } else {
    #####: 8227:      if (!quiet) {
        -: 8228:        {
    #####: 8229:          fprintf(
        -: 8230:              (FILE * /* __restrict  */) stderr,
        -: 8231:              (char const * /* __restrict  */) "\n%s: %s: decompression OK, "
        -: 8232:                                               "trailing garbage ignored\n",
        -: 8233:              progname, ifname);
        -: 8234:        }
        -: 8235:      }
    #####: 8236:      if (exit_code == 0) {
    #####: 8237:        exit_code = 2;
        -: 8238:      }
    #####: 8239:      return (-2);
        -: 8240:    }
        -: 8241:  }
        -: 8242:}
        -: 8243:static int first_time = 1;
        -: 8244:static char *methods[9] = {(char *)"store", (char *)"compr", (char *)"pack ",
        -: 8245:                           (char *)"lzh  ", (char *)"",      (char *)"",
        -: 8246:                           (char *)"",      (char *)"",      (char *)"defla"};
    #####: 8247:static void do_list(int ifd___0, int method___0) {
        -: 8248:  ulg crc___1;
        -: 8249:  char *date;
        -: 8250:  __off_t tmp;
        -: 8251:  uch buf[8];
        -: 8252:  ssize_t tmp___0;
        -: 8253:  char *tmp___1;
        -: 8254:  void *__cil_tmp9;
        -: 8255:
        -: 8256:  {
    #####: 8257:    if (first_time) {
    #####: 8258:      if (method___0 >= 0) {
    #####: 8259:        first_time = 0;
    #####: 8260:        if (verbose) {
        -: 8261:          {
    #####: 8262:            printf((
        -: 8263:                char const * /* __restrict  */) "method  crc     date  time  ");
        -: 8264:          }
        -: 8265:        }
    #####: 8266:        if (!quiet) {
        -: 8267:          {
    #####: 8268:            printf(
        -: 8269:                (char const * /* __restrict  */) "compressed  uncompr. ratio "
        -: 8270:                                                 "uncompressed_name\n");
        -: 8271:          }
        -: 8272:        }
        -: 8273:      } else {
    #####: 8274:        goto _L;
        -: 8275:      }
        -: 8276:    } else {
    #####: 8277:    _L:
    #####: 8278:      if (method___0 < 0) {
    #####: 8279:        if (total_in <= 0L) {
    #####: 8280:          return;
        -: 8281:        } else {
    #####: 8282:          if (total_out <= 0L) {
    #####: 8283:            return;
        -: 8284:          }
        -: 8285:        }
    #####: 8286:        if (verbose) {
        -: 8287:          {
    #####: 8288:            printf((char const * /* __restrict  */) "                          "
        -: 8289:                                                    "  %9lu %9lu ",
        -: 8290:                   total_in, total_out);
        -: 8291:          }
        -: 8292:        } else {
    #####: 8293:          if (!quiet) {
        -: 8294:            {
    #####: 8295:              printf((char const * /* __restrict  */) "%9ld %9ld ", total_in,
        -: 8296:                     total_out);
        -: 8297:            }
        -: 8298:          }
        -: 8299:        }
        -: 8300:        {
    #####: 8301:          display_ratio(total_out - (total_in - header_bytes), total_out,
        -: 8302:                        stdout);
    #####: 8303:          printf((char const * /* __restrict  */) " (totals)\n");
        -: 8304:        }
    #####: 8305:        return;
        -: 8306:      }
        -: 8307:    }
    #####: 8308:    crc___1 = (ulg)(~0);
    #####: 8309:    bytes_out = -1L;
    #####: 8310:    bytes_in = ifile_size;
    #####: 8311:    if (method___0 == 8) {
    #####: 8312:      if (!last_member) {
        -: 8313:        {
    #####: 8314:          tmp = lseek(ifd___0, (off_t)-8, 2);
    #####: 8315:          bytes_in = tmp;
        -: 8316:        }
    #####: 8317:        if (bytes_in != -1L) {
        -: 8318:          {
    #####: 8319:            bytes_in += 8L;
    #####: 8320:            tmp___0 = read(ifd___0, (void *)((char *)(buf)), sizeof(buf));
        -: 8321:          }
    #####: 8322:          if ((unsigned long)tmp___0 != sizeof(buf)) {
        -: 8323:            {
    #####: 8324:              read_error();
        -: 8325:            }
        -: 8326:          }
    #####: 8327:          crc___1 = (ulg)((int)((ush)buf[0]) | ((int)((ush)buf[1]) << 8)) |
    #####: 8328:                    ((ulg)((int)((ush) * ((buf + 2) + 0)) |
    #####: 8329:                           ((int)((ush) * ((buf + 2) + 1)) << 8))
    #####: 8330:                     << 16);
    #####: 8331:          bytes_out = (long)((ulg)((int)((ush) * ((buf + 4) + 0)) |
    #####: 8332:                                   ((int)((ush) * ((buf + 4) + 1)) << 8)) |
    #####: 8333:                             ((ulg)((int)((ush) * (((buf + 4) + 2) + 0)) |
    #####: 8334:                                    ((int)((ush) * (((buf + 4) + 2) + 1)) << 8))
    #####: 8335:                              << 16));
        -: 8336:        }
        -: 8337:      }
        -: 8338:    }
        -: 8339:    {
    #####: 8340:      tmp___1 = ctime((time_t const *)(&time_stamp));
    #####: 8341:      date = tmp___1 + 4;
    #####: 8342:      *(date + 12) = (char)'\000';
        -: 8343:    }
    #####: 8344:    if (verbose) {
        -: 8345:      {
    #####: 8346:        printf((char const * /* __restrict  */) "%5s %08lx %11s ",
        -: 8347:               methods[method___0], crc___1, date);
        -: 8348:      }
        -: 8349:    }
        -: 8350:    {
    #####: 8351:      printf((char const * /* __restrict  */) "%9ld %9ld ", bytes_in,
        -: 8352:             bytes_out);
        -: 8353:    }
    #####: 8354:    if (bytes_in == -1L) {
    #####: 8355:      total_in = -1L;
    #####: 8356:      header_bytes = 0L;
    #####: 8357:      bytes_out = header_bytes;
    #####: 8358:      bytes_in = bytes_out;
        -: 8359:    } else {
    #####: 8360:      if (total_in >= 0L) {
    #####: 8361:        total_in += bytes_in;
        -: 8362:      }
        -: 8363:    }
    #####: 8364:    if (bytes_out == -1L) {
    #####: 8365:      total_out = -1L;
    #####: 8366:      header_bytes = 0L;
    #####: 8367:      bytes_out = header_bytes;
    #####: 8368:      bytes_in = bytes_out;
        -: 8369:    } else {
    #####: 8370:      if (total_out >= 0L) {
    #####: 8371:        total_out += bytes_out;
        -: 8372:      }
        -: 8373:    }
        -: 8374:    {
    #####: 8375:      display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
    #####: 8376:      printf((char const * /* __restrict  */) " %s\n", ofname);
        -: 8377:    }
    #####: 8378:    return;
        -: 8379:  }
        -: 8380:}
    #####: 8381:static int same_file(struct stat *stat1, struct stat *stat2) {
        -: 8382:  int tmp;
        -: 8383:
        -: 8384:  {
    #####: 8385:    if (stat1->st_ino == stat2->st_ino) {
    #####: 8386:      if (stat1->st_dev == stat2->st_dev) {
    #####: 8387:        tmp = 1;
        -: 8388:      } else {
    #####: 8389:        tmp = 0;
        -: 8390:      }
        -: 8391:    } else {
    #####: 8392:      tmp = 0;
        -: 8393:    }
    #####: 8394:    return (tmp);
        -: 8395:  }
        -: 8396:}
    #####: 8397:static int name_too_long(char *name, struct stat *statb) {
        -: 8398:  int s;
        -: 8399:  int tmp;
        -: 8400:  char c;
        -: 8401:  struct stat tstat;
        -: 8402:  int res;
        -: 8403:  int tmp___0;
        -: 8404:  int tmp___1;
        -: 8405:  int tmp___2;
        -: 8406:  void *__cil_tmp12;
        -: 8407:
        -: 8408:  {
        -: 8409:    {
    #####: 8410:      tmp = (int)strlen((char const *)name);
    #####: 8411:      s = tmp;
    #####: 8412:      c = *(name + (s - 1));
    #####: 8413:      tstat = *statb;
    #####: 8414:      *(name + (s - 1)) = (char)'\000';
    #####: 8415:      tmp___0 = stat((char const * /* __restrict  */)name,
        -: 8416:                     (struct stat * /* __restrict  */)(&tstat));
        -: 8417:    }
    #####: 8418:    if (tmp___0 == 0) {
        -: 8419:      {
    #####: 8420:        tmp___1 = same_file(statb, &tstat);
        -: 8421:      }
    #####: 8422:      if (tmp___1) {
    #####: 8423:        tmp___2 = 1;
        -: 8424:      } else {
    #####: 8425:        tmp___2 = 0;
        -: 8426:      }
        -: 8427:    } else {
    #####: 8428:      tmp___2 = 0;
        -: 8429:    }
    #####: 8430:    res = tmp___2;
    #####: 8431:    *(name + (s - 1)) = c;
    #####: 8432:    return (res);
        -: 8433:  }
        -: 8434:}
    #####: 8435:static void shorten_name(char *name) {
        -: 8436:  int len;
        -: 8437:  char *trunc;
        -: 8438:  int plen;
        -: 8439:  int min_part;
        -: 8440:  char *p;
        -: 8441:  int tmp;
        -: 8442:  char *tmp___0;
        -: 8443:  char *__cil_tmp11;
        -: 8444:  char *__cil_tmp12;
        -: 8445:  char *__cil_tmp13;
        -: 8446:  char *__cil_tmp14;
        -: 8447:  char *__cil_tmp15;
        -: 8448:
        -: 8449:  {
        -: 8450:    {
    #####: 8451:      trunc = (char *)((void *)0);
    #####: 8452:      min_part = 3;
    #####: 8453:      len = (int)strlen((char const *)name);
        -: 8454:    }
    #####: 8455:    if (decompress) {
    #####: 8456:      if (len <= 1) {
        -: 8457:        {
    #####: 8458:          error((char *)"name too short");
        -: 8459:        }
        -: 8460:      }
    #####: 8461:      *(name + (len - 1)) = (char)'\000';
    #####: 8462:      return;
        -: 8463:    }
    #####: 8464:    { p = get_suffix(name); }
    #####: 8465:    if ((unsigned long)p == (unsigned long)((void *)0)) {
        -: 8466:      {
    #####: 8467:        error((char *)"can\'t recover suffix\n");
        -: 8468:      }
        -: 8469:    }
    #####: 8470:    *p = (char)'\000';
    #####: 8471:    save_orig_name = 1;
    #####: 8472:    if (len > 4) {
        -: 8473:      {
    #####: 8474:        tmp = strcmp((char const *)(p - 4), ".tar");
        -: 8475:      }
    #####: 8476:      if (tmp == 0) {
        -: 8477:        {
    #####: 8478:          strcpy((char * /* __restrict  */)(p - 4),
        -: 8479:                 (char const * /* __restrict  */) ".tgz");
        -: 8480:        }
    #####: 8481:        return;
        -: 8482:      }
        -: 8483:    }
        -: 8484:    {
        -: 8485:      while (1) {
    #####: 8486:      while_continue: /* CIL Label */;
    #####: 8487:        { p = strrchr((char const *)name, '/'); }
    #####: 8488:        if (p) {
    #####: 8489:          p++;
        -: 8490:        } else {
    #####: 8491:          p = name;
        -: 8492:        }
        -: 8493:        {
        -: 8494:          while (1) {
    #####: 8495:          while_continue___0: /* CIL Label */;
    #####: 8496:            if (!*p) {
    #####: 8497:              goto while_break___0;
        -: 8498:            }
        -: 8499:            {
    #####: 8500:              plen = (int)strcspn((char const *)p, ".");
    #####: 8501:              p += plen;
        -: 8502:            }
    #####: 8503:            if (plen > min_part) {
    #####: 8504:              trunc = p - 1;
        -: 8505:            }
    #####: 8506:            if (*p) {
    #####: 8507:              p++;
        -: 8508:            }
        -: 8509:          }
    #####: 8510:        while_break___0: /* CIL Label */;
        -: 8511:        }
    #####: 8512:        if ((unsigned long)trunc == (unsigned long)((void *)0)) {
    #####: 8513:          min_part--;
    #####: 8514:          if (!(min_part != 0)) {
    #####: 8515:            goto while_break;
        -: 8516:          }
        -: 8517:        } else {
    #####: 8518:          goto while_break;
        -: 8519:        }
        -: 8520:      }
    #####: 8521:    while_break: /* CIL Label */;
        -: 8522:    }
    #####: 8523:    if ((unsigned long)trunc != (unsigned long)((void *)0)) {
        -: 8524:      {
        -: 8525:        while (1) {
    #####: 8526:        while_continue___1: /* CIL Label */;
    #####: 8527:          *(trunc + 0) = *(trunc + 1);
    #####: 8528:          tmp___0 = trunc;
    #####: 8529:          trunc++;
    #####: 8530:          if (!*tmp___0) {
    #####: 8531:            goto while_break___1;
        -: 8532:          }
        -: 8533:        }
    #####: 8534:      while_break___1: /* CIL Label */;
        -: 8535:      }
    #####: 8536:      trunc--;
        -: 8537:    } else {
    #####: 8538:      { trunc = strrchr((char const *)name, (int)*("." + 0)); }
    #####: 8539:      if ((unsigned long)trunc == (unsigned long)((void *)0)) {
        -: 8540:        {
    #####: 8541:          error((char *)"internal error in shorten_name");
        -: 8542:        }
        -: 8543:      }
    #####: 8544:      if ((int)*(trunc + 1) == 0) {
    #####: 8545:        trunc--;
        -: 8546:      }
        -: 8547:    }
        -: 8548:    {
    #####: 8549:      strcpy((char * /* __restrict  */)trunc,
        -: 8550:             (char const * /* __restrict  */)(z_suffix));
        -: 8551:    }
    #####: 8552:    return;
        -: 8553:  }
        -: 8554:}
    #####: 8555:static int check_ofname(void) {
        -: 8556:  struct stat ostat;
        -: 8557:  int *tmp;
        -: 8558:  int *tmp___0;
        -: 8559:  int tmp___1;
        -: 8560:  int tmp___2;
        -: 8561:  int tmp___3;
        -: 8562:  char const *tmp___4;
        -: 8563:  int tmp___5;
        -: 8564:  int tmp___6;
        -: 8565:  char response[80];
        -: 8566:  int tmp___7;
        -: 8567:  int tmp___8;
        -: 8568:  int tmp___10;
        -: 8569:  unsigned short const **tmp___11;
        -: 8570:  int tmp___12;
        -: 8571:  void *__cil_tmp16;
        -: 8572:  void *__cil_tmp17;
        -: 8573:  char *__cil_tmp18;
        -: 8574:  char *__cil_tmp19;
        -: 8575:  char *__cil_tmp20;
        -: 8576:
        -: 8577:  {
        -: 8578:    {
    #####: 8579:      tmp = __errno_location();
    #####: 8580:      *tmp = 0;
        -: 8581:    }
        -: 8582:    {
        -: 8583:      while (1) {
    #####: 8584:      while_continue: /* CIL Label */;
        -: 8585:        {
    #####: 8586:          tmp___1 = stat((char const * /* __restrict  */)(ofname),
        -: 8587:                         (struct stat * /* __restrict  */)(&ostat));
        -: 8588:        }
    #####: 8589:        if (!(tmp___1 != 0)) {
    #####: 8590:          goto while_break;
        -: 8591:        }
    #####: 8592:        { tmp___0 = __errno_location(); }
    #####: 8593:        if (*tmp___0 != 36) {
    #####: 8594:          return (0);
        -: 8595:        }
    #####: 8596:        { shorten_name(ofname); }
        -: 8597:      }
    #####: 8598:    while_break: /* CIL Label */;
        -: 8599:    }
    #####: 8600:    if (!decompress) {
        -: 8601:      {
    #####: 8602:        tmp___3 = name_too_long(ofname, &ostat);
        -: 8603:      }
    #####: 8604:      if (tmp___3) {
        -: 8605:        {
    #####: 8606:          shorten_name(ofname);
    #####: 8607:          tmp___2 = stat((char const * /* __restrict  */)(ofname),
        -: 8608:                         (struct stat * /* __restrict  */)(&ostat));
        -: 8609:        }
    #####: 8610:        if (tmp___2 != 0) {
    #####: 8611:          return (0);
        -: 8612:        }
        -: 8613:      }
        -: 8614:    }
    #####: 8615:    { tmp___6 = same_file(&istat, &ostat); }
    #####: 8616:    if (tmp___6) {
        -: 8617:      {
    #####: 8618:        tmp___5 = strcmp((char const *)(ifname), (char const *)(ofname));
        -: 8619:      }
    #####: 8620:      if (tmp___5 == 0) {
    #####: 8621:        if (decompress) {
    #####: 8622:          tmp___4 = "de";
        -: 8623:        } else {
    #####: 8624:          tmp___4 = "";
        -: 8625:        }
        -: 8626:        {
    #####: 8627:          fprintf((FILE * /* __restrict  */) stderr,
        -: 8628:                  (char const * /* __restrict  */) "%s: %s: cannot %scompress "
        -: 8629:                                                   "onto itself\n",
        -: 8630:                  progname, ifname, tmp___4);
        -: 8631:        }
        -: 8632:      } else {
        -: 8633:        {
    #####: 8634:          fprintf((FILE * /* __restrict  */) stderr,
        -: 8635:                  (char const
        -: 8636:                       * /* __restrict  */) "%s: %s and %s are the same file\n",
        -: 8637:                  progname, ifname, ofname);
        -: 8638:        }
        -: 8639:      }
    #####: 8640:      exit_code = 1;
    #####: 8641:      return (1);
        -: 8642:    }
    #####: 8643:    if (!force) {
        -: 8644:      {
    #####: 8645:        strcpy((char * /* __restrict  */)(response),
        -: 8646:               (char const * /* __restrict  */) "n");
    #####: 8647:        fprintf((FILE * /* __restrict  */) stderr,
        -: 8648:                (char const * /* __restrict  */) "%s: %s already exists;",
        -: 8649:                progname, ofname);
        -: 8650:      }
    #####: 8651:      if (foreground) {
        -: 8652:        {
    #####: 8653:          tmp___7 = fileno(stdin);
    #####: 8654:          tmp___8 = isatty(tmp___7);
        -: 8655:        }
    #####: 8656:        if (tmp___8) {
        -: 8657:          {
    #####: 8658:            fprintf((FILE * /* __restrict  */) stderr,
        -: 8659:                    (char const * /* __restrict  */) " do you wish to "
        -: 8660:                                                     "overwrite (y or n)? ");
    #####: 8661:            fflush(stderr);
    #####: 8662:            fgets((char * /* __restrict  */)(response),
        -: 8663:                  (int)(sizeof(response) - 1UL),
        -: 8664:                  (FILE * /* __restrict  */) stdin);
        -: 8665:          }
        -: 8666:        }
        -: 8667:      }
    #####: 8668:      { tmp___11 = __ctype_b_loc(); }
    #####: 8669:      if ((int const) * (*tmp___11 + (int)response[0]) & 256) {
    #####: 8670:        tmp___10 = ((int)response[0] - 65) + 97;
        -: 8671:      } else {
    #####: 8672:        tmp___10 = (int)response[0];
        -: 8673:      }
    #####: 8674:      if (tmp___10 != 121) {
        -: 8675:        {
    #####: 8676:          fprintf((FILE * /* __restrict  */) stderr,
        -: 8677:                  (char const * /* __restrict  */) "\tnot overwritten\n");
        -: 8678:        }
    #####: 8679:        if (exit_code == 0) {
    #####: 8680:          exit_code = 2;
        -: 8681:        }
    #####: 8682:        return (1);
        -: 8683:      }
        -: 8684:    }
        -: 8685:    {
    #####: 8686:      chmod((char const *)(ofname), (__mode_t)511);
    #####: 8687:      tmp___12 = unlink((char const *)(ofname));
        -: 8688:    }
    #####: 8689:    if (tmp___12) {
        -: 8690:      {
    #####: 8691:        fprintf((FILE * /* __restrict  */) stderr,
        -: 8692:                (char const * /* __restrict  */) "%s: ", progname);
    #####: 8693:        perror((char const *)(ofname));
    #####: 8694:        exit_code = 1;
        -: 8695:      }
    #####: 8696:      return (1);
        -: 8697:    }
    #####: 8698:    return (0);
        -: 8699:  }
        -: 8700:}
    #####: 8701:static void reset_times(char *name, struct stat *statb) {
        -: 8702:  struct utimbuf timep;
        -: 8703:  int tmp;
        -: 8704:
        -: 8705:  {
        -: 8706:    {
    #####: 8707:      timep.actime = statb->st_atim.tv_sec;
    #####: 8708:      timep.modtime = statb->st_mtim.tv_sec;
    #####: 8709:      tmp = utime((char const *)name, (struct utimbuf const *)(&timep));
        -: 8710:    }
    #####: 8711:    if (tmp) {
    #####: 8712:      if (!((statb->st_mode & 61440U) == 16384U)) {
    #####: 8713:        if (!quiet) {
        -: 8714:          {
    #####: 8715:            fprintf((FILE * /* __restrict  */) stderr,
        -: 8716:                    (char const * /* __restrict  */) "%s: ", progname);
        -: 8717:          }
        -: 8718:        }
    #####: 8719:        if (exit_code == 0) {
    #####: 8720:          exit_code = 2;
        -: 8721:        }
    #####: 8722:        if (!quiet) {
        -: 8723:          {
    #####: 8724:            perror((char const *)(ofname));
        -: 8725:          }
        -: 8726:        }
        -: 8727:      }
        -: 8728:    }
    #####: 8729:    return;
        -: 8730:  }
        -: 8731:}
    #####: 8732:static void copy_stat(struct stat *ifstat) {
        -: 8733:  int tmp;
        -: 8734:  int tmp___0;
        -: 8735:
        -: 8736:  {
    #####: 8737:    if (decompress) {
    #####: 8738:      if (time_stamp != 0L) {
    #####: 8739:        if (ifstat->st_mtim.tv_sec != time_stamp) {
    #####: 8740:          ifstat->st_mtim.tv_sec = time_stamp;
    #####: 8741:          if (verbose > 1) {
        -: 8742:            {
    #####: 8743:              fprintf(
        -: 8744:                  (FILE * /* __restrict  */) stderr,
        -: 8745:                  (char const * /* __restrict  */) "%s: time stamp restored\n",
        -: 8746:                  ofname);
        -: 8747:            }
        -: 8748:          }
        -: 8749:        }
        -: 8750:      }
        -: 8751:    }
        -: 8752:    {
    #####: 8753:      reset_times(ofname, ifstat);
    #####: 8754:      tmp = chmod((char const *)(ofname), ifstat->st_mode & 4095U);
        -: 8755:    }
    #####: 8756:    if (tmp) {
    #####: 8757:      if (!quiet) {
        -: 8758:        {
    #####: 8759:          fprintf((FILE * /* __restrict  */) stderr,
        -: 8760:                  (char const * /* __restrict  */) "%s: ", progname);
        -: 8761:        }
        -: 8762:      }
    #####: 8763:      if (exit_code == 0) {
    #####: 8764:        exit_code = 2;
        -: 8765:      }
    #####: 8766:      if (!quiet) {
        -: 8767:        {
    #####: 8768:          perror((char const *)(ofname));
        -: 8769:        }
        -: 8770:      }
        -: 8771:    }
        -: 8772:    {
    #####: 8773:      chown((char const *)(ofname), ifstat->st_uid, ifstat->st_gid);
    #####: 8774:      remove_ofname = 0;
    #####: 8775:      chmod((char const *)(ifname), (__mode_t)511);
    #####: 8776:      tmp___0 = unlink((char const *)(ifname));
        -: 8777:    }
    #####: 8778:    if (tmp___0) {
    #####: 8779:      if (!quiet) {
        -: 8780:        {
    #####: 8781:          fprintf((FILE * /* __restrict  */) stderr,
        -: 8782:                  (char const * /* __restrict  */) "%s: ", progname);
        -: 8783:        }
        -: 8784:      }
    #####: 8785:      if (exit_code == 0) {
    #####: 8786:        exit_code = 2;
        -: 8787:      }
    #####: 8788:      if (!quiet) {
        -: 8789:        {
    #####: 8790:          perror((char const *)(ifname));
        -: 8791:        }
        -: 8792:      }
        -: 8793:    }
    #####: 8794:    return;
        -: 8795:  }
        -: 8796:}
    #####: 8797:static void treat_dir(char *dir) {
        -: 8798:  dir_type *dp;
        -: 8799:  DIR *dirp;
        -: 8800:  char nbuf[1024];
        -: 8801:  int len;
        -: 8802:  int tmp;
        -: 8803:  int tmp___0;
        -: 8804:  int tmp___1;
        -: 8805:  size_t tmp___2;
        -: 8806:  void *__cil_tmp11;
        -: 8807:
        -: 8808:  {
    #####: 8809:    { dirp = opendir((char const *)dir); }
    #####: 8810:    if ((unsigned long)dirp == (unsigned long)((void *)0)) {
        -: 8811:      {
    #####: 8812:        fprintf((FILE * /* __restrict  */) stderr,
        -: 8813:                (char const * /* __restrict  */) "%s: %s unreadable\n",
        -: 8814:                progname, dir);
    #####: 8815:        exit_code = 1;
        -: 8816:      }
    #####: 8817:      return;
        -: 8818:    }
        -: 8819:    {
        -: 8820:      while (1) {
    #####: 8821:      while_continue: /* CIL Label */;
    #####: 8822:        { dp = readdir(dirp); }
    #####: 8823:        if (!((unsigned long)dp != (unsigned long)((void *)0))) {
    #####: 8824:          goto while_break;
        -: 8825:        }
    #####: 8826:        { tmp = strcmp((char const *)(dp->d_name), "."); }
    #####: 8827:        if (tmp == 0) {
    #####: 8828:          goto while_continue;
        -: 8829:        } else {
    #####: 8830:          { tmp___0 = strcmp((char const *)(dp->d_name), ".."); }
    #####: 8831:          if (tmp___0 == 0) {
    #####: 8832:            goto while_continue;
        -: 8833:          }
        -: 8834:        }
        -: 8835:        {
    #####: 8836:          len = (int)strlen((char const *)dir);
    #####: 8837:          tmp___2 = strlen((char const *)(dp->d_name));
        -: 8838:        }
    #####: 8839:        if ((len + (int)tmp___2) + 1 < 1023) {
        -: 8840:          {
    #####: 8841:            strcpy((char * /* __restrict  */)(nbuf),
        -: 8842:                   (char const * /* __restrict  */)dir);
        -: 8843:          }
    #####: 8844:          if (len != 0) {
    #####: 8845:            tmp___1 = len;
    #####: 8846:            len++;
    #####: 8847:            nbuf[tmp___1] = (char)'/';
        -: 8848:          }
        -: 8849:          {
    #####: 8850:            strcpy((char * /* __restrict  */)(nbuf + len),
    #####: 8851:                   (char const * /* __restrict  */)(dp->d_name));
    #####: 8852:            treat_file(nbuf);
        -: 8853:          }
        -: 8854:        } else {
        -: 8855:          {
    #####: 8856:            fprintf((FILE * /* __restrict  */) stderr,
        -: 8857:                    (char const
        -: 8858:                         * /* __restrict  */) "%s: %s/%s: pathname too long\n",
    #####: 8859:                    progname, dir, dp->d_name);
    #####: 8860:            exit_code = 1;
        -: 8861:          }
        -: 8862:        }
        -: 8863:      }
    #####: 8864:    while_break: /* CIL Label */;
        -: 8865:    }
    #####: 8866:    { closedir(dirp); }
    #####: 8867:    return;
        -: 8868:  }
        -: 8869:}
        -: 8870:static int in_exit = 0;
        -: 8872:
        -: 8873:  {
        -: 8875:      {
    #####: 8876:        exit(exitcode);
        -: 8877:      }
        -: 8878:    }
        -: 8881:      {
    #####: 8882:        free((void *)env);
    #####: 8883:        env = (char *)((void *)0);
        -: 8884:      }
        -: 8885:    }
        -: 8887:      {
    #####: 8888:        free((void *)((char *)args));
    #####: 8889:        args = (char **)((void *)0);
        -: 8890:      }
        -: 8891:    }
        -: 8893:  }
        -: 8894:}
    #####: 8895:void abort_gzip(void) {
        -: 8896:
        -: 8897:  {
    #####: 8898:    if (remove_ofname) {
        -: 8899:      {
    #####: 8900:        close(ofd);
    #####: 8901:        unlink((char const *)(ofname));
        -: 8902:      }
        -: 8903:    }
    #####: 8904:    { do_exit(1); }
    #####: 8905:    return;
        -: 8906:  }
        -: 8907:}
